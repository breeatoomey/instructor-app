"use strict";
/******************************************************************************
 * Copyright 2021-2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createServicesForGrammar = exports.loadGrammarFromJson = exports.findNameAssignment = exports.findAssignment = exports.findNodesForKeywordInternal = exports.findNodeForKeyword = exports.findNodesForKeyword = exports.findNodeForProperty = exports.findNodesForProperty = exports.isCommentTerminal = exports.getCrossReferenceTerminal = exports.getAllReachableRules = exports.getHiddenRules = exports.getEntryRule = void 0;
const vscode_uri_1 = require("vscode-uri");
const default_module_1 = require("../default-module");
const dependency_injection_1 = require("../dependency-injection");
const ast_reflection_interpreter_1 = require("../grammar/ast-reflection-interpreter");
const ast = __importStar(require("../grammar/generated/ast"));
const internal_grammar_util_1 = require("../grammar/internal-grammar-util");
const langium_grammar_module_1 = require("../grammar/langium-grammar-module");
const syntax_tree_1 = require("../syntax-tree");
const ast_util_1 = require("../utils/ast-util");
const cst_util_1 = require("../utils/cst-util");
const file_system_provider_1 = require("../workspace/file-system-provider");
/**
 * Returns the entry rule of the given grammar, if any. If the grammar file does not contain an entry rule,
 * the result is `undefined`.
 */
function getEntryRule(grammar) {
    return grammar.rules.find(e => ast.isParserRule(e) && e.entry);
}
exports.getEntryRule = getEntryRule;
/**
 * Returns all hidden terminal rules of the given grammar, if any.
 */
function getHiddenRules(grammar) {
    return grammar.rules.filter((e) => ast.isTerminalRule(e) && e.hidden);
}
exports.getHiddenRules = getHiddenRules;
/**
 * Returns all rules that can be reached from the topmost rules of the specified grammar (entry and hidden terminal rules).
 *
 * @param grammar The grammar that contains all rules
 * @param allTerminals Whether or not to include terminals that are referenced only by other terminals
 * @returns A list of referenced parser and terminal rules. If the grammar contains no entry rule,
 *      this function returns all rules of the specified grammar.
 */
function getAllReachableRules(grammar, allTerminals) {
    const ruleNames = new Set();
    const entryRule = getEntryRule(grammar);
    if (!entryRule) {
        return new Set(grammar.rules);
    }
    const topMostRules = [entryRule].concat(getHiddenRules(grammar));
    for (const rule of topMostRules) {
        ruleDfs(rule, ruleNames, allTerminals);
    }
    const rules = new Set();
    for (const rule of grammar.rules) {
        if (ruleNames.has(rule.name) || (ast.isTerminalRule(rule) && rule.hidden)) {
            rules.add(rule);
        }
    }
    return rules;
}
exports.getAllReachableRules = getAllReachableRules;
function ruleDfs(rule, visitedSet, allTerminals) {
    visitedSet.add(rule.name);
    (0, ast_util_1.streamAllContents)(rule).forEach(node => {
        if (ast.isRuleCall(node) || (allTerminals && ast.isTerminalRuleCall(node))) {
            const refRule = node.rule.ref;
            if (refRule && !visitedSet.has(refRule.name)) {
                ruleDfs(refRule, visitedSet, allTerminals);
            }
        }
    });
}
/**
 * Determines the grammar expression used to parse a cross-reference (usually a reference to a terminal rule).
 * A cross-reference can declare this expression explicitly in the form `[Type : Terminal]`, but if `Terminal`
 * is omitted, this function attempts to infer it from the name of the referenced `Type` (using `findNameAssignment`).
 *
 * Returns the grammar expression used to parse the given cross-reference, or `undefined` if it is not declared
 * and cannot be inferred.
 */
function getCrossReferenceTerminal(crossRef) {
    if (crossRef.terminal) {
        return crossRef.terminal;
    }
    else if (crossRef.type.ref) {
        const nameAssigment = findNameAssignment(crossRef.type.ref);
        return nameAssigment === null || nameAssigment === void 0 ? void 0 : nameAssigment.terminal;
    }
    return undefined;
}
exports.getCrossReferenceTerminal = getCrossReferenceTerminal;
/**
 * Determines whether the given terminal rule represents a comment. This is true if the rule is marked
 * as `hidden` and it does not match white space. This means every hidden token (i.e. excluded from the AST)
 * that contains visible characters is considered a comment.
 */
function isCommentTerminal(terminalRule) {
    return terminalRule.hidden && !(0, internal_grammar_util_1.terminalRegex)(terminalRule).test(' ');
}
exports.isCommentTerminal = isCommentTerminal;
/**
 * Find all CST nodes within the given node that contribute to the specified property.
 *
 * @param node A CST node in which to look for property assignments. If this is undefined, the result is an empty array.
 * @param property A property name of the constructed AST node. If this is undefined, the result is an empty array.
 */
function findNodesForProperty(node, property) {
    if (!node || !property) {
        return [];
    }
    return findNodesForPropertyInternal(node, property, node.element, true);
}
exports.findNodesForProperty = findNodesForProperty;
/**
 * Find a single CST node within the given node that contributes to the specified property.
 *
 * @param node A CST node in which to look for property assignments. If this is undefined, the result is `undefined`.
 * @param property A property name of the constructed AST node. If this is undefined, the result is `undefined`.
 * @param index If no index is specified or the index is less than zero, the first found node is returned. If the
 *        specified index exceeds the number of assignments to the property, the last found node is returned. Otherwise,
 *        the node with the specified index is returned.
 */
function findNodeForProperty(node, property, index) {
    if (!node || !property) {
        return undefined;
    }
    const nodes = findNodesForPropertyInternal(node, property, node.element, true);
    if (nodes.length === 0) {
        return undefined;
    }
    if (index !== undefined) {
        index = Math.max(0, Math.min(index, nodes.length - 1));
    }
    else {
        index = 0;
    }
    return nodes[index];
}
exports.findNodeForProperty = findNodeForProperty;
function findNodesForPropertyInternal(node, property, element, first) {
    if (!first) {
        const nodeFeature = (0, ast_util_1.getContainerOfType)(node.feature, ast.isAssignment);
        if (nodeFeature && nodeFeature.feature === property) {
            return [node];
        }
    }
    if ((0, syntax_tree_1.isCompositeCstNode)(node) && node.element === element) {
        return node.children.flatMap(e => findNodesForPropertyInternal(e, property, element, false));
    }
    return [];
}
/**
 * Find all CST nodes within the given node that correspond to the specified keyword.
 *
 * @param node A CST node in which to look for keywords. If this is undefined, the result is an empty array.
 * @param keyword A keyword as specified in the grammar.
 */
function findNodesForKeyword(node, keyword) {
    if (!node) {
        return [];
    }
    return findNodesForKeywordInternal(node, keyword, node === null || node === void 0 ? void 0 : node.element);
}
exports.findNodesForKeyword = findNodesForKeyword;
/**
 * Find a single CST node within the given node that corresponds to the specified keyword.
 *
 * @param node A CST node in which to look for keywords. If this is undefined, the result is `undefined`.
 * @param keyword A keyword as specified in the grammar.
 * @param index If no index is specified or the index is less than zero, the first found node is returned. If the
 *        specified index exceeds the number of keyword occurrences, the last found node is returned. Otherwise,
 *        the node with the specified index is returned.
 */
function findNodeForKeyword(node, keyword, index) {
    if (!node) {
        return undefined;
    }
    const nodes = findNodesForKeywordInternal(node, keyword, node === null || node === void 0 ? void 0 : node.element);
    if (nodes.length === 0) {
        return undefined;
    }
    if (index !== undefined) {
        index = Math.max(0, Math.min(index, nodes.length - 1));
    }
    else {
        index = 0;
    }
    return nodes[index];
}
exports.findNodeForKeyword = findNodeForKeyword;
function findNodesForKeywordInternal(node, keyword, element) {
    if (node.element !== element) {
        return [];
    }
    if (ast.isKeyword(node.feature) && node.feature.value === keyword) {
        return [node];
    }
    const treeIterator = (0, cst_util_1.streamCst)(node).iterator();
    let result;
    const keywordNodes = [];
    do {
        result = treeIterator.next();
        if (!result.done) {
            const childNode = result.value;
            if (childNode.element === element) {
                if (ast.isKeyword(childNode.feature) && childNode.feature.value === keyword) {
                    keywordNodes.push(childNode);
                }
            }
            else {
                treeIterator.prune();
            }
        }
    } while (!result.done);
    return keywordNodes;
}
exports.findNodesForKeywordInternal = findNodesForKeywordInternal;
/**
 * If the given CST node was parsed in the context of a property assignment, the respective `Assignment` grammar
 * node is returned. If no assignment is found, the result is `undefined`.
 *
 * @param cstNode A CST node for which to find a property assignment.
 */
function findAssignment(cstNode) {
    var _a;
    const astNode = cstNode.element;
    // Only search until the ast node of the parent cst node is no longer the original ast node
    // This would make us jump to a preceding rule call, which contains only unrelated assignments
    while (astNode === ((_a = cstNode.parent) === null || _a === void 0 ? void 0 : _a.element)) {
        const assignment = (0, ast_util_1.getContainerOfType)(cstNode.feature, ast.isAssignment);
        if (assignment) {
            return assignment;
        }
        cstNode = cstNode.parent;
    }
    return undefined;
}
exports.findAssignment = findAssignment;
/**
 * Find an assignment to the `name` property for the given grammar type. This requires the `type` to be inferred
 * from a parser rule, and that rule must contain an assignment to the `name` property. In all other cases,
 * this function returns `undefined`.
 */
function findNameAssignment(type) {
    if (ast.isInferredType(type)) {
        // inferred type is unexpected, extract AbstractType first
        type = type.$container;
    }
    return findNameAssignmentInternal(type, new Map());
}
exports.findNameAssignment = findNameAssignment;
function findNameAssignmentInternal(type, cache) {
    var _a;
    function go(node, refType) {
        let childAssignment = undefined;
        const parentAssignment = (0, ast_util_1.getContainerOfType)(node, ast.isAssignment);
        // No parent assignment implies unassigned rule call
        if (!parentAssignment) {
            childAssignment = findNameAssignmentInternal(refType, cache);
        }
        cache.set(type, childAssignment);
        return childAssignment;
    }
    if (cache.has(type))
        return cache.get(type);
    cache.set(type, undefined);
    for (const node of (0, ast_util_1.streamAllContents)(type)) {
        if (ast.isAssignment(node) && node.feature.toLowerCase() === 'name') {
            cache.set(type, node);
            return node;
        }
        else if (ast.isRuleCall(node) && ast.isParserRule(node.rule.ref)) {
            return go(node, node.rule.ref);
        }
        else if (ast.isSimpleType(node) && ((_a = node.typeRef) === null || _a === void 0 ? void 0 : _a.ref)) {
            return go(node, node.typeRef.ref);
        }
    }
    return undefined;
}
/**
 * Load a Langium grammar for your language from a JSON string. This is used by several services,
 * most notably the parser builder which interprets the grammar to create a parser.
 */
function loadGrammarFromJson(json) {
    var _a;
    const services = (0, langium_grammar_module_1.createLangiumGrammarServices)(file_system_provider_1.EmptyFileSystem).grammar;
    const astNode = services.serializer.JsonSerializer.deserialize(json);
    services.shared.workspace.LangiumDocumentFactory.fromModel(astNode, vscode_uri_1.URI.parse(`memory://${(_a = astNode.name) !== null && _a !== void 0 ? _a : 'grammar'}.langium`));
    return astNode;
}
exports.loadGrammarFromJson = loadGrammarFromJson;
/**
 * Create an instance of the language services for the given grammar. This function is very
 * useful when the grammar is defined on-the-fly, for example in tests of the Langium framework.
 */
async function createServicesForGrammar(config) {
    var _a, _b, _c, _d, _e, _f;
    const grammarServices = (_a = config.grammarServices) !== null && _a !== void 0 ? _a : (0, langium_grammar_module_1.createLangiumGrammarServices)(file_system_provider_1.EmptyFileSystem).grammar;
    const uri = vscode_uri_1.URI.parse('memory:///grammar.langium');
    const factory = grammarServices.shared.workspace.LangiumDocumentFactory;
    const grammarDocument = typeof config.grammar === 'string'
        ? factory.fromString(config.grammar, uri)
        : (0, ast_util_1.getDocument)(config.grammar);
    const grammarNode = grammarDocument.parseResult.value;
    const documentBuilder = grammarServices.shared.workspace.DocumentBuilder;
    await documentBuilder.build([grammarDocument], { validationChecks: 'none' });
    const parserConfig = (_b = config.parserConfig) !== null && _b !== void 0 ? _b : {
        skipValidations: false
    };
    const languageMetaData = (_c = config.languageMetaData) !== null && _c !== void 0 ? _c : {
        caseInsensitive: false,
        fileExtensions: [`.${(_e = (_d = grammarNode.name) === null || _d === void 0 ? void 0 : _d.toLowerCase()) !== null && _e !== void 0 ? _e : 'unknown'}`],
        languageId: (_f = grammarNode.name) !== null && _f !== void 0 ? _f : 'UNKNOWN'
    };
    const generatedSharedModule = {
        AstReflection: () => (0, ast_reflection_interpreter_1.interpretAstReflection)(grammarNode),
    };
    const generatedModule = {
        Grammar: () => grammarNode,
        LanguageMetaData: () => languageMetaData,
        parser: {
            ParserConfig: () => parserConfig
        }
    };
    const shared = (0, dependency_injection_1.inject)((0, default_module_1.createDefaultSharedModule)(file_system_provider_1.EmptyFileSystem), generatedSharedModule, config.sharedModule);
    const services = (0, dependency_injection_1.inject)((0, default_module_1.createDefaultModule)({ shared }), generatedModule, config.module);
    shared.ServiceRegistry.register(services);
    return services;
}
exports.createServicesForGrammar = createServicesForGrammar;
//# sourceMappingURL=grammar-util.js.map