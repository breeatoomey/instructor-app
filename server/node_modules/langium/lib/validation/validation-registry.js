"use strict";
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValidationRegistry = void 0;
const collections_1 = require("../utils/collections");
const promise_util_1 = require("../utils/promise-util");
/**
 * Manages a set of `ValidationCheck`s to be applied when documents are validated.
 */
class ValidationRegistry {
    constructor(services) {
        this.validationChecks = new collections_1.MultiMap();
        this.reflection = services.shared.AstReflection;
    }
    register(checksRecord, thisObj = this) {
        for (const [type, ch] of Object.entries(checksRecord)) {
            const callbacks = ch;
            if (Array.isArray(callbacks)) {
                for (const check of callbacks) {
                    this.doRegister(type, this.wrapValidationException(check, thisObj));
                }
            }
            else if (typeof callbacks === 'function') {
                this.doRegister(type, this.wrapValidationException(callbacks, thisObj));
            }
        }
    }
    wrapValidationException(check, thisObj) {
        return async (node, accept, cancelToken) => {
            try {
                await check.call(thisObj, node, accept, cancelToken);
            }
            catch (err) {
                if ((0, promise_util_1.isOperationCancelled)(err)) {
                    throw err;
                }
                console.error('An error occurred during validation:', err);
                const message = err instanceof Error ? err.message : String(err);
                if (err instanceof Error && err.stack) {
                    console.error(err.stack);
                }
                accept('error', 'An error occurred during validation: ' + message, { node });
            }
        };
    }
    doRegister(type, check) {
        if (type === 'AstNode') {
            this.validationChecks.add('AstNode', check);
            return;
        }
        for (const subtype of this.reflection.getAllSubTypes(type)) {
            this.validationChecks.add(subtype, check);
        }
    }
    getChecks(type) {
        return this.validationChecks.get(type).concat(this.validationChecks.get('AstNode'));
    }
}
exports.ValidationRegistry = ValidationRegistry;
//# sourceMappingURL=validation-registry.js.map