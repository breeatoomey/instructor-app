"use strict";
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.DocumentValidator = exports.toDiagnosticSeverity = exports.getDiagnosticRange = exports.DefaultDocumentValidator = void 0;
const vscode_languageserver_1 = require("vscode-languageserver");
const grammar_util_1 = require("../utils/grammar-util");
const ast_util_1 = require("../utils/ast-util");
const cst_util_1 = require("../utils/cst-util");
const promise_util_1 = require("../utils/promise-util");
class DefaultDocumentValidator {
    constructor(services) {
        this.validationRegistry = services.validation.ValidationRegistry;
        this.metadata = services.LanguageMetaData;
    }
    async validateDocument(document, cancelToken = vscode_languageserver_1.CancellationToken.None) {
        const parseResult = document.parseResult;
        const diagnostics = [];
        await (0, promise_util_1.interruptAndCheck)(cancelToken);
        // Process lexing errors
        for (const lexerError of parseResult.lexerErrors) {
            const diagnostic = {
                severity: vscode_languageserver_1.DiagnosticSeverity.Error,
                range: {
                    start: {
                        line: lexerError.line - 1,
                        character: lexerError.column - 1
                    },
                    end: {
                        line: lexerError.line - 1,
                        character: lexerError.column + lexerError.length - 1
                    }
                },
                message: lexerError.message,
                code: DocumentValidator.LexingError,
                source: this.getSource()
            };
            diagnostics.push(diagnostic);
        }
        // Process parsing errors
        for (const parserError of parseResult.parserErrors) {
            let range = undefined;
            // We can run into the chevrotain error recovery here
            // The token contained in the parser error might be automatically inserted
            // In this case every position value will be `NaN`
            if (isNaN(parserError.token.startOffset)) {
                // Some special parser error types contain a `previousToken`
                // We can simply append our diagnostic to that token
                if ('previousToken' in parserError) {
                    const token = parserError.previousToken;
                    if (!isNaN(token.startOffset)) {
                        const position = vscode_languageserver_1.Position.create(token.endLine - 1, token.endColumn);
                        range = vscode_languageserver_1.Range.create(position, position);
                    }
                    else {
                        // No valid prev token. Might be empty document or containing only hidden tokens.
                        // Point to document start
                        range = vscode_languageserver_1.Range.create(0, 0, 0, 0);
                    }
                }
            }
            else {
                range = (0, cst_util_1.tokenToRange)(parserError.token);
            }
            if (range) {
                const diagnostic = {
                    severity: vscode_languageserver_1.DiagnosticSeverity.Error,
                    range,
                    message: parserError.message,
                    code: DocumentValidator.ParsingError,
                    source: this.getSource()
                };
                diagnostics.push(diagnostic);
            }
        }
        // Process unresolved references
        for (const reference of document.references) {
            const linkingError = reference.error;
            if (linkingError) {
                const data = {
                    containerType: linkingError.container.$type,
                    property: linkingError.property,
                    refText: linkingError.reference.$refText
                };
                const info = {
                    node: linkingError.container,
                    property: linkingError.property,
                    index: linkingError.index,
                    code: DocumentValidator.LinkingError,
                    data
                };
                diagnostics.push(this.toDiagnostic('error', linkingError.message, info));
            }
        }
        // Process custom validations
        try {
            diagnostics.push(...await this.validateAst(parseResult.value, document, cancelToken));
        }
        catch (err) {
            if ((0, promise_util_1.isOperationCancelled)(err)) {
                throw err;
            }
            console.error('An error occurred during validation:', err);
        }
        await (0, promise_util_1.interruptAndCheck)(cancelToken);
        return diagnostics;
    }
    async validateAst(rootNode, document, cancelToken = vscode_languageserver_1.CancellationToken.None) {
        const validationItems = [];
        const acceptor = (severity, message, info) => {
            validationItems.push(this.toDiagnostic(severity, message, info));
        };
        await Promise.all((0, ast_util_1.streamAst)(rootNode).map(async (node) => {
            await (0, promise_util_1.interruptAndCheck)(cancelToken);
            const checks = this.validationRegistry.getChecks(node.$type);
            for (const check of checks) {
                await check(node, acceptor, cancelToken);
            }
        }));
        return validationItems;
    }
    toDiagnostic(severity, message, info) {
        return {
            message,
            range: getDiagnosticRange(info),
            severity: toDiagnosticSeverity(severity),
            code: info.code,
            codeDescription: info.codeDescription,
            tags: info.tags,
            relatedInformation: info.relatedInformation,
            data: info.data,
            source: this.getSource()
        };
    }
    getSource() {
        return this.metadata.languageId;
    }
}
exports.DefaultDocumentValidator = DefaultDocumentValidator;
function getDiagnosticRange(info) {
    if (vscode_languageserver_1.Range.is(info.range)) {
        return info.range;
    }
    let cstNode;
    if (typeof info.property === 'string') {
        cstNode = (0, grammar_util_1.findNodeForProperty)(info.node.$cstNode, info.property, info.index);
    }
    else if (typeof info.keyword === 'string') {
        cstNode = (0, grammar_util_1.findNodeForKeyword)(info.node.$cstNode, info.keyword, info.index);
    }
    cstNode !== null && cstNode !== void 0 ? cstNode : (cstNode = info.node.$cstNode);
    if (!cstNode) {
        return {
            start: { line: 0, character: 0 },
            end: { line: 0, character: 0 }
        };
    }
    return cstNode.range;
}
exports.getDiagnosticRange = getDiagnosticRange;
function toDiagnosticSeverity(severity) {
    switch (severity) {
        case 'error':
            return vscode_languageserver_1.DiagnosticSeverity.Error;
        case 'warning':
            return vscode_languageserver_1.DiagnosticSeverity.Warning;
        case 'info':
            return vscode_languageserver_1.DiagnosticSeverity.Information;
        case 'hint':
            return vscode_languageserver_1.DiagnosticSeverity.Hint;
        default:
            throw new Error('Invalid diagnostic severity: ' + severity);
    }
}
exports.toDiagnosticSeverity = toDiagnosticSeverity;
var DocumentValidator;
(function (DocumentValidator) {
    DocumentValidator.LexingError = 'lexing-error';
    DocumentValidator.ParsingError = 'parsing-error';
    DocumentValidator.LinkingError = 'linking-error';
})(DocumentValidator = exports.DocumentValidator || (exports.DocumentValidator = {}));
//# sourceMappingURL=document-validator.js.map