"use strict";
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultDocumentBuilder = void 0;
const vscode_languageserver_1 = require("vscode-languageserver");
const collections_1 = require("../utils/collections");
const promise_util_1 = require("../utils/promise-util");
const documents_1 = require("./documents");
class DefaultDocumentBuilder {
    constructor(services) {
        this.updateListeners = [];
        this.buildPhaseListeners = new collections_1.MultiMap();
        this.langiumDocuments = services.workspace.LangiumDocuments;
        this.langiumDocumentFactory = services.workspace.LangiumDocumentFactory;
        this.indexManager = services.workspace.IndexManager;
        this.serviceRegistry = services.ServiceRegistry;
    }
    async build(documents, options = {}, cancelToken = vscode_languageserver_1.CancellationToken.None) {
        await this.buildDocuments(documents, options, cancelToken);
    }
    async update(changed, deleted, cancelToken = vscode_languageserver_1.CancellationToken.None) {
        for (const deletedDocument of deleted) {
            this.langiumDocuments.deleteDocument(deletedDocument);
        }
        this.indexManager.remove(deleted);
        for (const changedUri of changed) {
            this.langiumDocuments.invalidateDocument(changedUri);
        }
        for (const listener of this.updateListeners) {
            listener(changed, deleted);
        }
        // Only interrupt execution after everything has been invalidated and update listeners have been notified
        await (0, promise_util_1.interruptAndCheck)(cancelToken);
        const changedDocuments = changed.map(e => this.langiumDocuments.getOrCreateDocument(e));
        const rebuildDocuments = this.collectDocuments(changedDocuments, deleted);
        const buildOptions = {
            // This method is meant to be called after receiving a change notification from the client,
            // so we assume that we want diagnostics to be reported in the editor.
            validationChecks: 'all'
        };
        await this.buildDocuments(rebuildDocuments, buildOptions, cancelToken);
    }
    onUpdate(callback) {
        this.updateListeners.push(callback);
        return vscode_languageserver_1.Disposable.create(() => {
            const index = this.updateListeners.indexOf(callback);
            if (index >= 0) {
                this.updateListeners.splice(index, 1);
            }
        });
    }
    collectDocuments(changed, deleted) {
        const allUris = changed.map(e => e.uri).concat(deleted);
        const affected = this.indexManager.getAffectedDocuments(allUris).toArray();
        affected.forEach(e => {
            const linker = this.serviceRegistry.getServices(e.uri).references.Linker;
            linker.unlink(e);
            e.state = Math.min(e.state, documents_1.DocumentState.ComputedScopes); // need to re-index potentially linked references
        });
        const docSet = new Set([
            ...changed,
            ...affected,
            // Also include all documents haven't completed the document lifecycle yet
            ...this.langiumDocuments.all.filter(e => e.state < documents_1.DocumentState.Validated)
        ]);
        return Array.from(docSet);
    }
    async buildDocuments(documents, options, cancelToken) {
        // 0. Parse content
        //  parsing is done initially for each document, but
        //  re-parsing after changes reported by the client might have been canceled by subsequent changes, so re-parse now
        await this.runCancelable(documents, documents_1.DocumentState.Parsed, cancelToken, doc => this.langiumDocumentFactory.update(doc));
        // 1. Index content
        await this.runCancelable(documents, documents_1.DocumentState.IndexedContent, cancelToken, doc => this.indexManager.updateContent(doc, cancelToken));
        // 2. Compute scopes
        await this.runCancelable(documents, documents_1.DocumentState.ComputedScopes, cancelToken, doc => this.computeScopes(doc, cancelToken));
        // 3. Linking
        await this.runCancelable(documents, documents_1.DocumentState.Linked, cancelToken, doc => this.serviceRegistry.getServices(doc.uri).references.Linker.link(doc, cancelToken));
        // 4. Index references
        await this.runCancelable(documents, documents_1.DocumentState.IndexedReferences, cancelToken, doc => this.indexManager.updateReferences(doc, cancelToken));
        // 5. Validation
        const validateDocs = documents.filter(doc => this.shouldValidate(doc, options));
        await this.runCancelable(validateDocs, documents_1.DocumentState.Validated, cancelToken, doc => this.validate(doc, cancelToken));
    }
    async runCancelable(documents, targetState, cancelToken, callback) {
        const filtered = documents.filter(e => e.state < targetState);
        for (const document of filtered) {
            await (0, promise_util_1.interruptAndCheck)(cancelToken);
            await callback(document);
        }
        await this.notifyBuildPhase(filtered, targetState, cancelToken);
    }
    onBuildPhase(targetState, callback) {
        this.buildPhaseListeners.add(targetState, callback);
        return vscode_languageserver_1.Disposable.create(() => {
            this.buildPhaseListeners.delete(targetState, callback);
        });
    }
    async notifyBuildPhase(documents, state, cancelToken) {
        if (documents.length === 0) {
            // Don't notify when no document has been processed
            return;
        }
        const listeners = this.buildPhaseListeners.get(state);
        for (const listener of listeners) {
            await (0, promise_util_1.interruptAndCheck)(cancelToken);
            await listener(documents, cancelToken);
        }
    }
    /**
     * Precompute the local scopes of the given document. The resulting data structure is used by
     * the `ScopeProvider` service to determine the visible scope of any cross-reference.
     *
     * _Note:_ You should not resolve any cross-references during this phase. Once the phase is completed,
     * you may follow the `ref` property of a reference, which triggers lazy resolution. The result is
     * either the respective target AST node or `undefined` in case the target is not in scope.
     */
    async computeScopes(document, cancelToken) {
        const scopeComputation = this.serviceRegistry.getServices(document.uri).references.ScopeComputation;
        document.precomputedScopes = await scopeComputation.computeLocalScopes(document, cancelToken);
        document.state = documents_1.DocumentState.ComputedScopes;
    }
    /**
     * Determine whether the given document should be validated during a build. The default
     * implementation checks the `validationChecks` property of the build options.
     */
    shouldValidate(_document, options) {
        return options.validationChecks === 'all';
    }
    /**
     * Run validation checks on the given document and store the resulting diagnostics in the document.
     */
    async validate(document, cancelToken) {
        const validator = this.serviceRegistry.getServices(document.uri).validation.DocumentValidator;
        const diagnostics = await validator.validateDocument(document, cancelToken);
        document.diagnostics = diagnostics;
        document.state = documents_1.DocumentState.Validated;
    }
}
exports.DefaultDocumentBuilder = DefaultDocumentBuilder;
//# sourceMappingURL=document-builder.js.map