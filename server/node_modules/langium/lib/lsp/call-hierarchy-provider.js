"use strict";
/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractCallHierarchyProvider = void 0;
const vscode_languageserver_1 = require("vscode-languageserver");
const vscode_uri_1 = require("vscode-uri");
const cst_util_1 = require("../utils/cst-util");
class AbstractCallHierarchyProvider {
    constructor(services) {
        this.grammarConfig = services.parser.GrammarConfig;
        this.nameProvider = services.references.NameProvider;
        this.documents = services.shared.workspace.LangiumDocuments;
        this.references = services.references.References;
    }
    prepareCallHierarchy(document, params) {
        const rootNode = document.parseResult.value;
        const targetNode = (0, cst_util_1.findDeclarationNodeAtOffset)(rootNode.$cstNode, document.textDocument.offsetAt(params.position), this.grammarConfig.nameRegexp);
        if (!targetNode) {
            return undefined;
        }
        const declarationNode = this.references.findDeclarationNode(targetNode);
        if (!declarationNode) {
            return undefined;
        }
        return this.getCallHierarchyItems(declarationNode.element, document);
    }
    getCallHierarchyItems(targetNode, document) {
        const nameNode = this.nameProvider.getNameNode(targetNode);
        const name = this.nameProvider.getName(targetNode);
        if (!nameNode || !targetNode.$cstNode || name === undefined) {
            return undefined;
        }
        return [Object.assign({ kind: vscode_languageserver_1.SymbolKind.Method, name, range: targetNode.$cstNode.range, selectionRange: nameNode.range, uri: document.uri.toString() }, this.getCallHierarchyItem(targetNode))];
    }
    getCallHierarchyItem(_targetNode) {
        return undefined;
    }
    incomingCalls(params) {
        const document = this.documents.getOrCreateDocument(vscode_uri_1.URI.parse(params.item.uri));
        const rootNode = document.parseResult.value;
        const targetNode = (0, cst_util_1.findDeclarationNodeAtOffset)(rootNode.$cstNode, document.textDocument.offsetAt(params.item.range.start), this.grammarConfig.nameRegexp);
        if (!targetNode) {
            return undefined;
        }
        const references = this.references.findReferences(targetNode.element, {
            includeDeclaration: false
        });
        return this.getIncomingCalls(targetNode.element, references);
    }
    outgoingCalls(params) {
        const document = this.documents.getOrCreateDocument(vscode_uri_1.URI.parse(params.item.uri));
        const rootNode = document.parseResult.value;
        const targetNode = (0, cst_util_1.findDeclarationNodeAtOffset)(rootNode.$cstNode, document.textDocument.offsetAt(params.item.range.start), this.grammarConfig.nameRegexp);
        if (!targetNode) {
            return undefined;
        }
        return this.getOutgoingCalls(targetNode.element);
    }
}
exports.AbstractCallHierarchyProvider = AbstractCallHierarchyProvider;
//# sourceMappingURL=call-hierarchy-provider.js.map