"use strict";
/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.interpretAstReflection = void 0;
const syntax_tree_1 = require("../syntax-tree");
const collections_1 = require("../utils/collections");
const ast_1 = require("./generated/ast");
const ast_collector_1 = require("./type-system/ast-collector");
const types_util_1 = require("./type-system/types-util");
function interpretAstReflection(grammarOrTypes, documents) {
    let collectedTypes;
    if ((0, ast_1.isGrammar)(grammarOrTypes)) {
        collectedTypes = (0, ast_collector_1.collectAst)(grammarOrTypes, documents);
    }
    else {
        collectedTypes = grammarOrTypes;
    }
    const allTypes = collectedTypes.interfaces.map(e => e.name).concat(collectedTypes.unions.filter(e => (0, types_util_1.isAstType)(e.type)).map(e => e.name));
    const references = buildReferenceTypes(collectedTypes);
    const metaData = buildTypeMetaData(collectedTypes);
    const superTypes = (0, types_util_1.collectTypeHierarchy)((0, types_util_1.mergeTypesAndInterfaces)(collectedTypes)).superTypes;
    return new InterpretedAstReflection({
        allTypes,
        references,
        metaData,
        superTypes
    });
}
exports.interpretAstReflection = interpretAstReflection;
class InterpretedAstReflection extends syntax_tree_1.AbstractAstReflection {
    constructor(options) {
        super();
        this.allTypes = options.allTypes;
        this.references = options.references;
        this.metaData = options.metaData;
        this.superTypes = options.superTypes;
    }
    getAllTypes() {
        return this.allTypes;
    }
    getReferenceType(refInfo) {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        const referenceType = this.references.get(referenceId);
        if (referenceType) {
            return referenceType;
        }
        throw new Error('Could not find reference type for ' + referenceId);
    }
    getTypeMetaData(type) {
        var _a;
        return (_a = this.metaData.get(type)) !== null && _a !== void 0 ? _a : {
            name: type,
            mandatory: []
        };
    }
    computeIsSubtype(subtype, originalSuperType) {
        const superTypes = this.superTypes.get(subtype);
        for (const superType of superTypes) {
            if (this.isSubtype(superType, originalSuperType)) {
                return true;
            }
        }
        return false;
    }
}
function buildReferenceTypes(astTypes) {
    const references = new collections_1.MultiMap();
    for (const interfaceType of astTypes.interfaces) {
        for (const property of interfaceType.properties) {
            for (const referenceType of (0, types_util_1.findReferenceTypes)(property.type)) {
                references.add(interfaceType.name, [property.name, referenceType]);
            }
        }
        for (const superType of interfaceType.interfaceSuperTypes) {
            const superTypeReferences = references.get(superType.name);
            references.addAll(interfaceType.name, superTypeReferences);
        }
    }
    const map = new Map();
    for (const [type, [property, target]] of references) {
        map.set(`${type}:${property}`, target);
    }
    return map;
}
function buildTypeMetaData(astTypes) {
    const map = new Map();
    for (const interfaceType of astTypes.interfaces) {
        const props = interfaceType.superProperties;
        const arrayProps = props.filter(e => (0, types_util_1.hasArrayType)(e.type));
        const booleanProps = props.filter(e => !(0, types_util_1.hasArrayType)(e.type) && (0, types_util_1.hasBooleanType)(e.type));
        if (arrayProps.length > 0 || booleanProps.length > 0) {
            map.set(interfaceType.name, {
                name: interfaceType.name,
                mandatory: buildMandatoryMetaData(arrayProps, booleanProps)
            });
        }
    }
    return map;
}
function buildMandatoryMetaData(arrayProps, booleanProps) {
    const array = [];
    const all = arrayProps.concat(booleanProps).sort((a, b) => a.name.localeCompare(b.name));
    for (const property of all) {
        const type = arrayProps.includes(property) ? 'array' : 'boolean';
        array.push({
            name: property.name,
            type
        });
    }
    return array;
}
//# sourceMappingURL=ast-reflection-interpreter.js.map