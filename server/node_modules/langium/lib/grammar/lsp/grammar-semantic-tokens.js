"use strict";
/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.LangiumGrammarSemanticTokenProvider = void 0;
const vscode_languageserver_1 = require("vscode-languageserver");
const semantic_token_provider_1 = require("../../lsp/semantic-token-provider");
const ast_1 = require("../generated/ast");
class LangiumGrammarSemanticTokenProvider extends semantic_token_provider_1.AbstractSemanticTokenProvider {
    highlightElement(node, acceptor) {
        var _a;
        if ((0, ast_1.isAssignment)(node)) {
            acceptor({
                node,
                property: 'feature',
                type: vscode_languageserver_1.SemanticTokenTypes.property
            });
        }
        else if ((0, ast_1.isAction)(node)) {
            if (node.feature) {
                acceptor({
                    node,
                    property: 'feature',
                    type: vscode_languageserver_1.SemanticTokenTypes.property
                });
            }
        }
        else if ((0, ast_1.isReturnType)(node)) {
            acceptor({
                node,
                property: 'name',
                type: vscode_languageserver_1.SemanticTokenTypes.type
            });
        }
        else if ((0, ast_1.isSimpleType)(node)) {
            if (node.primitiveType || node.typeRef) {
                acceptor({
                    node,
                    property: node.primitiveType ? 'primitiveType' : 'typeRef',
                    type: vscode_languageserver_1.SemanticTokenTypes.type
                });
            }
        }
        else if ((0, ast_1.isParameter)(node)) {
            acceptor({
                node,
                property: 'name',
                type: vscode_languageserver_1.SemanticTokenTypes.parameter
            });
        }
        else if ((0, ast_1.isParameterReference)(node)) {
            acceptor({
                node,
                property: 'parameter',
                type: vscode_languageserver_1.SemanticTokenTypes.parameter
            });
        }
        else if ((0, ast_1.isRuleCall)(node)) {
            if ((_a = node.rule.ref) === null || _a === void 0 ? void 0 : _a.fragment) {
                acceptor({
                    node,
                    property: 'rule',
                    type: vscode_languageserver_1.SemanticTokenTypes.type
                });
            }
        }
        else if ((0, ast_1.isTypeAttribute)(node)) {
            acceptor({
                node,
                property: 'name',
                type: vscode_languageserver_1.SemanticTokenTypes.property
            });
        }
    }
}
exports.LangiumGrammarSemanticTokenProvider = LangiumGrammarSemanticTokenProvider;
//# sourceMappingURL=grammar-semantic-tokens.js.map