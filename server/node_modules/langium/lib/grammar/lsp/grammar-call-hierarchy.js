"use strict";
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.LangiumGrammarCallHierarchyProvider = void 0;
const vscode_languageserver_1 = require("vscode-languageserver");
const call_hierarchy_provider_1 = require("../../lsp/call-hierarchy-provider");
const ast_util_1 = require("../../utils/ast-util");
const cst_util_1 = require("../../utils/cst-util");
const ast_1 = require("../generated/ast");
class LangiumGrammarCallHierarchyProvider extends call_hierarchy_provider_1.AbstractCallHierarchyProvider {
    getIncomingCalls(node, references) {
        if (!(0, ast_1.isParserRule)(node)) {
            return undefined;
        }
        // This map is used to group incoming calls to avoid duplicates.
        const uniqueRules = new Map();
        references.forEach(ref => {
            const doc = this.documents.getOrCreateDocument(ref.sourceUri);
            const rootNode = doc.parseResult.value;
            if (!rootNode.$cstNode) {
                return;
            }
            const targetNode = (0, cst_util_1.findLeafNodeAtOffset)(rootNode.$cstNode, ref.segment.offset);
            if (!targetNode) {
                return;
            }
            const parserRule = (0, ast_util_1.getContainerOfType)(targetNode.element, ast_1.isParserRule);
            if (!parserRule || !parserRule.$cstNode) {
                return;
            }
            const nameNode = this.nameProvider.getNameNode(parserRule);
            if (!nameNode) {
                return;
            }
            const refDocUri = ref.sourceUri.toString();
            const ruleId = refDocUri + '@' + nameNode.text;
            uniqueRules.has(ruleId) ?
                uniqueRules.set(ruleId, { parserRule: parserRule.$cstNode, nameNode, targetNodes: [...uniqueRules.get(ruleId).targetNodes, targetNode], docUri: refDocUri })
                : uniqueRules.set(ruleId, { parserRule: parserRule.$cstNode, nameNode, targetNodes: [targetNode], docUri: refDocUri });
        });
        if (uniqueRules.size === 0) {
            return undefined;
        }
        return Array.from(uniqueRules.values()).map(rule => ({
            from: {
                kind: vscode_languageserver_1.SymbolKind.Method,
                name: rule.nameNode.text,
                range: rule.parserRule.range,
                selectionRange: rule.nameNode.range,
                uri: rule.docUri
            },
            fromRanges: rule.targetNodes.map(node => node.range)
        }));
    }
    getOutgoingCalls(node) {
        if (!(0, ast_1.isParserRule)(node)) {
            return undefined;
        }
        const ruleCalls = (0, ast_util_1.streamAllContents)(node).filter(ast_1.isRuleCall).toArray();
        // This map is used to group outgoing calls to avoid duplicates.
        const uniqueRules = new Map();
        ruleCalls.forEach(ruleCall => {
            var _a;
            const cstNode = ruleCall.$cstNode;
            if (!cstNode) {
                return;
            }
            const refCstNode = (_a = ruleCall.rule.ref) === null || _a === void 0 ? void 0 : _a.$cstNode;
            if (!refCstNode) {
                return;
            }
            const refNameNode = this.nameProvider.getNameNode(refCstNode.element);
            if (!refNameNode) {
                return;
            }
            const refDocUri = (0, ast_util_1.getDocument)(refCstNode.element).uri.toString();
            const ruleId = refDocUri + '@' + refNameNode.text;
            uniqueRules.has(ruleId) ?
                uniqueRules.set(ruleId, { refCstNode: refCstNode, to: refNameNode, from: [...uniqueRules.get(ruleId).from, cstNode.range], docUri: refDocUri })
                : uniqueRules.set(ruleId, { refCstNode: refCstNode, to: refNameNode, from: [cstNode.range], docUri: refDocUri });
        });
        if (uniqueRules.size === 0) {
            return undefined;
        }
        return Array.from(uniqueRules.values()).map(rule => ({
            to: {
                kind: vscode_languageserver_1.SymbolKind.Method,
                name: rule.to.text,
                range: rule.refCstNode.range,
                selectionRange: rule.to.range,
                uri: rule.docUri
            },
            fromRanges: rule.from
        }));
    }
}
exports.LangiumGrammarCallHierarchyProvider = LangiumGrammarCallHierarchyProvider;
//# sourceMappingURL=grammar-call-hierarchy.js.map