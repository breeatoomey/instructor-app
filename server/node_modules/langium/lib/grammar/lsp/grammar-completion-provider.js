"use strict";
/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.LangiumGrammarCompletionProvider = void 0;
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const completion_provider_1 = require("../../lsp/completion/completion-provider");
const ast_util_1 = require("../../utils/ast-util");
const uri_util_1 = require("../../utils/uri-util");
const ast_1 = require("../generated/ast");
const vscode_uri_1 = require("vscode-uri");
class LangiumGrammarCompletionProvider extends completion_provider_1.DefaultCompletionProvider {
    constructor(services) {
        super(services);
        this.documents = () => services.shared.workspace.LangiumDocuments;
    }
    completionFor(context, next, acceptor) {
        const assignment = (0, ast_util_1.getContainerOfType)(next.feature, ast_1.isAssignment);
        if ((assignment === null || assignment === void 0 ? void 0 : assignment.feature) === 'path') {
            this.completeImportPath(context, acceptor);
        }
        else {
            return super.completionFor(context, next, acceptor);
        }
    }
    completeImportPath(context, acceptor) {
        const text = context.textDocument.getText();
        const existingText = text.substring(context.tokenOffset, context.offset);
        let allPaths = this.getAllFiles(context.document);
        let range = {
            start: context.position,
            end: context.position
        };
        if (existingText.length > 0) {
            const existingPath = existingText.substring(1);
            allPaths = allPaths.filter(path => path.startsWith(existingPath));
            // Completely replace the current token
            const start = context.textDocument.positionAt(context.tokenOffset + 1);
            const end = context.textDocument.positionAt(context.tokenEndOffset - 1);
            range = {
                start,
                end
            };
        }
        for (const path of allPaths) {
            // Only insert quotes if there is no `path` token yet.
            const delimiter = existingText.length > 0 ? '' : '"';
            const completionValue = `${delimiter}${path}${delimiter}`;
            acceptor(context, {
                label: path,
                textEdit: {
                    newText: completionValue,
                    range
                },
                kind: vscode_languageserver_types_1.CompletionItemKind.File,
                sortText: '0'
            });
        }
    }
    getAllFiles(document) {
        const documents = this.documents().all;
        const uri = document.uri.toString();
        const dirname = vscode_uri_1.Utils.dirname(document.uri).toString();
        const paths = [];
        for (const doc of documents) {
            if (!(0, uri_util_1.equalURI)(doc.uri, uri)) {
                const docUri = doc.uri.toString();
                const uriWithoutExt = docUri.substring(0, docUri.length - vscode_uri_1.Utils.extname(doc.uri).length);
                let relativePath = (0, uri_util_1.relativeURI)(dirname, uriWithoutExt);
                if (!relativePath.startsWith('.')) {
                    relativePath = `./${relativePath}`;
                }
                paths.push(relativePath);
            }
        }
        return paths;
    }
}
exports.LangiumGrammarCompletionProvider = LangiumGrammarCompletionProvider;
//# sourceMappingURL=grammar-completion-provider.js.map