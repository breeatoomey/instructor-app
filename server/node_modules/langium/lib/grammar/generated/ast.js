"use strict";
/******************************************************************************
 * This file was generated by langium-cli 1.2.1.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeAttribute = exports.isType = exports.Type = exports.isTerminalRule = exports.TerminalRule = exports.isSimpleType = exports.SimpleType = exports.isReturnType = exports.ReturnType = exports.isReferenceType = exports.ReferenceType = exports.isParserRule = exports.ParserRule = exports.isParameterReference = exports.ParameterReference = exports.isParameter = exports.Parameter = exports.isNegation = exports.Negation = exports.isNamedArgument = exports.NamedArgument = exports.isLiteralCondition = exports.LiteralCondition = exports.isInterface = exports.Interface = exports.isInferredType = exports.InferredType = exports.isGrammarImport = exports.GrammarImport = exports.isGrammar = exports.Grammar = exports.isDisjunction = exports.Disjunction = exports.isConjunction = exports.Conjunction = exports.isArrayType = exports.ArrayType = exports.isAbstractElement = exports.AbstractElement = exports.isTypeDefinition = exports.TypeDefinition = exports.isPrimitiveType = exports.isFeatureName = exports.isCondition = exports.Condition = exports.isAbstractType = exports.AbstractType = exports.isAbstractRule = exports.AbstractRule = exports.LangiumGrammarTerminals = void 0;
exports.reflection = exports.LangiumGrammarAstReflection = exports.isWildcard = exports.Wildcard = exports.isUntilToken = exports.UntilToken = exports.isUnorderedGroup = exports.UnorderedGroup = exports.isTerminalRuleCall = exports.TerminalRuleCall = exports.isTerminalGroup = exports.TerminalGroup = exports.isTerminalAlternatives = exports.TerminalAlternatives = exports.isRuleCall = exports.RuleCall = exports.isRegexToken = exports.RegexToken = exports.isNegatedToken = exports.NegatedToken = exports.isKeyword = exports.Keyword = exports.isGroup = exports.Group = exports.isCrossReference = exports.CrossReference = exports.isCharacterRange = exports.CharacterRange = exports.isAssignment = exports.Assignment = exports.isAlternatives = exports.Alternatives = exports.isAction = exports.Action = exports.isUnionType = exports.UnionType = exports.isTypeAttribute = void 0;
const syntax_tree_1 = require("../../syntax-tree");
exports.LangiumGrammarTerminals = {
    ID: /\^?[_a-zA-Z][\w_]*/,
    STRING: /"(\\.|[^"\\])*"|'(\\.|[^'\\])*'/,
    RegexLiteral: /\/(?![*+?])(?:[^\r\n\[/\\]|\\.|\[(?:[^\r\n\]\\]|\\.)*\])+\/[a-z]*/,
    WS: /\s+/,
    ML_COMMENT: /\/\*[\s\S]*?\*\//,
    SL_COMMENT: /\/\/[^\n\r]*/,
};
exports.AbstractRule = 'AbstractRule';
function isAbstractRule(item) {
    return exports.reflection.isInstance(item, exports.AbstractRule);
}
exports.isAbstractRule = isAbstractRule;
exports.AbstractType = 'AbstractType';
function isAbstractType(item) {
    return exports.reflection.isInstance(item, exports.AbstractType);
}
exports.isAbstractType = isAbstractType;
exports.Condition = 'Condition';
function isCondition(item) {
    return exports.reflection.isInstance(item, exports.Condition);
}
exports.isCondition = isCondition;
function isFeatureName(item) {
    return isPrimitiveType(item) || item === 'current' || item === 'entry' || item === 'extends' || item === 'false' || item === 'fragment' || item === 'grammar' || item === 'hidden' || item === 'import' || item === 'interface' || item === 'returns' || item === 'terminal' || item === 'true' || item === 'type' || item === 'infer' || item === 'infers' || item === 'with' || (typeof item === 'string' && (/\^?[_a-zA-Z][\w_]*/.test(item)));
}
exports.isFeatureName = isFeatureName;
function isPrimitiveType(item) {
    return item === 'string' || item === 'number' || item === 'boolean' || item === 'Date' || item === 'bigint';
}
exports.isPrimitiveType = isPrimitiveType;
exports.TypeDefinition = 'TypeDefinition';
function isTypeDefinition(item) {
    return exports.reflection.isInstance(item, exports.TypeDefinition);
}
exports.isTypeDefinition = isTypeDefinition;
exports.AbstractElement = 'AbstractElement';
function isAbstractElement(item) {
    return exports.reflection.isInstance(item, exports.AbstractElement);
}
exports.isAbstractElement = isAbstractElement;
exports.ArrayType = 'ArrayType';
function isArrayType(item) {
    return exports.reflection.isInstance(item, exports.ArrayType);
}
exports.isArrayType = isArrayType;
exports.Conjunction = 'Conjunction';
function isConjunction(item) {
    return exports.reflection.isInstance(item, exports.Conjunction);
}
exports.isConjunction = isConjunction;
exports.Disjunction = 'Disjunction';
function isDisjunction(item) {
    return exports.reflection.isInstance(item, exports.Disjunction);
}
exports.isDisjunction = isDisjunction;
exports.Grammar = 'Grammar';
function isGrammar(item) {
    return exports.reflection.isInstance(item, exports.Grammar);
}
exports.isGrammar = isGrammar;
exports.GrammarImport = 'GrammarImport';
function isGrammarImport(item) {
    return exports.reflection.isInstance(item, exports.GrammarImport);
}
exports.isGrammarImport = isGrammarImport;
exports.InferredType = 'InferredType';
function isInferredType(item) {
    return exports.reflection.isInstance(item, exports.InferredType);
}
exports.isInferredType = isInferredType;
exports.Interface = 'Interface';
function isInterface(item) {
    return exports.reflection.isInstance(item, exports.Interface);
}
exports.isInterface = isInterface;
exports.LiteralCondition = 'LiteralCondition';
function isLiteralCondition(item) {
    return exports.reflection.isInstance(item, exports.LiteralCondition);
}
exports.isLiteralCondition = isLiteralCondition;
exports.NamedArgument = 'NamedArgument';
function isNamedArgument(item) {
    return exports.reflection.isInstance(item, exports.NamedArgument);
}
exports.isNamedArgument = isNamedArgument;
exports.Negation = 'Negation';
function isNegation(item) {
    return exports.reflection.isInstance(item, exports.Negation);
}
exports.isNegation = isNegation;
exports.Parameter = 'Parameter';
function isParameter(item) {
    return exports.reflection.isInstance(item, exports.Parameter);
}
exports.isParameter = isParameter;
exports.ParameterReference = 'ParameterReference';
function isParameterReference(item) {
    return exports.reflection.isInstance(item, exports.ParameterReference);
}
exports.isParameterReference = isParameterReference;
exports.ParserRule = 'ParserRule';
function isParserRule(item) {
    return exports.reflection.isInstance(item, exports.ParserRule);
}
exports.isParserRule = isParserRule;
exports.ReferenceType = 'ReferenceType';
function isReferenceType(item) {
    return exports.reflection.isInstance(item, exports.ReferenceType);
}
exports.isReferenceType = isReferenceType;
exports.ReturnType = 'ReturnType';
function isReturnType(item) {
    return exports.reflection.isInstance(item, exports.ReturnType);
}
exports.isReturnType = isReturnType;
exports.SimpleType = 'SimpleType';
function isSimpleType(item) {
    return exports.reflection.isInstance(item, exports.SimpleType);
}
exports.isSimpleType = isSimpleType;
exports.TerminalRule = 'TerminalRule';
function isTerminalRule(item) {
    return exports.reflection.isInstance(item, exports.TerminalRule);
}
exports.isTerminalRule = isTerminalRule;
exports.Type = 'Type';
function isType(item) {
    return exports.reflection.isInstance(item, exports.Type);
}
exports.isType = isType;
exports.TypeAttribute = 'TypeAttribute';
function isTypeAttribute(item) {
    return exports.reflection.isInstance(item, exports.TypeAttribute);
}
exports.isTypeAttribute = isTypeAttribute;
exports.UnionType = 'UnionType';
function isUnionType(item) {
    return exports.reflection.isInstance(item, exports.UnionType);
}
exports.isUnionType = isUnionType;
exports.Action = 'Action';
function isAction(item) {
    return exports.reflection.isInstance(item, exports.Action);
}
exports.isAction = isAction;
exports.Alternatives = 'Alternatives';
function isAlternatives(item) {
    return exports.reflection.isInstance(item, exports.Alternatives);
}
exports.isAlternatives = isAlternatives;
exports.Assignment = 'Assignment';
function isAssignment(item) {
    return exports.reflection.isInstance(item, exports.Assignment);
}
exports.isAssignment = isAssignment;
exports.CharacterRange = 'CharacterRange';
function isCharacterRange(item) {
    return exports.reflection.isInstance(item, exports.CharacterRange);
}
exports.isCharacterRange = isCharacterRange;
exports.CrossReference = 'CrossReference';
function isCrossReference(item) {
    return exports.reflection.isInstance(item, exports.CrossReference);
}
exports.isCrossReference = isCrossReference;
exports.Group = 'Group';
function isGroup(item) {
    return exports.reflection.isInstance(item, exports.Group);
}
exports.isGroup = isGroup;
exports.Keyword = 'Keyword';
function isKeyword(item) {
    return exports.reflection.isInstance(item, exports.Keyword);
}
exports.isKeyword = isKeyword;
exports.NegatedToken = 'NegatedToken';
function isNegatedToken(item) {
    return exports.reflection.isInstance(item, exports.NegatedToken);
}
exports.isNegatedToken = isNegatedToken;
exports.RegexToken = 'RegexToken';
function isRegexToken(item) {
    return exports.reflection.isInstance(item, exports.RegexToken);
}
exports.isRegexToken = isRegexToken;
exports.RuleCall = 'RuleCall';
function isRuleCall(item) {
    return exports.reflection.isInstance(item, exports.RuleCall);
}
exports.isRuleCall = isRuleCall;
exports.TerminalAlternatives = 'TerminalAlternatives';
function isTerminalAlternatives(item) {
    return exports.reflection.isInstance(item, exports.TerminalAlternatives);
}
exports.isTerminalAlternatives = isTerminalAlternatives;
exports.TerminalGroup = 'TerminalGroup';
function isTerminalGroup(item) {
    return exports.reflection.isInstance(item, exports.TerminalGroup);
}
exports.isTerminalGroup = isTerminalGroup;
exports.TerminalRuleCall = 'TerminalRuleCall';
function isTerminalRuleCall(item) {
    return exports.reflection.isInstance(item, exports.TerminalRuleCall);
}
exports.isTerminalRuleCall = isTerminalRuleCall;
exports.UnorderedGroup = 'UnorderedGroup';
function isUnorderedGroup(item) {
    return exports.reflection.isInstance(item, exports.UnorderedGroup);
}
exports.isUnorderedGroup = isUnorderedGroup;
exports.UntilToken = 'UntilToken';
function isUntilToken(item) {
    return exports.reflection.isInstance(item, exports.UntilToken);
}
exports.isUntilToken = isUntilToken;
exports.Wildcard = 'Wildcard';
function isWildcard(item) {
    return exports.reflection.isInstance(item, exports.Wildcard);
}
exports.isWildcard = isWildcard;
class LangiumGrammarAstReflection extends syntax_tree_1.AbstractAstReflection {
    getAllTypes() {
        return ['AbstractElement', 'AbstractRule', 'AbstractType', 'Action', 'Alternatives', 'ArrayType', 'Assignment', 'CharacterRange', 'Condition', 'Conjunction', 'CrossReference', 'Disjunction', 'Grammar', 'GrammarImport', 'Group', 'InferredType', 'Interface', 'Keyword', 'LiteralCondition', 'NamedArgument', 'NegatedToken', 'Negation', 'Parameter', 'ParameterReference', 'ParserRule', 'ReferenceType', 'RegexToken', 'ReturnType', 'RuleCall', 'SimpleType', 'TerminalAlternatives', 'TerminalGroup', 'TerminalRule', 'TerminalRuleCall', 'Type', 'TypeAttribute', 'TypeDefinition', 'UnionType', 'UnorderedGroup', 'UntilToken', 'Wildcard'];
    }
    computeIsSubtype(subtype, supertype) {
        switch (subtype) {
            case exports.Action: {
                return this.isSubtype(exports.AbstractElement, supertype) || this.isSubtype(exports.AbstractType, supertype);
            }
            case exports.Alternatives:
            case exports.Assignment:
            case exports.CharacterRange:
            case exports.CrossReference:
            case exports.Group:
            case exports.Keyword:
            case exports.NegatedToken:
            case exports.RegexToken:
            case exports.RuleCall:
            case exports.TerminalAlternatives:
            case exports.TerminalGroup:
            case exports.TerminalRuleCall:
            case exports.UnorderedGroup:
            case exports.UntilToken:
            case exports.Wildcard: {
                return this.isSubtype(exports.AbstractElement, supertype);
            }
            case exports.ArrayType:
            case exports.ReferenceType:
            case exports.SimpleType:
            case exports.UnionType: {
                return this.isSubtype(exports.TypeDefinition, supertype);
            }
            case exports.Conjunction:
            case exports.Disjunction:
            case exports.LiteralCondition:
            case exports.Negation:
            case exports.ParameterReference: {
                return this.isSubtype(exports.Condition, supertype);
            }
            case exports.Interface:
            case exports.Type: {
                return this.isSubtype(exports.AbstractType, supertype);
            }
            case exports.ParserRule: {
                return this.isSubtype(exports.AbstractRule, supertype) || this.isSubtype(exports.AbstractType, supertype);
            }
            case exports.TerminalRule: {
                return this.isSubtype(exports.AbstractRule, supertype);
            }
            default: {
                return false;
            }
        }
    }
    getReferenceType(refInfo) {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'Action:type':
            case 'CrossReference:type':
            case 'Interface:superTypes':
            case 'ParserRule:returnType':
            case 'SimpleType:typeRef': {
                return exports.AbstractType;
            }
            case 'Grammar:hiddenTokens':
            case 'ParserRule:hiddenTokens':
            case 'RuleCall:rule': {
                return exports.AbstractRule;
            }
            case 'Grammar:usedGrammars': {
                return exports.Grammar;
            }
            case 'NamedArgument:parameter':
            case 'ParameterReference:parameter': {
                return exports.Parameter;
            }
            case 'TerminalRuleCall:rule': {
                return exports.TerminalRule;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }
    getTypeMetaData(type) {
        switch (type) {
            case 'Grammar': {
                return {
                    name: 'Grammar',
                    mandatory: [
                        { name: 'definesHiddenTokens', type: 'boolean' },
                        { name: 'hiddenTokens', type: 'array' },
                        { name: 'imports', type: 'array' },
                        { name: 'interfaces', type: 'array' },
                        { name: 'isDeclared', type: 'boolean' },
                        { name: 'rules', type: 'array' },
                        { name: 'types', type: 'array' },
                        { name: 'usedGrammars', type: 'array' }
                    ]
                };
            }
            case 'Interface': {
                return {
                    name: 'Interface',
                    mandatory: [
                        { name: 'attributes', type: 'array' },
                        { name: 'superTypes', type: 'array' }
                    ]
                };
            }
            case 'LiteralCondition': {
                return {
                    name: 'LiteralCondition',
                    mandatory: [
                        { name: 'true', type: 'boolean' }
                    ]
                };
            }
            case 'NamedArgument': {
                return {
                    name: 'NamedArgument',
                    mandatory: [
                        { name: 'calledByName', type: 'boolean' }
                    ]
                };
            }
            case 'ParserRule': {
                return {
                    name: 'ParserRule',
                    mandatory: [
                        { name: 'definesHiddenTokens', type: 'boolean' },
                        { name: 'entry', type: 'boolean' },
                        { name: 'fragment', type: 'boolean' },
                        { name: 'hiddenTokens', type: 'array' },
                        { name: 'parameters', type: 'array' },
                        { name: 'wildcard', type: 'boolean' }
                    ]
                };
            }
            case 'TerminalRule': {
                return {
                    name: 'TerminalRule',
                    mandatory: [
                        { name: 'fragment', type: 'boolean' },
                        { name: 'hidden', type: 'boolean' }
                    ]
                };
            }
            case 'TypeAttribute': {
                return {
                    name: 'TypeAttribute',
                    mandatory: [
                        { name: 'isOptional', type: 'boolean' }
                    ]
                };
            }
            case 'UnionType': {
                return {
                    name: 'UnionType',
                    mandatory: [
                        { name: 'types', type: 'array' }
                    ]
                };
            }
            case 'Alternatives': {
                return {
                    name: 'Alternatives',
                    mandatory: [
                        { name: 'elements', type: 'array' }
                    ]
                };
            }
            case 'CrossReference': {
                return {
                    name: 'CrossReference',
                    mandatory: [
                        { name: 'deprecatedSyntax', type: 'boolean' }
                    ]
                };
            }
            case 'Group': {
                return {
                    name: 'Group',
                    mandatory: [
                        { name: 'elements', type: 'array' }
                    ]
                };
            }
            case 'RuleCall': {
                return {
                    name: 'RuleCall',
                    mandatory: [
                        { name: 'arguments', type: 'array' }
                    ]
                };
            }
            case 'TerminalAlternatives': {
                return {
                    name: 'TerminalAlternatives',
                    mandatory: [
                        { name: 'elements', type: 'array' }
                    ]
                };
            }
            case 'TerminalGroup': {
                return {
                    name: 'TerminalGroup',
                    mandatory: [
                        { name: 'elements', type: 'array' }
                    ]
                };
            }
            case 'UnorderedGroup': {
                return {
                    name: 'UnorderedGroup',
                    mandatory: [
                        { name: 'elements', type: 'array' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}
exports.LangiumGrammarAstReflection = LangiumGrammarAstReflection;
exports.reflection = new LangiumGrammarAstReflection();
//# sourceMappingURL=ast.js.map