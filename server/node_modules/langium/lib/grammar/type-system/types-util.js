"use strict";
/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.isAstType = exports.findReferenceTypes = exports.hasBooleanType = exports.hasArrayType = exports.sortInterfacesTopologically = exports.mergeTypesAndInterfaces = exports.mergeInterfaces = exports.collectSuperTypes = exports.collectTypeHierarchy = exports.collectChildrenTypes = exports.distinctAndSorted = exports.collectAllPlainProperties = void 0;
const collections_1 = require("../../utils/collections");
const ast_1 = require("../generated/ast");
const types_1 = require("./type-collector/types");
/**
 * Collects all properties of all interface types. Includes super type properties.
 * @param interfaces A topologically sorted array of interfaces.
 */
function collectAllPlainProperties(interfaces) {
    const map = new collections_1.MultiMap();
    for (const interfaceType of interfaces) {
        map.addAll(interfaceType.name, interfaceType.properties);
    }
    for (const interfaceType of interfaces) {
        for (const superType of interfaceType.superTypes) {
            const superTypeProperties = map.get(superType);
            if (superTypeProperties) {
                map.addAll(interfaceType.name, superTypeProperties);
            }
        }
    }
    return map;
}
exports.collectAllPlainProperties = collectAllPlainProperties;
function distinctAndSorted(list, compareFn) {
    return Array.from(new Set(list)).sort(compareFn);
}
exports.distinctAndSorted = distinctAndSorted;
function collectChildrenTypes(interfaceNode, references, langiumDocuments, nodeLocator) {
    const childrenTypes = new Set();
    childrenTypes.add(interfaceNode);
    const refs = references.findReferences(interfaceNode, {});
    refs.forEach(ref => {
        const doc = langiumDocuments.getOrCreateDocument(ref.sourceUri);
        const astNode = nodeLocator.getAstNode(doc.parseResult.value, ref.sourcePath);
        if ((0, ast_1.isInterface)(astNode)) {
            childrenTypes.add(astNode);
            const childrenOfInterface = collectChildrenTypes(astNode, references, langiumDocuments, nodeLocator);
            childrenOfInterface.forEach(child => childrenTypes.add(child));
        }
        else if (astNode && (0, ast_1.isType)(astNode.$container)) {
            childrenTypes.add(astNode.$container);
        }
    });
    return childrenTypes;
}
exports.collectChildrenTypes = collectChildrenTypes;
function collectTypeHierarchy(types) {
    const allTypes = new Set(types);
    const duplicateSuperTypes = new collections_1.MultiMap();
    const duplicateSubTypes = new collections_1.MultiMap();
    for (const type of allTypes) {
        for (const superType of type.superTypes) {
            if (allTypes.has(superType)) {
                duplicateSuperTypes.add(type.name, superType.name);
                duplicateSubTypes.add(superType.name, type.name);
            }
        }
        for (const subType of type.subTypes) {
            if (allTypes.has(subType)) {
                duplicateSuperTypes.add(subType.name, type.name);
                duplicateSubTypes.add(type.name, subType.name);
            }
        }
    }
    const superTypes = new collections_1.MultiMap();
    const subTypes = new collections_1.MultiMap();
    // Deduplicate and sort
    for (const [name, superTypeList] of Array.from(duplicateSuperTypes.entriesGroupedByKey()).sort(([aName], [bName]) => aName.localeCompare(bName))) {
        superTypes.addAll(name, Array.from(new Set(superTypeList)));
    }
    for (const [name, subTypeList] of Array.from(duplicateSubTypes.entriesGroupedByKey()).sort(([aName], [bName]) => aName.localeCompare(bName))) {
        subTypes.addAll(name, Array.from(new Set(subTypeList)));
    }
    return {
        superTypes,
        subTypes
    };
}
exports.collectTypeHierarchy = collectTypeHierarchy;
function collectSuperTypes(ruleNode) {
    const superTypes = new Set();
    if ((0, ast_1.isInterface)(ruleNode)) {
        superTypes.add(ruleNode);
        ruleNode.superTypes.forEach(superType => {
            if ((0, ast_1.isInterface)(superType.ref)) {
                superTypes.add(superType.ref);
                const collectedSuperTypes = collectSuperTypes(superType.ref);
                for (const superType of collectedSuperTypes) {
                    superTypes.add(superType);
                }
            }
        });
    }
    else if ((0, ast_1.isType)(ruleNode)) {
        const usedTypes = collectUsedTypes(ruleNode.type);
        for (const usedType of usedTypes) {
            const collectedSuperTypes = collectSuperTypes(usedType);
            for (const superType of collectedSuperTypes) {
                superTypes.add(superType);
            }
        }
    }
    return superTypes;
}
exports.collectSuperTypes = collectSuperTypes;
function collectUsedTypes(typeDefinition) {
    var _a;
    if ((0, ast_1.isUnionType)(typeDefinition)) {
        return typeDefinition.types.flatMap(e => collectUsedTypes(e));
    }
    else if ((0, ast_1.isSimpleType)(typeDefinition)) {
        const value = (_a = typeDefinition.typeRef) === null || _a === void 0 ? void 0 : _a.ref;
        if ((0, ast_1.isType)(value) || (0, ast_1.isInterface)(value)) {
            return [value];
        }
    }
    return [];
}
function mergeInterfaces(inferred, declared) {
    return inferred.interfaces.concat(declared.interfaces);
}
exports.mergeInterfaces = mergeInterfaces;
function mergeTypesAndInterfaces(astTypes) {
    return astTypes.interfaces.concat(astTypes.unions);
}
exports.mergeTypesAndInterfaces = mergeTypesAndInterfaces;
/**
 * Performs topological sorting on the generated interfaces.
 * @param interfaces The interfaces to sort topologically.
 * @returns A topologically sorted set of interfaces.
 */
function sortInterfacesTopologically(interfaces) {
    const nodes = interfaces
        .sort((a, b) => a.name.localeCompare(b.name))
        .map(e => ({ value: e, nodes: [] }));
    for (const node of nodes) {
        node.nodes = nodes.filter(e => node.value.superTypes.has(e.value.name));
    }
    const l = [];
    const s = nodes.filter(e => e.nodes.length === 0);
    while (s.length > 0) {
        const n = s.shift();
        if (!l.includes(n)) {
            l.push(n);
            nodes
                .filter(e => e.nodes.includes(n))
                .forEach(m => s.push(m));
        }
    }
    return l.map(e => e.value);
}
exports.sortInterfacesTopologically = sortInterfacesTopologically;
function hasArrayType(type) {
    if ((0, types_1.isPropertyUnion)(type)) {
        return type.types.some(e => hasArrayType(e));
    }
    else if ((0, types_1.isArrayType)(type)) {
        return true;
    }
    else {
        return false;
    }
}
exports.hasArrayType = hasArrayType;
function hasBooleanType(type) {
    if ((0, types_1.isPropertyUnion)(type)) {
        return type.types.some(e => hasBooleanType(e));
    }
    else if ((0, types_1.isPrimitiveType)(type)) {
        return type.primitive === 'boolean';
    }
    else {
        return false;
    }
}
exports.hasBooleanType = hasBooleanType;
function findReferenceTypes(type) {
    if ((0, types_1.isPropertyUnion)(type)) {
        return type.types.flatMap(e => findReferenceTypes(e));
    }
    else if ((0, types_1.isReferenceType)(type)) {
        const refType = type.referenceType;
        if ((0, types_1.isValueType)(refType)) {
            return [refType.value.name];
        }
    }
    else if ((0, types_1.isArrayType)(type)) {
        return findReferenceTypes(type.elementType);
    }
    return [];
}
exports.findReferenceTypes = findReferenceTypes;
function isAstType(type) {
    if ((0, types_1.isPropertyUnion)(type)) {
        return type.types.every(isAstType);
    }
    else if ((0, types_1.isValueType)(type)) {
        const value = type.value;
        if ('type' in value) {
            return isAstType(value.type);
        }
        else {
            // Is definitely an interface type
            return true;
        }
    }
    return false;
}
exports.isAstType = isAstType;
//# sourceMappingURL=types-util.js.map