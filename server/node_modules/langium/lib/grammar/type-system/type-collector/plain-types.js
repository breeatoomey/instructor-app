"use strict";
/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.flattenPlainType = exports.mergePropertyTypes = exports.plainToTypes = exports.isPlainStringType = exports.isPlainPrimitiveType = exports.isPlainValueType = exports.isPlainPropertyUnion = exports.isPlainArrayType = exports.isPlainReferenceType = exports.isPlainUnion = exports.isPlainInterface = void 0;
const types_1 = require("./types");
function isPlainInterface(type) {
    return !isPlainUnion(type);
}
exports.isPlainInterface = isPlainInterface;
function isPlainUnion(type) {
    return 'type' in type;
}
exports.isPlainUnion = isPlainUnion;
function isPlainReferenceType(propertyType) {
    return 'referenceType' in propertyType;
}
exports.isPlainReferenceType = isPlainReferenceType;
function isPlainArrayType(propertyType) {
    return 'elementType' in propertyType;
}
exports.isPlainArrayType = isPlainArrayType;
function isPlainPropertyUnion(propertyType) {
    return 'types' in propertyType;
}
exports.isPlainPropertyUnion = isPlainPropertyUnion;
function isPlainValueType(propertyType) {
    return 'value' in propertyType;
}
exports.isPlainValueType = isPlainValueType;
function isPlainPrimitiveType(propertyType) {
    return 'primitive' in propertyType;
}
exports.isPlainPrimitiveType = isPlainPrimitiveType;
function isPlainStringType(propertyType) {
    return 'string' in propertyType;
}
exports.isPlainStringType = isPlainStringType;
function plainToTypes(plain) {
    const interfaceTypes = new Map();
    const unionTypes = new Map();
    for (const interfaceValue of plain.interfaces) {
        const type = new types_1.InterfaceType(interfaceValue.name, interfaceValue.declared, interfaceValue.abstract);
        interfaceTypes.set(interfaceValue.name, type);
    }
    for (const unionValue of plain.unions) {
        const type = new types_1.UnionType(unionValue.name, {
            declared: unionValue.declared,
            dataType: unionValue.dataType
        });
        unionTypes.set(unionValue.name, type);
    }
    for (const interfaceValue of plain.interfaces) {
        const type = interfaceTypes.get(interfaceValue.name);
        for (const superTypeName of interfaceValue.superTypes) {
            const superType = interfaceTypes.get(superTypeName) || unionTypes.get(superTypeName);
            if (superType) {
                type.superTypes.add(superType);
            }
        }
        for (const subTypeName of interfaceValue.subTypes) {
            const subType = interfaceTypes.get(subTypeName) || unionTypes.get(subTypeName);
            if (subType) {
                type.subTypes.add(subType);
            }
        }
        for (const property of interfaceValue.properties) {
            const prop = plainToProperty(property, interfaceTypes, unionTypes);
            type.properties.push(prop);
        }
    }
    for (const unionValue of plain.unions) {
        const type = unionTypes.get(unionValue.name);
        type.type = plainToPropertyType(unionValue.type, type, interfaceTypes, unionTypes);
    }
    return {
        interfaces: Array.from(interfaceTypes.values()),
        unions: Array.from(unionTypes.values())
    };
}
exports.plainToTypes = plainToTypes;
function plainToProperty(property, interfaces, unions) {
    return {
        name: property.name,
        optional: property.optional,
        astNodes: property.astNodes,
        type: plainToPropertyType(property.type, undefined, interfaces, unions)
    };
}
function plainToPropertyType(type, union, interfaces, unions) {
    if (isPlainArrayType(type)) {
        return {
            elementType: plainToPropertyType(type.elementType, union, interfaces, unions)
        };
    }
    else if (isPlainReferenceType(type)) {
        return {
            referenceType: plainToPropertyType(type.referenceType, undefined, interfaces, unions)
        };
    }
    else if (isPlainPropertyUnion(type)) {
        return {
            types: type.types.map(e => plainToPropertyType(e, union, interfaces, unions))
        };
    }
    else if (isPlainStringType(type)) {
        return {
            string: type.string
        };
    }
    else if (isPlainPrimitiveType(type)) {
        return {
            primitive: type.primitive,
            regex: type.regex
        };
    }
    else if (isPlainValueType(type)) {
        const value = interfaces.get(type.value) || unions.get(type.value);
        if (!value) {
            return {
                primitive: 'unknown'
            };
        }
        if (union) {
            union.subTypes.add(value);
        }
        return {
            value
        };
    }
    else {
        throw new Error('Invalid property type');
    }
}
function mergePropertyTypes(first, second) {
    const flattenedFirst = flattenPlainType(first);
    const flattenedSecond = flattenPlainType(second);
    for (const second of flattenedSecond) {
        if (!includesType(flattenedFirst, second)) {
            flattenedFirst.push(second);
        }
    }
    if (flattenedFirst.length === 1) {
        return flattenedFirst[0];
    }
    else {
        return {
            types: flattenedFirst
        };
    }
}
exports.mergePropertyTypes = mergePropertyTypes;
function includesType(list, value) {
    return list.some(e => typeEquals(e, value));
}
function typeEquals(first, second) {
    if (isPlainArrayType(first) && isPlainArrayType(second)) {
        return typeEquals(first.elementType, second.elementType);
    }
    else if (isPlainReferenceType(first) && isPlainReferenceType(second)) {
        return typeEquals(first.referenceType, second.referenceType);
    }
    else if (isPlainValueType(first) && isPlainValueType(second)) {
        return first.value === second.value;
    }
    else {
        return false;
    }
}
function flattenPlainType(type) {
    if (isPlainPropertyUnion(type)) {
        return type.types.flatMap(e => flattenPlainType(e));
    }
    else {
        return [type];
    }
}
exports.flattenPlainType = flattenPlainType;
//# sourceMappingURL=plain-types.js.map