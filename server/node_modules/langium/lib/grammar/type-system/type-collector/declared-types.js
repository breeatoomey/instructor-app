"use strict";
/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.typeDefinitionToPropertyType = exports.collectDeclaredTypes = void 0;
const ast_1 = require("../../generated/ast");
const internal_grammar_util_1 = require("../../internal-grammar-util");
function collectDeclaredTypes(interfaces, unions) {
    const declaredTypes = { unions: [], interfaces: [] };
    // add interfaces
    for (const type of interfaces) {
        const properties = [];
        for (const attribute of type.attributes) {
            properties.push({
                name: attribute.name,
                optional: attribute.isOptional,
                astNodes: new Set([attribute]),
                type: typeDefinitionToPropertyType(attribute.type)
            });
        }
        const superTypes = new Set();
        for (const superType of type.superTypes) {
            if (superType.ref) {
                superTypes.add((0, internal_grammar_util_1.getTypeName)(superType.ref));
            }
        }
        const interfaceType = {
            name: type.name,
            declared: true,
            abstract: false,
            properties: properties,
            superTypes: superTypes,
            subTypes: new Set()
        };
        declaredTypes.interfaces.push(interfaceType);
    }
    // add types
    for (const union of unions) {
        const unionType = {
            name: union.name,
            declared: true,
            type: typeDefinitionToPropertyType(union.type),
            superTypes: new Set(),
            subTypes: new Set()
        };
        declaredTypes.unions.push(unionType);
    }
    return declaredTypes;
}
exports.collectDeclaredTypes = collectDeclaredTypes;
function typeDefinitionToPropertyType(type) {
    if ((0, ast_1.isArrayType)(type)) {
        return {
            elementType: typeDefinitionToPropertyType(type.elementType)
        };
    }
    else if ((0, ast_1.isReferenceType)(type)) {
        return {
            referenceType: typeDefinitionToPropertyType(type.referenceType)
        };
    }
    else if ((0, ast_1.isUnionType)(type)) {
        return {
            types: type.types.map(typeDefinitionToPropertyType)
        };
    }
    else if ((0, ast_1.isSimpleType)(type)) {
        let value;
        if (type.primitiveType) {
            value = type.primitiveType;
            return {
                primitive: value
            };
        }
        else if (type.stringType) {
            value = type.stringType;
            return {
                string: value
            };
        }
        else if (type.typeRef) {
            const ref = type.typeRef.ref;
            const value = (0, internal_grammar_util_1.getTypeNameWithoutError)(ref);
            if (value) {
                if ((0, internal_grammar_util_1.isPrimitiveType)(value)) {
                    return {
                        primitive: value
                    };
                }
                else {
                    return {
                        value
                    };
                }
            }
        }
    }
    return {
        primitive: 'unknown'
    };
}
exports.typeDefinitionToPropertyType = typeDefinitionToPropertyType;
//# sourceMappingURL=declared-types.js.map