"use strict";
/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.specifyAstNodeProperties = exports.createAstTypes = exports.collectValidationAst = exports.collectAst = void 0;
const types_util_1 = require("./types-util");
const types_1 = require("./type-collector/types");
const all_types_1 = require("./type-collector/all-types");
const plain_types_1 = require("./type-collector/plain-types");
/**
 * Collects all types for the generated AST. The types collector entry point.
 *
 * @param grammars All grammars involved in the type generation process
 * @param documents Additional documents so that imports can be resolved as necessary
 */
function collectAst(grammars, documents) {
    const { inferred, declared } = (0, all_types_1.collectTypeResources)(grammars, documents);
    return createAstTypes(inferred, declared);
}
exports.collectAst = collectAst;
/**
 * Collects all types used during the validation process.
 * The validation process requires us to compare our inferred types with our declared types.
 *
 * @param grammars All grammars involved in the validation process
 * @param documents Additional documents so that imports can be resolved as necessary
 */
function collectValidationAst(grammars, documents) {
    const { inferred, declared, astResources } = (0, all_types_1.collectTypeResources)(grammars, documents);
    return {
        astResources,
        inferred: createAstTypes(declared, inferred),
        declared: createAstTypes(inferred, declared)
    };
}
exports.collectValidationAst = collectValidationAst;
function createAstTypes(first, second) {
    var _a, _b;
    const astTypes = {
        interfaces: (0, types_util_1.sortInterfacesTopologically)(mergeAndRemoveDuplicates(...first.interfaces, ...(_a = second === null || second === void 0 ? void 0 : second.interfaces) !== null && _a !== void 0 ? _a : [])),
        unions: mergeAndRemoveDuplicates(...first.unions, ...(_b = second === null || second === void 0 ? void 0 : second.unions) !== null && _b !== void 0 ? _b : []),
    };
    const finalTypes = (0, plain_types_1.plainToTypes)(astTypes);
    specifyAstNodeProperties(finalTypes);
    return finalTypes;
}
exports.createAstTypes = createAstTypes;
/**
 * Merges the lists of given elements into a single list and removes duplicates. Elements later in the lists get precedence over earlier elements.
 *
 * The distinction is performed over the `name` property of the element. The result is a name-sorted list of elements.
 */
function mergeAndRemoveDuplicates(...elements) {
    return Array.from(elements
        .reduce((acc, type) => { acc.set(type.name, type); return acc; }, new Map())
        .values()).sort((a, b) => a.name.localeCompare(b.name));
}
function specifyAstNodeProperties(astTypes) {
    const nameToType = filterInterfaceLikeTypes(astTypes);
    const array = Array.from(nameToType.values());
    addSubTypes(array);
    buildContainerTypes(array);
    buildTypeNames(array);
}
exports.specifyAstNodeProperties = specifyAstNodeProperties;
function buildTypeNames(types) {
    // Recursively collect all subtype names
    const visited = new Set();
    const collect = (type) => {
        if (visited.has(type))
            return;
        visited.add(type);
        type.typeNames.add(type.name);
        for (const subtype of type.subTypes) {
            collect(subtype);
            subtype.typeNames.forEach(n => type.typeNames.add(n));
        }
    };
    types.forEach(collect);
}
/**
 * Removes union types that reference only to primitive types or
 * types that reference only to primitive types.
 */
function filterInterfaceLikeTypes({ interfaces, unions }) {
    const nameToType = interfaces.concat(unions)
        .reduce((acc, e) => { acc.set(e.name, e); return acc; }, new Map());
    const cache = new Map();
    for (const union of unions) {
        cache.set(union, isDataType(union.type, new Set()));
    }
    for (const [union, isDataType] of cache) {
        if (isDataType) {
            nameToType.delete(union.name);
        }
    }
    return nameToType;
}
function isDataType(property, visited) {
    if (visited.has(property)) {
        return true;
    }
    visited.add(property);
    if ((0, types_1.isPropertyUnion)(property)) {
        return property.types.every(e => isDataType(e, visited));
    }
    else if ((0, types_1.isValueType)(property)) {
        const value = property.value;
        if ((0, types_1.isUnionType)(value)) {
            return isDataType(value.type, visited);
        }
        else {
            return false;
        }
    }
    else {
        return (0, types_1.isPrimitiveType)(property) || (0, types_1.isStringType)(property);
    }
}
function addSubTypes(types) {
    for (const interfaceType of types) {
        for (const superTypeName of interfaceType.superTypes) {
            superTypeName.subTypes.add(interfaceType);
        }
    }
}
/**
 * Builds container types for given interfaces.
 * @param interfaces The interfaces that have to get container types.
 */
function buildContainerTypes(types) {
    // 1st stage: collect container types
    const interfaces = types.filter(types_1.isInterfaceType);
    for (const interfaceType of interfaces) {
        const refTypes = interfaceType.properties.flatMap(property => findChildTypes(property.type, new Set()));
        for (const refType of refTypes) {
            refType.containerTypes.add(interfaceType);
        }
    }
    // 2nd stage: share container types
    const connectedComponents = calculateConnectedComponents(types);
    shareContainerTypes(connectedComponents);
}
function findChildTypes(type, set) {
    if ((0, types_1.isPropertyUnion)(type)) {
        return type.types.flatMap(e => findChildTypes(e, set));
    }
    else if ((0, types_1.isValueType)(type)) {
        if (set.has(type.value)) {
            return [];
        }
        else {
            set.add(type.value);
        }
        return [type.value];
    }
    else if ((0, types_1.isArrayType)(type)) {
        return findChildTypes(type.elementType, set);
    }
    else {
        return [];
    }
}
function calculateConnectedComponents(interfaces) {
    function dfs(typeInterface) {
        const component = [typeInterface];
        visited.add(typeInterface);
        const allTypes = [
            ...hierarchy.subTypes.get(typeInterface.name),
            ...hierarchy.superTypes.get(typeInterface.name)
        ];
        for (const nextTypeInterface of allTypes) {
            const nextType = map.get(nextTypeInterface);
            if (nextType && !visited.has(nextType)) {
                component.push(...dfs(nextType));
            }
        }
        return component;
    }
    const map = new Map(interfaces.map(e => [e.name, e]));
    const connectedComponents = [];
    const hierarchy = (0, types_util_1.collectTypeHierarchy)(interfaces);
    const visited = new Set();
    for (const typeInterface of interfaces) {
        if (!visited.has(typeInterface)) {
            connectedComponents.push(dfs(typeInterface));
        }
    }
    return connectedComponents;
}
function shareContainerTypes(connectedComponents) {
    for (const component of connectedComponents) {
        const superSet = new Set();
        component.forEach(type => type.containerTypes.forEach(e => superSet.add(e)));
        component.forEach(type => type.containerTypes = superSet);
    }
}
//# sourceMappingURL=ast-collector.js.map