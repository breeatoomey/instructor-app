"use strict";
/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LangiumGrammarTypesValidator = exports.registerTypeValidationChecks = void 0;
const ast = __importStar(require("../generated/ast"));
const collections_1 = require("../../utils/collections");
const internal_grammar_util_1 = require("../internal-grammar-util");
const types_1 = require("../type-system/type-collector/types");
const documents_1 = require("../workspace/documents");
function registerTypeValidationChecks(services) {
    const registry = services.validation.ValidationRegistry;
    const typesValidator = services.validation.LangiumGrammarTypesValidator;
    const checks = {
        Action: [
            typesValidator.checkActionIsNotUnionType,
        ],
        Grammar: [
            typesValidator.checkDeclaredTypesConsistency,
            typesValidator.checkDeclaredAndInferredTypesConsistency,
        ],
        Interface: [
            typesValidator.checkCyclicInterface
        ],
        Type: [
            typesValidator.checkCyclicType
        ]
    };
    registry.register(checks, typesValidator);
}
exports.registerTypeValidationChecks = registerTypeValidationChecks;
class LangiumGrammarTypesValidator {
    checkCyclicType(type, accept) {
        if (isCyclicType(type, new Set())) {
            accept('error', `Type alias '${type.name}' circularly references itself.`, { node: type, property: 'name' });
        }
    }
    checkCyclicInterface(type, accept) {
        if (isCyclicType(type, new Set())) {
            accept('error', `Type '${type.name}' recursively references itself as a base type.`, { node: type, property: 'name' });
        }
    }
    checkDeclaredTypesConsistency(grammar, accept) {
        var _a;
        const validationResources = (_a = grammar.$document) === null || _a === void 0 ? void 0 : _a.validationResources;
        if (validationResources) {
            for (const typeInfo of validationResources.typeToValidationInfo.values()) {
                if ((0, documents_1.isDeclared)(typeInfo) && (0, types_1.isInterfaceType)(typeInfo.declared) && ast.isInterface(typeInfo.declaredNode)) {
                    const declInterface = typeInfo;
                    validateInterfaceSuperTypes(declInterface, accept);
                    validateSuperTypesConsistency(declInterface, accept);
                }
            }
        }
    }
    checkDeclaredAndInferredTypesConsistency(grammar, accept) {
        var _a;
        const validationResources = (_a = grammar.$document) === null || _a === void 0 ? void 0 : _a.validationResources;
        if (validationResources) {
            for (const typeInfo of validationResources.typeToValidationInfo.values()) {
                if ((0, documents_1.isInferred)(typeInfo) && typeInfo.inferred instanceof types_1.InterfaceType) {
                    validateInferredInterface(typeInfo.inferred, accept);
                }
                if ((0, documents_1.isInferredAndDeclared)(typeInfo)) {
                    validateDeclaredAndInferredConsistency(typeInfo, validationResources, accept);
                }
            }
        }
    }
    checkActionIsNotUnionType(action, accept) {
        if (ast.isType(action.type)) {
            accept('error', 'Actions cannot create union types.', { node: action, property: 'type' });
        }
    }
}
exports.LangiumGrammarTypesValidator = LangiumGrammarTypesValidator;
///////////////////////////////////////////////////////////////////////////////
function isCyclicType(type, visited) {
    var _a;
    if (visited.has(type)) {
        return true;
    }
    visited.add(type);
    if (ast.isType(type)) {
        return isCyclicType(type.type, visited);
    }
    else if (ast.isInterface(type)) {
        return type.superTypes.some(t => t.ref && isCyclicType(t.ref, new Set(visited)));
    }
    else if (ast.isSimpleType(type)) {
        if ((_a = type.typeRef) === null || _a === void 0 ? void 0 : _a.ref) {
            return isCyclicType(type.typeRef.ref, visited);
        }
    }
    else if (ast.isReferenceType(type)) {
        return isCyclicType(type.referenceType, visited);
    }
    else if (ast.isArrayType(type)) {
        return isCyclicType(type.elementType, visited);
    }
    else if (ast.isUnionType(type)) {
        return type.types.some(t => isCyclicType(t, new Set(visited)));
    }
    return false;
}
function validateInferredInterface(inferredInterface, accept) {
    inferredInterface.properties.forEach(prop => {
        var _a;
        const flattened = (0, types_1.flattenPropertyUnion)(prop.type);
        if (flattened.length > 1) {
            const typeKind = (type) => (0, types_1.isReferenceType)(type) ? 'ref' : 'other';
            const firstKind = typeKind(flattened[0]);
            if (flattened.slice(1).some(type => typeKind(type) !== firstKind)) {
                const targetNode = (_a = prop.astNodes.values().next()) === null || _a === void 0 ? void 0 : _a.value;
                if (targetNode) {
                    accept('error', `Mixing a cross-reference with other types is not supported. Consider splitting property "${prop.name}" into two or more different properties.`, { node: targetNode });
                }
            }
        }
    });
}
function validateInterfaceSuperTypes({ declared, declaredNode }, accept) {
    Array.from(declared.superTypes).forEach((superType, i) => {
        if (superType) {
            if ((0, types_1.isUnionType)(superType)) {
                accept('error', 'Interfaces cannot extend union types.', { node: declaredNode, property: 'superTypes', index: i });
            }
            if (!superType.declared) {
                accept('error', 'Extending an inferred type is discouraged.', { node: declaredNode, property: 'superTypes', index: i });
            }
        }
    });
}
function validateSuperTypesConsistency({ declared, declaredNode }, accept) {
    const nameToProp = declared.properties.reduce((acc, e) => acc.add(e.name, e), new collections_1.MultiMap());
    for (const [name, props] of nameToProp.entriesGroupedByKey()) {
        if (props.length > 1) {
            for (const prop of props) {
                accept('error', `Cannot have two properties with the same name '${name}'.`, {
                    node: Array.from(prop.astNodes)[0],
                    property: 'name'
                });
            }
        }
    }
    const allSuperTypes = Array.from(declared.superTypes);
    for (let i = 0; i < allSuperTypes.length; i++) {
        for (let j = i + 1; j < allSuperTypes.length; j++) {
            const outerType = allSuperTypes[i];
            const innerType = allSuperTypes[j];
            const outerProps = (0, types_1.isInterfaceType)(outerType) ? outerType.superProperties : [];
            const innerProps = (0, types_1.isInterfaceType)(innerType) ? innerType.superProperties : [];
            const nonIdentical = getNonIdenticalProps(outerProps, innerProps);
            if (nonIdentical.length > 0) {
                accept('error', `Cannot simultaneously inherit from '${outerType}' and '${innerType}'. Their ${nonIdentical.map(e => "'" + e + "'").join(', ')} properties are not identical.`, {
                    node: declaredNode,
                    property: 'name'
                });
            }
        }
    }
    const allSuperProps = new Set();
    for (const superType of allSuperTypes) {
        const props = (0, types_1.isInterfaceType)(superType) ? superType.superProperties : [];
        for (const prop of props) {
            allSuperProps.add(prop.name);
        }
    }
    for (const ownProp of declared.properties) {
        if (allSuperProps.has(ownProp.name)) {
            const propNode = declaredNode.attributes.find(e => e.name === ownProp.name);
            if (propNode) {
                accept('error', `Cannot redeclare property '${ownProp.name}'. It is already inherited from another interface.`, {
                    node: propNode,
                    property: 'name'
                });
            }
        }
    }
}
function getNonIdenticalProps(a, b) {
    const nonIdentical = [];
    for (const outerProp of a) {
        const innerProp = b.find(e => e.name === outerProp.name);
        if (innerProp && !arePropTypesIdentical(outerProp, innerProp)) {
            nonIdentical.push(outerProp.name);
        }
    }
    return nonIdentical;
}
function arePropTypesIdentical(a, b) {
    return (0, types_1.isTypeAssignable)(a.type, b.type) && (0, types_1.isTypeAssignable)(b.type, a.type);
}
///////////////////////////////////////////////////////////////////////////////
function validateDeclaredAndInferredConsistency(typeInfo, resources, accept) {
    const { inferred, declared, declaredNode, inferredNodes } = typeInfo;
    const typeName = declared.name;
    const applyErrorToRulesAndActions = (msgPostfix) => (errorMsg) => inferredNodes.forEach(node => accept('error', `${errorMsg}${msgPostfix ? ` ${msgPostfix}` : ''}.`, (node === null || node === void 0 ? void 0 : node.inferredType) ?
        { node: node === null || node === void 0 ? void 0 : node.inferredType, property: 'name' } :
        { node, property: ast.isAction(node) ? 'type' : 'name' }));
    const applyErrorToProperties = (nodes, errorMessage) => nodes.forEach(node => accept('error', errorMessage, { node, property: ast.isAssignment(node) || ast.isAction(node) ? 'feature' : 'name' }));
    // todo add actions
    // currently we don't track which assignments belong to which actions and can't apply this error
    const applyMissingPropErrorToRules = (missingProp) => {
        inferredNodes.forEach(node => {
            if (ast.isParserRule(node)) {
                const assignments = (0, internal_grammar_util_1.extractAssignments)(node.definition);
                if (assignments.find(e => e.feature === missingProp) === undefined) {
                    accept('error', `Property '${missingProp}' is missing in a rule '${node.name}', but is required in type '${typeName}'.`, {
                        node,
                        property: 'parameters'
                    });
                }
            }
        });
    };
    if ((0, types_1.isUnionType)(inferred) && (0, types_1.isUnionType)(declared)) {
        validateAlternativesConsistency(inferred.type, declared.type, applyErrorToRulesAndActions(`in a rule that returns type '${typeName}'`));
    }
    else if ((0, types_1.isInterfaceType)(inferred) && (0, types_1.isInterfaceType)(declared)) {
        validatePropertiesConsistency(inferred, declared, resources, applyErrorToRulesAndActions(`in a rule that returns type '${typeName}'`), applyErrorToProperties, applyMissingPropErrorToRules);
    }
    else {
        const errorMessage = `Inferred and declared versions of type '${typeName}' both have to be interfaces or unions.`;
        applyErrorToRulesAndActions()(errorMessage);
        accept('error', errorMessage, { node: declaredNode, property: 'name' });
    }
}
function validateAlternativesConsistency(inferred, declared, applyErrorToInferredTypes) {
    if (!(0, types_1.isTypeAssignable)(inferred, declared)) {
        applyErrorToInferredTypes(`Cannot assign type '${(0, types_1.propertyTypeToString)(inferred, 'DeclaredType')}' to '${(0, types_1.propertyTypeToString)(declared, 'DeclaredType')}'`);
    }
}
function isOptionalProperty(prop) {
    // mandatory properties will always be created so there are no issues if they are missing
    return prop.optional || (0, types_1.isMandatoryPropertyType)(prop.type);
}
function validatePropertiesConsistency(inferred, declared, resources, applyErrorToType, applyErrorToProperties, applyMissingPropErrorToRules) {
    const ownInferredProps = new Set(inferred.properties.map(e => e.name));
    // This field also contains properties of sub types
    const allInferredProps = new Map(inferred.allProperties.map(e => [e.name, e]));
    // This field only contains properties of itself or super types
    const declaredProps = new Map(declared.superProperties.map(e => [e.name, e]));
    // The inferred props may not have full hierarchy information so try finding
    // a corresponding declared type
    const matchingProp = (type) => {
        if ((0, types_1.isPropertyUnion)(type))
            return { types: type.types.map(t => matchingProp(t)) };
        if ((0, types_1.isReferenceType)(type))
            return { referenceType: matchingProp(type.referenceType) };
        if ((0, types_1.isArrayType)(type))
            return { elementType: matchingProp(type.elementType) };
        if ((0, types_1.isValueType)(type)) {
            const resource = resources.typeToValidationInfo.get(type.value.name);
            if (!resource)
                return type;
            return { value: 'declared' in resource ? resource.declared : resource.inferred };
        }
        return type;
    };
    // detects extra properties & validates matched ones on consistency by the 'optional' property
    for (const [name, foundProp] of allInferredProps.entries()) {
        const expectedProp = declaredProps.get(name);
        if (expectedProp) {
            const foundTypeAsStr = (0, types_1.propertyTypeToString)(foundProp.type, 'DeclaredType');
            const expectedTypeAsStr = (0, types_1.propertyTypeToString)(expectedProp.type, 'DeclaredType');
            const typeAlternativesErrors = (0, types_1.isTypeAssignable)(matchingProp(foundProp.type), expectedProp.type);
            if (!typeAlternativesErrors && expectedTypeAsStr !== 'unknown') {
                const errorMsgPrefix = `The assigned type '${foundTypeAsStr}' is not compatible with the declared property '${name}' of type '${expectedTypeAsStr}'.`;
                applyErrorToProperties(foundProp.astNodes, errorMsgPrefix);
            }
            if (foundProp.optional && !isOptionalProperty(expectedProp)) {
                applyMissingPropErrorToRules(name);
            }
        }
        else if (ownInferredProps.has(name)) {
            // Only apply the superfluous property error on properties which are actually declared on the current type
            applyErrorToProperties(foundProp.astNodes, `A property '${name}' is not expected.`);
        }
    }
    // Detect any missing properties
    const missingProps = new Set();
    for (const [name, expectedProperties] of declaredProps.entries()) {
        const foundProperty = allInferredProps.get(name);
        if (!foundProperty && !isOptionalProperty(expectedProperties)) {
            missingProps.add(name);
        }
    }
    if (missingProps.size > 0) {
        const prefix = missingProps.size > 1 ? 'Properties' : 'A property';
        const postfix = missingProps.size > 1 ? 'are expected' : 'is expected';
        const props = Array.from(missingProps).map(e => `'${e}'`).sort().join(', ');
        applyErrorToType(`${prefix} ${props} ${postfix}.`);
    }
}
//# sourceMappingURL=types-validator.js.map