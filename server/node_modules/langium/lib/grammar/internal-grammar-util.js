"use strict";
/******************************************************************************
 * Copyright 2021-2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isPrimitiveType = exports.extractAssignments = exports.resolveTransitiveImports = exports.resolveImport = exports.resolveImportUri = exports.terminalRegex = exports.getRuleType = exports.getActionType = exports.getExplicitRuleType = exports.getTypeNameWithoutError = exports.getTypeName = exports.getActionAtElement = exports.isStringType = exports.isDataType = exports.hasDataTypeReturn = exports.isDataTypeRule = exports.isArrayOperator = exports.isArrayCardinality = exports.isOptionalCardinality = void 0;
const ast = __importStar(require("../grammar/generated/ast"));
const vscode_uri_1 = require("vscode-uri");
const ast_util_1 = require("../utils/ast-util");
const types_1 = require("./type-system/type-collector/types");
const regex_util_1 = require("../utils/regex-util");
function isOptionalCardinality(cardinality, element) {
    return cardinality === '?' || cardinality === '*' || (ast.isGroup(element) && Boolean(element.guardCondition));
}
exports.isOptionalCardinality = isOptionalCardinality;
function isArrayCardinality(cardinality) {
    return cardinality === '*' || cardinality === '+';
}
exports.isArrayCardinality = isArrayCardinality;
function isArrayOperator(operator) {
    return operator === '+=';
}
exports.isArrayOperator = isArrayOperator;
/**
 * Determines whether the given parser rule is a _data type rule_, meaning that it has a
 * primitive return type like `number`, `boolean`, etc.
 */
function isDataTypeRule(rule) {
    return isDataTypeRuleInternal(rule, new Set());
}
exports.isDataTypeRule = isDataTypeRule;
function isDataTypeRuleInternal(rule, visited) {
    if (visited.has(rule)) {
        return true;
    }
    else {
        visited.add(rule);
    }
    for (const node of (0, ast_util_1.streamAllContents)(rule)) {
        if (ast.isRuleCall(node)) {
            if (!node.rule.ref) {
                // RuleCall to unresolved rule. Don't assume `rule` is a DataType rule.
                return false;
            }
            if (ast.isParserRule(node.rule.ref) && !isDataTypeRuleInternal(node.rule.ref, visited)) {
                return false;
            }
        }
        else if (ast.isAssignment(node)) {
            return false;
        }
        else if (ast.isAction(node)) {
            return false;
        }
    }
    return Boolean(rule.definition);
}
function hasDataTypeReturn(rule) {
    var _a;
    const returnType = (_a = rule.returnType) === null || _a === void 0 ? void 0 : _a.ref;
    return rule.dataType !== undefined || (ast.isType(returnType) && isDataType(returnType));
}
exports.hasDataTypeReturn = hasDataTypeReturn;
function isDataType(type) {
    return isDataTypeInternal(type.type, new Set());
}
exports.isDataType = isDataType;
function isDataTypeInternal(type, visited) {
    if (visited.has(type)) {
        return true;
    }
    else {
        visited.add(type);
    }
    if (ast.isArrayType(type)) {
        return false;
    }
    else if (ast.isReferenceType(type)) {
        return false;
    }
    else if (ast.isUnionType(type)) {
        return type.types.every(e => isDataTypeInternal(e, visited));
    }
    else if (ast.isSimpleType(type)) {
        if (type.primitiveType !== undefined) {
            return true;
        }
        else if (type.stringType !== undefined) {
            return true;
        }
        else if (type.typeRef !== undefined) {
            const ref = type.typeRef.ref;
            if (ast.isType(ref)) {
                return isDataTypeInternal(ref.type, visited);
            }
            else {
                return false;
            }
        }
        else {
            return false;
        }
    }
    else {
        return false;
    }
}
function isStringType(type) {
    return isStringTypeInternal(type, new Set());
}
exports.isStringType = isStringType;
function isStringTypeInternal(type, visited) {
    var _a, _b;
    if (visited.has(type)) {
        return true;
    }
    else {
        visited.add(type);
    }
    if (ast.isParserRule(type)) {
        if (type.dataType) {
            return type.dataType === 'string';
        }
        if ((_a = type.returnType) === null || _a === void 0 ? void 0 : _a.ref) {
            return isStringTypeInternal(type.returnType.ref, visited);
        }
    }
    else if (ast.isType(type)) {
        return isStringTypeInternal(type.type, visited);
    }
    else if (ast.isArrayType(type)) {
        return false;
    }
    else if (ast.isReferenceType(type)) {
        return false;
    }
    else if (ast.isUnionType(type)) {
        return type.types.every(e => isStringTypeInternal(e, visited));
    }
    else if (ast.isSimpleType(type)) {
        if (type.primitiveType === 'string') {
            return true;
        }
        else if (type.stringType) {
            return true;
        }
        else if ((_b = type.typeRef) === null || _b === void 0 ? void 0 : _b.ref) {
            return isStringTypeInternal(type.typeRef.ref, visited);
        }
    }
    return false;
}
function getActionAtElement(element) {
    const parent = element.$container;
    if (ast.isGroup(parent)) {
        const elements = parent.elements;
        const index = elements.indexOf(element);
        for (let i = index - 1; i >= 0; i--) {
            const item = elements[i];
            if (ast.isAction(item)) {
                return item;
            }
            else {
                const action = (0, ast_util_1.streamAllContents)(elements[i]).find(ast.isAction);
                if (action) {
                    return action;
                }
            }
        }
    }
    if (ast.isAbstractElement(parent)) {
        return getActionAtElement(parent);
    }
    else {
        return undefined;
    }
}
exports.getActionAtElement = getActionAtElement;
function getTypeName(type) {
    var _a;
    if (ast.isParserRule(type)) {
        return isDataTypeRule(type) ? type.name : (_a = getExplicitRuleType(type)) !== null && _a !== void 0 ? _a : type.name;
    }
    else if (ast.isInterface(type) || ast.isType(type) || ast.isReturnType(type)) {
        return type.name;
    }
    else if (ast.isAction(type)) {
        const actionType = getActionType(type);
        if (actionType) {
            return actionType;
        }
    }
    else if (ast.isInferredType(type)) {
        return type.name;
    }
    throw new types_1.TypeResolutionError('Cannot get name of Unknown Type', type.$cstNode);
}
exports.getTypeName = getTypeName;
function getTypeNameWithoutError(type) {
    if (!type) {
        return undefined;
    }
    try {
        return getTypeName(type);
    }
    catch (_a) {
        return undefined;
    }
}
exports.getTypeNameWithoutError = getTypeNameWithoutError;
function getExplicitRuleType(rule) {
    if (rule.inferredType) {
        return rule.inferredType.name;
    }
    else if (rule.dataType) {
        return rule.dataType;
    }
    else if (rule.returnType) {
        const refType = rule.returnType.ref;
        if (refType) {
            // check if we need to check Action as return type
            if (ast.isParserRule(refType)) {
                return refType.name;
            }
            else if (ast.isInterface(refType) || ast.isType(refType)) {
                return refType.name;
            }
        }
    }
    return undefined;
}
exports.getExplicitRuleType = getExplicitRuleType;
function getActionType(action) {
    var _a;
    if (action.inferredType) {
        return action.inferredType.name;
    }
    else if ((_a = action.type) === null || _a === void 0 ? void 0 : _a.ref) {
        return getTypeName(action.type.ref);
    }
    return undefined; // not inferring and not referencing a valid type
}
exports.getActionType = getActionType;
function getRuleType(rule) {
    var _a, _b, _c;
    if (ast.isTerminalRule(rule)) {
        return (_b = (_a = rule.type) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : 'string';
    }
    else {
        return isDataTypeRule(rule) ? rule.name : (_c = getExplicitRuleType(rule)) !== null && _c !== void 0 ? _c : rule.name;
    }
}
exports.getRuleType = getRuleType;
function terminalRegex(terminalRule) {
    const flags = {
        s: false,
        i: false,
        u: false
    };
    const source = abstractElementToRegex(terminalRule.definition, flags);
    const flagText = Object.entries(flags).filter(([, value]) => value).map(([name]) => name).join('');
    return new RegExp(source, flagText);
}
exports.terminalRegex = terminalRegex;
// Using [\s\S]* allows to match everything, compared to . which doesn't match line terminators
const WILDCARD = /[\s\S]/.source;
function abstractElementToRegex(element, flags) {
    if (ast.isTerminalAlternatives(element)) {
        return terminalAlternativesToRegex(element);
    }
    else if (ast.isTerminalGroup(element)) {
        return terminalGroupToRegex(element);
    }
    else if (ast.isCharacterRange(element)) {
        return characterRangeToRegex(element);
    }
    else if (ast.isTerminalRuleCall(element)) {
        const rule = element.rule.ref;
        if (!rule) {
            throw new Error('Missing rule reference.');
        }
        return withCardinality(abstractElementToRegex(rule.definition), {
            cardinality: element.cardinality,
            lookahead: element.lookahead
        });
    }
    else if (ast.isNegatedToken(element)) {
        return negateTokenToRegex(element);
    }
    else if (ast.isUntilToken(element)) {
        return untilTokenToRegex(element);
    }
    else if (ast.isRegexToken(element)) {
        const lastSlash = element.regex.lastIndexOf('/');
        const source = element.regex.substring(1, lastSlash);
        const regexFlags = element.regex.substring(lastSlash + 1);
        if (flags) {
            flags.i = regexFlags.includes('i');
            flags.s = regexFlags.includes('s');
            flags.u = regexFlags.includes('u');
        }
        return withCardinality(source, {
            cardinality: element.cardinality,
            lookahead: element.lookahead,
            wrap: false
        });
    }
    else if (ast.isWildcard(element)) {
        return withCardinality(WILDCARD, {
            cardinality: element.cardinality,
            lookahead: element.lookahead
        });
    }
    else {
        throw new Error(`Invalid terminal element: ${element === null || element === void 0 ? void 0 : element.$type}`);
    }
}
function terminalAlternativesToRegex(alternatives) {
    return withCardinality(alternatives.elements.map(e => abstractElementToRegex(e)).join('|'), {
        cardinality: alternatives.cardinality,
        lookahead: alternatives.lookahead
    });
}
function terminalGroupToRegex(group) {
    return withCardinality(group.elements.map(e => abstractElementToRegex(e)).join(''), {
        cardinality: group.cardinality,
        lookahead: group.lookahead
    });
}
function untilTokenToRegex(until) {
    return withCardinality(`${WILDCARD}*?${abstractElementToRegex(until.terminal)}`, {
        cardinality: until.cardinality,
        lookahead: until.lookahead
    });
}
function negateTokenToRegex(negate) {
    return withCardinality(`(?!${abstractElementToRegex(negate.terminal)})${WILDCARD}*?`, {
        cardinality: negate.cardinality,
        lookahead: negate.lookahead
    });
}
function characterRangeToRegex(range) {
    if (range.right) {
        return withCardinality(`[${keywordToRegex(range.left)}-${keywordToRegex(range.right)}]`, {
            cardinality: range.cardinality,
            lookahead: range.lookahead,
            wrap: false
        });
    }
    return withCardinality(keywordToRegex(range.left), {
        cardinality: range.cardinality,
        lookahead: range.lookahead,
        wrap: false
    });
}
function keywordToRegex(keyword) {
    return (0, regex_util_1.escapeRegExp)(keyword.value);
}
function withCardinality(regex, options) {
    var _a;
    if (options.wrap !== false || options.lookahead) {
        regex = `(${(_a = options.lookahead) !== null && _a !== void 0 ? _a : ''}${regex})`;
    }
    if (options.cardinality) {
        return `${regex}${options.cardinality}`;
    }
    return regex;
}
function resolveImportUri(imp) {
    if (imp.path === undefined || imp.path.length === 0) {
        return undefined;
    }
    const dirUri = vscode_uri_1.Utils.dirname((0, ast_util_1.getDocument)(imp).uri);
    let grammarPath = imp.path;
    if (!grammarPath.endsWith('.langium')) {
        grammarPath += '.langium';
    }
    return vscode_uri_1.Utils.resolvePath(dirUri, grammarPath);
}
exports.resolveImportUri = resolveImportUri;
function resolveImport(documents, imp) {
    const resolvedUri = resolveImportUri(imp);
    try {
        if (resolvedUri) {
            const resolvedDocument = documents.getOrCreateDocument(resolvedUri);
            const node = resolvedDocument.parseResult.value;
            if (ast.isGrammar(node)) {
                return node;
            }
        }
    }
    catch (_a) {
        // NOOP
    }
    return undefined;
}
exports.resolveImport = resolveImport;
function resolveTransitiveImports(documents, grammarOrImport) {
    if (ast.isGrammarImport(grammarOrImport)) {
        const resolvedGrammar = resolveImport(documents, grammarOrImport);
        if (resolvedGrammar) {
            const transitiveGrammars = resolveTransitiveImportsInternal(documents, resolvedGrammar);
            transitiveGrammars.push(resolvedGrammar);
            return transitiveGrammars;
        }
        return [];
    }
    else {
        return resolveTransitiveImportsInternal(documents, grammarOrImport);
    }
}
exports.resolveTransitiveImports = resolveTransitiveImports;
function resolveTransitiveImportsInternal(documents, grammar, initialGrammar = grammar, visited = new Set(), grammars = new Set()) {
    const doc = (0, ast_util_1.getDocument)(grammar);
    if (initialGrammar !== grammar) {
        grammars.add(grammar);
    }
    if (!visited.has(doc.uri)) {
        visited.add(doc.uri);
        for (const imp of grammar.imports) {
            const importedGrammar = resolveImport(documents, imp);
            if (importedGrammar) {
                resolveTransitiveImportsInternal(documents, importedGrammar, initialGrammar, visited, grammars);
            }
        }
    }
    return Array.from(grammars);
}
function extractAssignments(element) {
    if (ast.isAssignment(element)) {
        return [element];
    }
    else if (ast.isAlternatives(element) || ast.isGroup(element) || ast.isUnorderedGroup(element)) {
        return element.elements.flatMap(e => extractAssignments(e));
    }
    else if (ast.isRuleCall(element) && element.rule.ref) {
        return extractAssignments(element.rule.ref.definition);
    }
    return [];
}
exports.extractAssignments = extractAssignments;
const primitiveTypes = ['string', 'number', 'boolean', 'Date', 'bigint'];
function isPrimitiveType(type) {
    return primitiveTypes.includes(type);
}
exports.isPrimitiveType = isPrimitiveType;
//# sourceMappingURL=internal-grammar-util.js.map