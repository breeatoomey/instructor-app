"use strict";
/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.joinTracedToNodeIf = exports.joinTracedToNode = exports.joinToNode = void 0;
const generator_node_1 = require("./generator-node");
/**
 * Joins the elements of the given `iterable` by applying `toGenerated` to each element
 * and appending the results to a {@link CompositeGeneratorNode} being returned finally.
 *
 * Note: empty strings being returned by `toGenerated` are treated as ordinary string
 * representations, while the result of `undefined` makes this function to ignore the
 * corresponding item and no separator is appended, if configured.
 *
 * Examples:
 * ```
 *   exandToNode`
 *       ${ joinToNode(['a', 'b'], String, { appendNewLineIfNotEmpty: true }) }
 *
 *       ${ joinToNode(new Set(['a', undefined, 'b']), e => e && String(e), { separator: ',', appendNewLineIfNotEmpty: true }) }
 *   `
 * ```
 *
 * @param iterable an {@link Array} or {@link Iterable} providing the elements to be joined
 *
 * @param toGenerated a callback converting each individual element to a string, a
 *  {@link CompositeGeneratorNode}, or undefined if to be omitted, defaults to {@link String}
 *
 * @param options optional config object for defining a `separator`, contributing specialized
 *  `prefix` and/or `suffix` providers, and activating conditional line-break insertion. In addition,
 *  a dedicated `filter` function can be provided that is required get provided with the original
 *  element indices in the aformentioned functions, if the list is to be filtered. If
 *  {@link Array.filter} would be applied to the original list, the indices will be those of the
 *  filtered list during subsequent processing that in particular will cause confusion when using
 *  the tracing variant of this function named ({@link joinTracedToNode}).
 * @returns the resulting {@link CompositeGeneratorNode} representing `iterable`'s content
 */
function joinToNode(iterable, toGenerated = String, { filter, prefix, suffix, separator, appendNewLineIfNotEmpty } = {}) {
    return reduceWithIsLast(iterable, (node, it, i, isLast) => {
        if (filter && !filter(it, i, isLast)) {
            return node;
        }
        const content = toGenerated(it, i, isLast);
        return (node !== null && node !== void 0 ? node : (node = new generator_node_1.CompositeGeneratorNode()))
            .append(prefix && prefix(it, i, isLast))
            .append(content)
            .append(suffix && suffix(it, i, isLast))
            .appendIf(!isLast && content !== undefined, separator)
            .appendNewLineIfNotEmptyIf(
        // append 'newLineIfNotEmpty' elements only if 'node' has some content already,
        //  as if the parent is an IndentNode with 'indentImmediately' set to 'false'
        //  the indentation is not properly applied to the first non-empty line of the (this) child node
        !node.isEmpty() && !!appendNewLineIfNotEmpty);
    });
}
exports.joinToNode = joinToNode;
// implementation:
function joinTracedToNode(source, property) {
    return (iterable, toGenerated = String, options) => {
        return (0, generator_node_1.traceToNode)(source, property)(joinToNode(iterable, source && property ? (element, index, isLast) => (0, generator_node_1.traceToNode)(source, property, index)(toGenerated(element, index, isLast)) : toGenerated, options));
    };
}
exports.joinTracedToNode = joinTracedToNode;
// implementation:
function joinTracedToNodeIf(condition, source, property) {
    return condition ? joinTracedToNode((typeof source === 'function' ? source() : source), property) : () => undefined;
}
exports.joinTracedToNodeIf = joinTracedToNodeIf;
function reduceWithIsLast(iterable, callbackfn, initial) {
    const iterator = iterable[Symbol.iterator]();
    let next = iterator.next();
    let index = 0;
    let result = initial;
    while (!next.done) {
        const nextNext = iterator.next();
        result = callbackfn(result, next.value, index, Boolean(nextNext.done));
        next = nextNext;
        index++;
    }
    return result;
}
//# sourceMappingURL=node-joiner.js.map