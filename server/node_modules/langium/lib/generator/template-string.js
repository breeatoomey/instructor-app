"use strict";
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizeEOL = exports.findIndentation = exports.NEWLINE_REGEXP = exports.SNLE = exports.expandToString = exports.expandToStringWithNL = void 0;
const generator_node_1 = require("./generator-node");
function expandToStringWithNL(staticParts, ...substitutions) {
    return expandToString(staticParts, ...substitutions) + generator_node_1.EOL;
}
exports.expandToStringWithNL = expandToStringWithNL;
/**
 * A tag function that automatically aligns embedded multiline strings.
 *
 * @param staticParts the static parts of a tagged template literal
 * @param substitutions the variable parts of a tagged template literal
 * @returns an aligned string that consists of the given parts
 */
function expandToString(staticParts, ...substitutions) {
    let lines = substitutions
        // align substitutions and fuse them with static parts
        .reduce((acc, subst, i) => { var _a; return acc + (subst === undefined ? exports.SNLE : align((0, generator_node_1.toString)(subst), acc)) + ((_a = staticParts[i + 1]) !== null && _a !== void 0 ? _a : ''); }, staticParts[0])
        // converts text to lines
        .split(exports.NEWLINE_REGEXP)
        .filter(l => l.trim() !== exports.SNLE)
        // whitespace-only lines are empty (preserving leading whitespace)
        .map(l => l.replace(exports.SNLE, '').trimRight());
    // in order to nicely handle single line templates with the leading and trailing termintators (``) on separate lines, like
    //   expandToString`foo
    //   `,
    //   expandToString`
    //      foo
    //   `,
    //   expandToString`
    //      foo`,
    // the same way as true single line templates like
    //   expandToString`foo`
    // ...
    // ... drop initial linebreak if the first line is empty or contains white space only, ...
    const containsLeadingLinebreak = lines.length > 1 && lines[0].trim().length === 0;
    lines = containsLeadingLinebreak ? lines.slice(1) : lines;
    // .. and drop the last linebreak if it's the last charactor or is followed by white space
    const containsTrailingLinebreak = lines.length !== 0 && lines[lines.length - 1].trimRight().length === 0;
    lines = containsTrailingLinebreak ? lines.slice(0, lines.length - 1) : lines;
    // finds the minimum indentation
    const indent = findIndentation(lines);
    return lines
        // shifts lines to the left
        .map(line => line.slice(indent).trimRight())
        // convert lines to string
        .join(generator_node_1.EOL);
}
exports.expandToString = expandToString;
exports.SNLE = Object.freeze('__«SKIP^NEW^LINE^IF^EMPTY»__');
exports.NEWLINE_REGEXP = /\r?\n/g;
const nonWhitespace = /\S|$/;
// add the alignment of the previous static part to all lines of the following substitution
function align(subst, acc) {
    const length = Math.max(0, acc.length - acc.lastIndexOf('\n') - 1);
    const indent = ' '.repeat(length);
    return subst.replace(exports.NEWLINE_REGEXP, generator_node_1.EOL + indent);
}
// finds the indentation of a text block represented by a sequence of lines
function findIndentation(lines) {
    const indents = lines.filter(line => line.length > 0).map(line => line.search(nonWhitespace));
    const min = indents.length === 0 ? 0 : Math.min(...indents); // min(...[]) = min() = Infinity
    return Math.max(0, min);
}
exports.findIndentation = findIndentation;
function normalizeEOL(input) {
    return input.replace(exports.NEWLINE_REGEXP, generator_node_1.EOL);
}
exports.normalizeEOL = normalizeEOL;
//# sourceMappingURL=template-string.js.map