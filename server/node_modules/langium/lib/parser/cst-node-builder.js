"use strict";
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.RootCstNodeImpl = exports.CompositeCstNodeImpl = exports.LeafCstNodeImpl = exports.AbstractCstNode = exports.CstNodeBuilder = void 0;
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const syntax_tree_1 = require("../syntax-tree");
const cst_util_1 = require("../utils/cst-util");
class CstNodeBuilder {
    constructor() {
        this.nodeStack = [];
    }
    get current() {
        return this.nodeStack[this.nodeStack.length - 1];
    }
    buildRootNode(input) {
        this.rootNode = new RootCstNodeImpl(input);
        this.nodeStack = [this.rootNode];
        return this.rootNode;
    }
    buildCompositeNode(feature) {
        const compositeNode = new CompositeCstNodeImpl();
        compositeNode.feature = feature;
        compositeNode.root = this.rootNode;
        this.current.children.push(compositeNode);
        this.nodeStack.push(compositeNode);
        return compositeNode;
    }
    buildLeafNode(token, feature) {
        const leafNode = new LeafCstNodeImpl(token.startOffset, token.image.length, (0, cst_util_1.tokenToRange)(token), token.tokenType, false);
        leafNode.feature = feature;
        leafNode.root = this.rootNode;
        this.current.children.push(leafNode);
        return leafNode;
    }
    removeNode(node) {
        const parent = node.parent;
        if (parent) {
            const index = parent.children.indexOf(node);
            if (index >= 0) {
                parent.children.splice(index, 1);
            }
        }
    }
    construct(item) {
        const current = this.current;
        // The specified item could be a datatype ($type is symbol) or a fragment ($type is undefined)
        // Only if the $type is a string, we actually assign the element
        if (typeof item.$type === 'string') {
            this.current.element = item;
        }
        item.$cstNode = current;
        const node = this.nodeStack.pop();
        // Empty composite nodes are not valid
        // Simply remove the node from the tree
        if ((node === null || node === void 0 ? void 0 : node.children.length) === 0) {
            this.removeNode(node);
        }
    }
    addHiddenTokens(hiddenTokens) {
        for (const token of hiddenTokens) {
            const hiddenNode = new LeafCstNodeImpl(token.startOffset, token.image.length, (0, cst_util_1.tokenToRange)(token), token.tokenType, true);
            hiddenNode.root = this.rootNode;
            this.addHiddenToken(this.rootNode, hiddenNode);
        }
    }
    addHiddenToken(node, token) {
        const { offset: tokenStart, end: tokenEnd } = token;
        for (let i = 0; i < node.children.length; i++) {
            const child = node.children[i];
            const { offset: childStart, end: childEnd } = child;
            if ((0, syntax_tree_1.isCompositeCstNode)(child) && tokenStart > childStart && tokenEnd < childEnd) {
                this.addHiddenToken(child, token);
                return;
            }
            else if (tokenEnd <= childStart) {
                node.children.splice(i, 0, token);
                return;
            }
        }
        // We know that we haven't found a suited position for the token
        // So we simply add it to the end of the current node
        node.children.push(token);
    }
}
exports.CstNodeBuilder = CstNodeBuilder;
class AbstractCstNode {
    get hidden() {
        return false;
    }
    get element() {
        var _a, _b;
        const node = typeof ((_a = this._element) === null || _a === void 0 ? void 0 : _a.$type) === 'string' ? this._element : (_b = this.parent) === null || _b === void 0 ? void 0 : _b.element;
        if (!node) {
            throw new Error('This node has no associated AST element');
        }
        return node;
    }
    set element(value) {
        this._element = value;
    }
    get text() {
        return this.root.fullText.substring(this.offset, this.end);
    }
}
exports.AbstractCstNode = AbstractCstNode;
class LeafCstNodeImpl extends AbstractCstNode {
    get offset() {
        return this._offset;
    }
    get length() {
        return this._length;
    }
    get end() {
        return this._offset + this._length;
    }
    get hidden() {
        return this._hidden;
    }
    get tokenType() {
        return this._tokenType;
    }
    get range() {
        return this._range;
    }
    constructor(offset, length, range, tokenType, hidden = false) {
        super();
        this._hidden = hidden;
        this._offset = offset;
        this._tokenType = tokenType;
        this._length = length;
        this._range = range;
    }
}
exports.LeafCstNodeImpl = LeafCstNodeImpl;
class CompositeCstNodeImpl extends AbstractCstNode {
    constructor() {
        super(...arguments);
        this.children = new CstNodeContainer(this);
    }
    get offset() {
        var _a, _b;
        return (_b = (_a = this.firstNonHiddenNode) === null || _a === void 0 ? void 0 : _a.offset) !== null && _b !== void 0 ? _b : 0;
    }
    get length() {
        return this.end - this.offset;
    }
    get end() {
        var _a, _b;
        return (_b = (_a = this.lastNonHiddenNode) === null || _a === void 0 ? void 0 : _a.end) !== null && _b !== void 0 ? _b : 0;
    }
    get range() {
        const firstNode = this.firstNonHiddenNode;
        const lastNode = this.lastNonHiddenNode;
        if (firstNode && lastNode) {
            if (this._rangeCache === undefined) {
                const { range: firstRange } = firstNode;
                const { range: lastRange } = lastNode;
                this._rangeCache = { start: firstRange.start, end: lastRange.end.line < firstRange.start.line ? firstRange.start : lastRange.end };
            }
            return this._rangeCache;
        }
        else {
            return { start: vscode_languageserver_types_1.Position.create(0, 0), end: vscode_languageserver_types_1.Position.create(0, 0) };
        }
    }
    get firstNonHiddenNode() {
        for (const child of this.children) {
            if (!child.hidden) {
                return child;
            }
        }
        return this.children[0];
    }
    get lastNonHiddenNode() {
        for (let i = this.children.length - 1; i >= 0; i--) {
            const child = this.children[i];
            if (!child.hidden) {
                return child;
            }
        }
        return this.children[this.children.length - 1];
    }
}
exports.CompositeCstNodeImpl = CompositeCstNodeImpl;
class CstNodeContainer extends Array {
    constructor(parent) {
        super();
        this.parent = parent;
        Object.setPrototypeOf(this, CstNodeContainer.prototype);
    }
    push(...items) {
        this.addParents(items);
        return super.push(...items);
    }
    unshift(...items) {
        this.addParents(items);
        return super.unshift(...items);
    }
    splice(start, count, ...items) {
        this.addParents(items);
        return super.splice(start, count, ...items);
    }
    addParents(items) {
        for (const item of items) {
            item.parent = this.parent;
        }
    }
}
class RootCstNodeImpl extends CompositeCstNodeImpl {
    get text() {
        return this._text.substring(this.offset, this.end);
    }
    get fullText() {
        return this._text;
    }
    constructor(input) {
        super();
        this._text = '';
        this._text = input !== null && input !== void 0 ? input : '';
    }
}
exports.RootCstNodeImpl = RootCstNodeImpl;
//# sourceMappingURL=cst-node-builder.js.map