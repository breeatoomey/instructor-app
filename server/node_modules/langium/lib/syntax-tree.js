"use strict";
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.isRootCstNode = exports.isLeafCstNode = exports.isCompositeCstNode = exports.AbstractAstReflection = exports.isLinkingError = exports.isAstNodeDescription = exports.isReference = exports.isAstNode = void 0;
function isAstNode(obj) {
    return typeof obj === 'object' && obj !== null && typeof obj.$type === 'string';
}
exports.isAstNode = isAstNode;
function isReference(obj) {
    return typeof obj === 'object' && obj !== null && typeof obj.$refText === 'string';
}
exports.isReference = isReference;
function isAstNodeDescription(obj) {
    return typeof obj === 'object' && obj !== null
        && typeof obj.name === 'string'
        && typeof obj.type === 'string'
        && typeof obj.path === 'string';
}
exports.isAstNodeDescription = isAstNodeDescription;
function isLinkingError(obj) {
    return typeof obj === 'object' && obj !== null
        && isAstNode(obj.container)
        && isReference(obj.reference)
        && typeof obj.message === 'string';
}
exports.isLinkingError = isLinkingError;
/**
 * An abstract implementation of the {@link AstReflection} interface.
 * Serves to cache subtype computation results to improve performance throughout different parts of Langium.
 */
class AbstractAstReflection {
    constructor() {
        this.subtypes = {};
        this.allSubtypes = {};
    }
    isInstance(node, type) {
        return isAstNode(node) && this.isSubtype(node.$type, type);
    }
    isSubtype(subtype, supertype) {
        if (subtype === supertype) {
            return true;
        }
        let nested = this.subtypes[subtype];
        if (!nested) {
            nested = this.subtypes[subtype] = {};
        }
        const existing = nested[supertype];
        if (existing !== undefined) {
            return existing;
        }
        else {
            const result = this.computeIsSubtype(subtype, supertype);
            nested[supertype] = result;
            return result;
        }
    }
    getAllSubTypes(type) {
        const existing = this.allSubtypes[type];
        if (existing) {
            return existing;
        }
        else {
            const allTypes = this.getAllTypes();
            const types = [];
            for (const possibleSubType of allTypes) {
                if (this.isSubtype(possibleSubType, type)) {
                    types.push(possibleSubType);
                }
            }
            this.allSubtypes[type] = types;
            return types;
        }
    }
}
exports.AbstractAstReflection = AbstractAstReflection;
function isCompositeCstNode(node) {
    return typeof node === 'object' && node !== null && 'children' in node;
}
exports.isCompositeCstNode = isCompositeCstNode;
function isLeafCstNode(node) {
    return typeof node === 'object' && node !== null && 'tokenType' in node;
}
exports.isLeafCstNode = isLeafCstNode;
function isRootCstNode(node) {
    return isCompositeCstNode(node) && 'fullText' in node;
}
exports.isRootCstNode = isRootCstNode;
//# sourceMappingURL=syntax-tree.js.map