"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPackageJson = exports.findPackageJson = exports.ensurePackage = exports.installPackage = exports.getPackageManager = exports.findNodeModulesFile = exports.findUp = void 0;
const node_fs_1 = __importDefault(require("node:fs"));
const node_path_1 = __importDefault(require("node:path"));
const exec_utils_1 = require("./exec-utils");
const ts_pattern_1 = require("ts-pattern");
/**
 * Find and return file paths by searching parent directories based on the given names list and current working directory (cwd) path.
 * Optionally return a single path or multiple paths.
 * If multiple allowed, return all paths found.
 * If no paths are found, return undefined.
 *
 * @export
 * @template [e=false]
 * @param names An array of strings representing names to search for within the directory
 * @param cwd A string representing the current working directory
 * @param [multiple=false as e] A boolean flag indicating whether to search for multiple levels. Useful for finding node_modules directories...
 * @param [result=[]] An array of strings representing the accumulated results used in multiple results
 * @returns Path(s) to a specific file or folder within the directory or parent directories
 */
function findUp(names, cwd = process.cwd(), multiple = false, result = []) {
    if (!names.some((name) => !!name))
        return undefined;
    const target = names.find((name) => node_fs_1.default.existsSync(node_path_1.default.join(cwd, name)));
    if (multiple == false && target)
        return node_path_1.default.join(cwd, target);
    if (target)
        result.push(node_path_1.default.join(cwd, target));
    const up = node_path_1.default.resolve(cwd, '..');
    if (up === cwd)
        return (multiple && result.length > 0 ? result : undefined); // it'll fail anyway
    return findUp(names, up, multiple, result);
}
exports.findUp = findUp;
/**
 * Find a Node module/file given its name in a specific directory, with a fallback to the current working directory.
 * If the name is empty, return undefined.
 * Try to resolve the module/file using require.resolve with the specified directory as the starting point.
 * Return the resolved path if successful, otherwise return undefined.
 *
 * @export
 * @param {string} name The name of the module/file to find
 * @param {string} [cwd=process.cwd()]
 * @returns {*} Finds a specified module or file using require.resolve starting from a specified directory path, or the current working directory if not provided.
 */
function findNodeModulesFile(name, cwd = process.cwd()) {
    if (!name)
        return undefined;
    try {
        // Use require.resolve to find the module/file. The paths option allows specifying the directory to start from.
        const resolvedPath = require.resolve(name, { paths: [cwd] });
        return resolvedPath;
    }
    catch (error) {
        // If require.resolve fails to find the module/file, it will throw an error.
        return undefined;
    }
}
exports.findNodeModulesFile = findNodeModulesFile;
function getPackageManager(searchStartPath = '.') {
    const lockFile = findUp(['yarn.lock', 'pnpm-lock.yaml', 'package-lock.json'], searchStartPath);
    if (!lockFile) {
        // default use npm
        return { packageManager: 'npm', lockFile: undefined, projectRoot: searchStartPath };
    }
    const packageManager = (0, ts_pattern_1.match)(node_path_1.default.basename(lockFile))
        .with('yarn.lock', () => 'yarn')
        .with('pnpm-lock.yaml', () => 'pnpm')
        .otherwise(() => 'npm');
    return { packageManager, lockFile, projectRoot: node_path_1.default.dirname(lockFile) };
}
exports.getPackageManager = getPackageManager;
function installPackage(pkg, dev, pkgManager = undefined, tag = 'latest', projectPath = '.', exactVersion = true) {
    const manager = pkgManager !== null && pkgManager !== void 0 ? pkgManager : getPackageManager(projectPath).packageManager;
    console.log(`Installing package "${pkg}@${tag}" with ${manager}`);
    switch (manager) {
        case 'yarn':
            (0, exec_utils_1.execSync)(`yarn --cwd "${projectPath}" add ${exactVersion ? '--exact' : ''} ${pkg}@${tag} ${dev ? ' --dev' : ''}`);
            break;
        case 'pnpm':
            (0, exec_utils_1.execSync)(`pnpm add -C "${projectPath}" ${exactVersion ? '--save-exact' : ''} ${dev ? ' --save-dev' : ''} ${pkg}@${tag}`);
            break;
        default:
            (0, exec_utils_1.execSync)(`npm install --prefix "${projectPath}" ${exactVersion ? '--save-exact' : ''} ${dev ? ' --save-dev' : ''} ${pkg}@${tag}`);
            break;
    }
}
exports.installPackage = installPackage;
function ensurePackage(pkg, dev, pkgManager = undefined, tag = 'latest', projectPath = '.', exactVersion = false) {
    const resolvePath = node_path_1.default.resolve(projectPath);
    try {
        require.resolve(pkg, { paths: [resolvePath] });
    }
    catch (err) {
        installPackage(pkg, dev, pkgManager, tag, resolvePath, exactVersion);
    }
}
exports.ensurePackage = ensurePackage;
/**
 * A function that searches for the nearest package.json file starting from the provided search path or the current working directory if no search path is provided.
 * It iterates through the directory structure going one level up at a time until it finds a package.json file. If no package.json file is found, it returns undefined.
 * @deprecated Use findUp instead @see findUp
 */
function findPackageJson(searchPath) {
    let currDir = searchPath !== null && searchPath !== void 0 ? searchPath : process.cwd();
    while (currDir) {
        const pkgJsonPath = node_path_1.default.join(currDir, 'package.json');
        if (node_fs_1.default.existsSync(pkgJsonPath)) {
            return pkgJsonPath;
        }
        const up = node_path_1.default.resolve(currDir, '..');
        if (up === currDir) {
            return undefined;
        }
        currDir = up;
    }
    return undefined;
}
exports.findPackageJson = findPackageJson;
function getPackageJson(searchPath) {
    const pkgJsonPath = findUp(['package.json'], searchPath !== null && searchPath !== void 0 ? searchPath : process.cwd());
    if (pkgJsonPath) {
        return JSON.parse(node_fs_1.default.readFileSync(pkgJsonPath, 'utf-8'));
    }
    else {
        return undefined;
    }
}
exports.getPackageJson = getPackageJson;
//# sourceMappingURL=pkg-utils.js.map