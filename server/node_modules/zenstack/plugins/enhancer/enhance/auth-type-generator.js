"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateAuthType = void 0;
const sdk_1 = require("@zenstackhq/sdk");
const ast_1 = require("@zenstackhq/sdk/ast");
const langium_1 = require("langium");
const ast_utils_1 = require("../../../utils/ast-utils");
/**
 * Generate types for typing the `user` context object passed to the `enhance` call, based
 * on the fields (potentially deeply) access through `auth()`.
 */
function generateAuthType(model, authModel) {
    const types = new Map();
    types.set(authModel.name, { pickFields: (0, sdk_1.getIdFields)(authModel).map((f) => f.name), addFields: [] });
    const ensureType = (model) => {
        if (!types.has(model)) {
            types.set(model, { pickFields: [], addFields: [] });
        }
    };
    const addPickField = (model, field) => {
        let fields = types.get(model);
        if (!fields) {
            fields = { pickFields: [], addFields: [] };
            types.set(model, fields);
        }
        if (!fields.pickFields.includes(field)) {
            fields.pickFields.push(field);
        }
    };
    const addAddField = (model, name, type, array) => {
        let fields = types.get(model);
        if (!fields) {
            fields = { pickFields: [], addFields: [] };
            types.set(model, fields);
        }
        if (!fields.addFields.find((f) => f.name === name)) {
            fields.addFields.push({ name, type: array ? `${type}[]` : type });
        }
    };
    // get all policy expressions involving `auth()`
    const authInvolvedExprs = (0, langium_1.streamAst)(model).filter(isAuthAccess);
    // traverse the expressions and collect types and fields involved
    authInvolvedExprs.forEach((expr) => {
        (0, langium_1.streamAst)(expr).forEach((node) => {
            var _a, _b, _c;
            if ((0, ast_1.isMemberAccessExpr)(node)) {
                const exprType = (_a = node.operand.$resolvedType) === null || _a === void 0 ? void 0 : _a.decl;
                if ((0, ast_1.isDataModel)(exprType)) {
                    const memberDecl = node.member.ref;
                    if ((0, ast_1.isDataModel)((_b = memberDecl === null || memberDecl === void 0 ? void 0 : memberDecl.type.reference) === null || _b === void 0 ? void 0 : _b.ref)) {
                        // member is a relation
                        const fieldType = memberDecl.type.reference.ref.name;
                        ensureType(fieldType);
                        addAddField(exprType.name, memberDecl.name, fieldType, memberDecl.type.array);
                    }
                    else {
                        // member is a scalar
                        if (!isIgnoredField(node.member.ref)) {
                            addPickField(exprType.name, node.member.$refText);
                        }
                    }
                }
            }
            if ((0, sdk_1.isDataModelFieldReference)(node)) {
                // this can happen inside collection predicates
                const fieldDecl = node.target.ref;
                const fieldType = (_c = fieldDecl.type.reference) === null || _c === void 0 ? void 0 : _c.ref;
                if ((0, ast_1.isDataModel)(fieldType)) {
                    // field is a relation
                    ensureType(fieldType.name);
                    addAddField(fieldDecl.$container.name, node.target.$refText, fieldType.name, fieldDecl.type.array);
                }
                else {
                    if (!isIgnoredField(fieldDecl)) {
                        // field is a scalar
                        addPickField(fieldDecl.$container.name, node.target.$refText);
                    }
                }
            }
        });
    });
    // generate:
    // `
    // namespace auth {
    //   export type User = WithRequired<Partial<_P.User>, 'id'> & { profile: Profile; } & Record<string, unknown>;
    //   export type Profile = WithRequired<Partial<_P.Profile>, 'age'> & Record<string, unknown>;
    // }
    // `
    return `export namespace auth {
    type WithRequired<T, K extends keyof T> = T & { [P in K]-?: T[P] };
${Array.from(types.entries())
        .map(([model, fields]) => {
        let result = `Partial<_P.${model}>`;
        if (fields.pickFields.length > 0) {
            result = `WithRequired<${result}, ${fields.pickFields
                .map((f) => `'${f}'`)
                .join('|')}> & Record<string, unknown>`;
        }
        if (fields.addFields.length > 0) {
            result = `${result} & { ${fields.addFields.map(({ name, type }) => `${name}: ${type}`).join('; ')} }`;
        }
        return `    export type ${model} = ${result};`;
    })
        .join('\n')}
}`;
}
exports.generateAuthType = generateAuthType;
function isAuthAccess(node) {
    if ((0, sdk_1.isAuthInvocation)(node)) {
        return true;
    }
    if ((0, ast_1.isMemberAccessExpr)(node) && isAuthAccess(node.operand)) {
        return true;
    }
    if ((0, ast_utils_1.isCollectionPredicate)(node)) {
        if (isAuthAccess(node.left)) {
            return true;
        }
    }
    return false;
}
function isIgnoredField(field) {
    return !!(field && (0, sdk_1.hasAttribute)(field, '@ignore'));
}
//# sourceMappingURL=auth-type-generator.js.map