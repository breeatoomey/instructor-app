"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EnhancerGenerator = void 0;
const runtime_1 = require("@zenstackhq/runtime");
const sdk_1 = require("@zenstackhq/sdk");
const ast_1 = require("@zenstackhq/sdk/ast");
const prisma_1 = require("@zenstackhq/sdk/prisma");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const semver_1 = __importDefault(require("semver"));
const ts_morph_1 = require("ts-morph");
const upper_case_first_1 = require("upper-case-first");
const __1 = require("..");
const exec_utils_1 = require("../../../utils/exec-utils");
const prisma_2 = require("../../prisma");
const schema_generator_1 = require("../../prisma/schema-generator");
const enhancer_utils_1 = require("../enhancer-utils");
const auth_type_generator_1 = require("./auth-type-generator");
const checker_type_generator_1 = require("./checker-type-generator");
const LOGICAL_CLIENT_GENERATION_PATH = './.logical-prisma-client';
class EnhancerGenerator {
    constructor(model, options, project, outDir) {
        this.model = model;
        this.options = options;
        this.project = project;
        this.outDir = outDir;
    }
    generate() {
        return __awaiter(this, void 0, void 0, function* () {
            let logicalPrismaClientDir;
            let dmmf;
            const prismaImport = (0, prisma_1.getPrismaClientImportSpec)(this.outDir, this.options);
            if (this.needsLogicalClient()) {
                // schema contains delegate models, need to generate a logical prisma schema
                const result = yield this.generateLogicalPrisma();
                logicalPrismaClientDir = LOGICAL_CLIENT_GENERATION_PATH;
                dmmf = result.dmmf;
                // create a reexport of the logical prisma client
                const prismaDts = this.project.createSourceFile(path_1.default.join(this.outDir, 'models.d.ts'), `export type * from '${logicalPrismaClientDir}/index-fixed';`, { overwrite: true });
                yield prismaDts.save();
            }
            else {
                // just reexport the prisma client
                const prismaDts = this.project.createSourceFile(path_1.default.join(this.outDir, 'models.d.ts'), `export type * from '${prismaImport}';`, { overwrite: true });
                yield prismaDts.save();
            }
            const authModel = (0, sdk_1.getAuthModel)((0, sdk_1.getDataModels)(this.model));
            const authTypes = authModel ? (0, auth_type_generator_1.generateAuthType)(this.model, authModel) : '';
            const authTypeParam = authModel ? `auth.${authModel.name}` : 'AuthUser';
            const checkerTypes = this.generatePermissionChecker ? (0, checker_type_generator_1.generateCheckerType)(this.model) : '';
            const enhanceTs = this.project.createSourceFile(path_1.default.join(this.outDir, 'enhance.ts'), `import { type EnhancementContext, type EnhancementOptions, type ZodSchemas, type AuthUser } from '@zenstackhq/runtime';
import { createEnhancement } from '@zenstackhq/runtime/enhancements';
import modelMeta from './model-meta';
import policy from './policy';
${this.options.withZodSchemas ? "import * as zodSchemas from './zod';" : 'const zodSchemas = undefined;'}

${logicalPrismaClientDir
                ? this.createLogicalPrismaImports(prismaImport, logicalPrismaClientDir)
                : this.createSimplePrismaImports(prismaImport)}

${authTypes}

${checkerTypes}

${logicalPrismaClientDir
                ? this.createLogicalPrismaEnhanceFunction(authTypeParam)
                : this.createSimplePrismaEnhanceFunction(authTypeParam)}
    `, { overwrite: true });
            yield this.saveSourceFile(enhanceTs);
            return { dmmf };
        });
    }
    createSimplePrismaImports(prismaImport) {
        return `import { Prisma } from '${prismaImport}';
import type * as _P from '${prismaImport}';
        `;
    }
    createSimplePrismaEnhanceFunction(authTypeParam) {
        const returnType = `DbClient${this.generatePermissionChecker ? ' & ModelCheckers' : ''}`;
        return `
export function enhance<DbClient extends object>(prisma: DbClient, context?: EnhancementContext<${authTypeParam}>, options?: EnhancementOptions): ${returnType} {
    return createEnhancement(prisma, {
        modelMeta,
        policy,
        zodSchemas: zodSchemas as unknown as (ZodSchemas | undefined),
        prismaModule: Prisma,
        ...options
    }, context) as ${returnType};
}         
            `;
    }
    createLogicalPrismaImports(prismaImport, logicalPrismaClientDir) {
        return `import { Prisma as _Prisma, PrismaClient as _PrismaClient } from '${prismaImport}';
import type {
    InternalArgs,
    TypeMapDef,
    TypeMapCbDef,
    DynamicClientExtensionThis,
} from '${prismaImport}/runtime/library';
import type * as _P from '${logicalPrismaClientDir}/index-fixed';
import type { Prisma, PrismaClient } from '${logicalPrismaClientDir}/index-fixed';
`;
    }
    createLogicalPrismaEnhanceFunction(authTypeParam) {
        return `
// overload for plain PrismaClient
export function enhance<ExtArgs extends Record<string, any> & InternalArgs>(
    prisma: _PrismaClient<any, any, ExtArgs>,
    context?: EnhancementContext<${authTypeParam}>, options?: EnhancementOptions): PrismaClient${this.generatePermissionChecker ? ' & ModelCheckers' : ''};
    
// overload for extended PrismaClient
export function enhance<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any> & InternalArgs>(
    prisma: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>,
    context?: EnhancementContext<${authTypeParam}>, options?: EnhancementOptions): DynamicClientExtensionThis<Prisma.TypeMap, Prisma.TypeMapCb, ExtArgs>${this.generatePermissionChecker ? ' & ModelCheckers' : ''};

export function enhance(prisma: any, context?: EnhancementContext<${authTypeParam}>, options?: EnhancementOptions): any {
    return createEnhancement(prisma, {
        modelMeta,
        policy,
        zodSchemas: zodSchemas as unknown as (ZodSchemas | undefined),
        prismaModule: _Prisma,
        ...options
    }, context);
}
`;
    }
    needsLogicalClient() {
        return this.hasDelegateModel(this.model) || this.hasAuthInDefault(this.model);
    }
    hasDelegateModel(model) {
        const dataModels = (0, sdk_1.getDataModels)(model);
        return dataModels.some((dm) => (0, sdk_1.isDelegateModel)(dm) && dataModels.some((sub) => sub.superTypes.some((base) => base.ref === dm)));
    }
    hasAuthInDefault(model) {
        return (0, sdk_1.getDataModels)(model).some((dm) => dm.fields.some((f) => f.attributes.some((attr) => (0, enhancer_utils_1.isDefaultWithAuth)(attr))));
    }
    generateLogicalPrisma() {
        return __awaiter(this, void 0, void 0, function* () {
            const prismaGenerator = new schema_generator_1.PrismaSchemaGenerator(this.model);
            // dir of the zmodel file
            const zmodelDir = path_1.default.dirname(this.options.schemaPath);
            // generate a temp logical prisma schema in zmodel's dir
            const logicalPrismaFile = path_1.default.join(zmodelDir, `logical-${Date.now()}.prisma`);
            // calculate a relative output path to output the logical prisma client into enhancer's output dir
            const prismaClientOutDir = path_1.default.join(path_1.default.relative(zmodelDir, this.outDir), LOGICAL_CLIENT_GENERATION_PATH);
            yield prismaGenerator.generate({
                provider: '@internal', // doesn't matter
                schemaPath: this.options.schemaPath,
                output: logicalPrismaFile,
                overrideClientGenerationPath: prismaClientOutDir,
                mode: 'logical',
            });
            // generate the prisma client
            // only run prisma client generator for the logical schema
            const prismaClientGeneratorName = this.getPrismaClientGeneratorName(this.model);
            let generateCmd = `prisma generate --schema "${logicalPrismaFile}" --generator=${prismaClientGeneratorName}`;
            const prismaVersion = (0, prisma_1.getPrismaVersion)();
            if (!prismaVersion || semver_1.default.gte(prismaVersion, '5.2.0')) {
                // add --no-engine to reduce generation size if the prisma version supports
                generateCmd += ' --no-engine';
            }
            try {
                // run 'prisma generate'
                yield (0, exec_utils_1.execPackage)(generateCmd, { stdio: 'ignore' });
            }
            catch (_a) {
                yield (0, prisma_2.trackPrismaSchemaError)(logicalPrismaFile);
                try {
                    // run 'prisma generate' again with output to the console
                    yield (0, exec_utils_1.execPackage)(generateCmd);
                }
                catch (_b) {
                    // noop
                }
                throw new sdk_1.PluginError(__1.name, `Failed to run "prisma generate" on logical schema: ${logicalPrismaFile}`);
            }
            // make a bunch of typing fixes to the generated prisma client
            yield this.processClientTypes(path_1.default.join(this.outDir, LOGICAL_CLIENT_GENERATION_PATH));
            const dmmf = yield (0, prisma_1.getDMMF)({ datamodel: fs_1.default.readFileSync(logicalPrismaFile, { encoding: 'utf-8' }) });
            try {
                // clean up temp schema
                if (fs_1.default.existsSync(logicalPrismaFile)) {
                    fs_1.default.rmSync(logicalPrismaFile);
                }
            }
            catch (_c) {
                // ignore errors
            }
            return {
                prismaSchema: logicalPrismaFile,
                // load the dmmf of the logical prisma schema
                dmmf,
            };
        });
    }
    getPrismaClientGeneratorName(model) {
        for (const generator of model.declarations.filter(ast_1.isGeneratorDecl)) {
            if (generator.fields.some((f) => f.name === 'provider' && (0, sdk_1.getLiteral)(f.value) === 'prisma-client-js')) {
                return generator.name;
            }
        }
        throw new sdk_1.PluginError(__1.name, `Cannot find prisma-client-js generator in the schema`);
    }
    processClientTypes(prismaClientDir) {
        return __awaiter(this, void 0, void 0, function* () {
            // make necessary updates to the generated `index.d.ts` file and save it as `index-fixed.d.ts`
            const project = new ts_morph_1.Project();
            const sf = project.addSourceFileAtPath(path_1.default.join(prismaClientDir, 'index.d.ts'));
            // build a map of delegate models and their sub models
            const delegateInfo = [];
            this.model.declarations
                .filter((d) => (0, sdk_1.isDelegateModel)(d))
                .forEach((dm) => {
                const concreteModels = this.model.declarations.filter((d) => (0, ast_1.isDataModel)(d) && d.superTypes.some((s) => s.ref === dm));
                if (concreteModels.length > 0) {
                    delegateInfo.push([dm, concreteModels]);
                }
            });
            // transform index.d.ts and save it into a new file (better perf than in-line editing)
            const sfNew = project.createSourceFile(path_1.default.join(prismaClientDir, 'index-fixed.d.ts'), undefined, {
                overwrite: true,
            });
            if (delegateInfo.length > 0) {
                // transform types for delegated models
                this.transformDelegate(sf, sfNew, delegateInfo);
                sfNew.formatText();
            }
            else {
                // just copy
                sfNew.replaceWithText(sf.getFullText());
            }
            yield sfNew.save();
        });
    }
    transformDelegate(sf, sfNew, delegateInfo) {
        // copy toplevel imports
        sfNew.addImportDeclarations(sf.getImportDeclarations().map((n) => n.getStructure()));
        // copy toplevel import equals
        sfNew.addStatements(sf.getChildrenOfKind(ts_morph_1.SyntaxKind.ImportEqualsDeclaration).map((n) => n.getFullText()));
        // copy toplevel exports
        sfNew.addExportAssignments(sf.getExportAssignments().map((n) => n.getStructure()));
        // copy toplevel type aliases
        sfNew.addTypeAliases(sf.getTypeAliases().map((n) => n.getStructure()));
        // copy toplevel classes
        sfNew.addClasses(sf.getClasses().map((n) => n.getStructure()));
        // copy toplevel variables
        sfNew.addVariableStatements(sf.getVariableStatements().map((n) => n.getStructure()));
        // copy toplevel namespaces except for `Prisma`
        sfNew.addModules(sf
            .getModules()
            .filter((n) => n.getName() !== 'Prisma')
            .map((n) => n.getStructure()));
        // transform the `Prisma` namespace
        const prismaModule = sf.getModuleOrThrow('Prisma');
        const newPrismaModule = sfNew.addModule({ name: 'Prisma', isExported: true });
        this.transformPrismaModule(prismaModule, newPrismaModule, delegateInfo);
    }
    transformPrismaModule(prismaModule, newPrismaModule, delegateInfo) {
        // module block is the direct container of declarations inside a namespace
        const moduleBlock = prismaModule.getFirstChildByKindOrThrow(ts_morph_1.SyntaxKind.ModuleBlock);
        // most of the toplevel constructs should be copied over
        // here we use ts-morph batch operations for optimal performance
        // copy imports
        newPrismaModule.addStatements(moduleBlock.getChildrenOfKind(ts_morph_1.SyntaxKind.ImportEqualsDeclaration).map((n) => n.getFullText()));
        // copy classes
        newPrismaModule.addClasses(moduleBlock.getClasses().map((n) => n.getStructure()));
        // copy functions
        newPrismaModule.addFunctions(moduleBlock.getFunctions().map((n) => n.getStructure()));
        // copy nested namespaces
        newPrismaModule.addModules(moduleBlock.getModules().map((n) => n.getStructure()));
        // transform variables
        const newVariables = moduleBlock
            .getVariableStatements()
            .map((variable) => this.transformVariableStatement(variable));
        newPrismaModule.addVariableStatements(newVariables);
        // transform interfaces
        const newInterfaces = moduleBlock.getInterfaces().map((iface) => this.transformInterface(iface, delegateInfo));
        newPrismaModule.addInterfaces(newInterfaces);
        // transform type aliases
        const newTypeAliases = moduleBlock
            .getTypeAliases()
            .map((typeAlias) => this.transformTypeAlias(typeAlias, delegateInfo));
        newPrismaModule.addTypeAliases(newTypeAliases);
    }
    transformVariableStatement(variable) {
        const structure = variable.getStructure();
        // remove `delegate_aux_*` fields from the variable's typing
        const auxFields = this.findAuxDecls(variable);
        if (auxFields.length > 0) {
            structure.declarations.forEach((variable) => {
                var _a;
                let source = (_a = variable.type) === null || _a === void 0 ? void 0 : _a.toString();
                auxFields.forEach((f) => {
                    source = source === null || source === void 0 ? void 0 : source.replace(f.getText(), '');
                });
                variable.type = source;
            });
        }
        return structure;
    }
    transformInterface(iface, delegateInfo) {
        var _a, _b, _c;
        const structure = iface.getStructure();
        // filter out aux fields
        structure.properties = (_a = structure.properties) === null || _a === void 0 ? void 0 : _a.filter((p) => !p.name.startsWith(runtime_1.DELEGATE_AUX_RELATION_PREFIX));
        // filter out aux methods
        structure.methods = (_b = structure.methods) === null || _b === void 0 ? void 0 : _b.filter((m) => !m.name.startsWith(runtime_1.DELEGATE_AUX_RELATION_PREFIX));
        if (delegateInfo.some(([delegate]) => `${delegate.name}Delegate` === iface.getName())) {
            // delegate models cannot be created directly, remove create/createMany/upsert
            structure.methods = (_c = structure.methods) === null || _c === void 0 ? void 0 : _c.filter((m) => !['create', 'createMany', 'upsert'].includes(m.name));
        }
        return structure;
    }
    transformTypeAlias(typeAlias, delegateInfo) {
        const structure = typeAlias.getStructure();
        let source = structure.type;
        // remove aux fields
        source = this.removeAuxFieldsFromTypeAlias(typeAlias, source);
        // remove discriminator field from concrete input types
        source = this.removeDiscriminatorFromConcreteInput(typeAlias, delegateInfo, source);
        // remove create/connectOrCreate/upsert fields from delegate's input types
        source = this.removeCreateFromDelegateInput(typeAlias, delegateInfo, source);
        // remove delegate fields from nested mutation input types
        source = this.removeDelegateFieldsFromNestedMutationInput(typeAlias, delegateInfo, source);
        // fix delegate payload union type
        source = this.fixDelegatePayloadType(typeAlias, delegateInfo, source);
        structure.type = source;
        return structure;
    }
    fixDelegatePayloadType(typeAlias, delegateInfo, source) {
        // change the type of `$<DelegateModel>Payload` type of delegate model to a union of concrete types
        const typeName = typeAlias.getName();
        const payloadRecord = delegateInfo.find(([delegate]) => `$${delegate.name}Payload` === typeName);
        if (payloadRecord) {
            const discriminatorDecl = this.getDiscriminatorField(payloadRecord[0]);
            if (discriminatorDecl) {
                source = `${payloadRecord[1]
                    .map((concrete) => `($${concrete.name}Payload<ExtArgs> & { scalars: { ${discriminatorDecl.name}: '${concrete.name}' } })`)
                    .join(' | ')}`;
            }
        }
        return source;
    }
    removeCreateFromDelegateInput(typeAlias, delegateModels, source) {
        // remove create/connectOrCreate/upsert fields from delegate's input types because
        // delegate models cannot be created directly
        const typeName = typeAlias.getName();
        const delegateModelNames = delegateModels.map(([delegate]) => delegate.name);
        const delegateCreateUpdateInputRegex = new RegExp(`\\${delegateModelNames.join('|')}(Unchecked)?(Create|Update).*Input`);
        if (delegateCreateUpdateInputRegex.test(typeName)) {
            const toRemove = typeAlias
                .getDescendantsOfKind(ts_morph_1.SyntaxKind.PropertySignature)
                .filter((p) => ['create', 'connectOrCreate', 'upsert'].includes(p.getName()));
            toRemove.forEach((r) => {
                source = source.replace(r.getText(), '');
            });
        }
        return source;
    }
    removeDiscriminatorFromConcreteInput(typeAlias, delegateInfo, source) {
        // remove discriminator field from the create/update input of concrete models because
        // discriminator cannot be set directly
        const typeName = typeAlias.getName();
        const concreteModelNames = delegateInfo.map(([, concretes]) => concretes.map((c) => c.name)).flatMap((c) => c);
        const concreteCreateUpdateInputRegex = new RegExp(`(${concreteModelNames.join('|')})(Unchecked)?(Create|Update).*Input`);
        const match = typeName.match(concreteCreateUpdateInputRegex);
        if (match) {
            const modelName = match[1];
            const record = delegateInfo.find(([, concretes]) => concretes.some((c) => c.name === modelName));
            if (record) {
                // remove all discriminator fields recursively
                const delegateOfConcrete = record[0];
                const discriminators = this.getDiscriminatorFieldsRecursively(delegateOfConcrete);
                discriminators.forEach((discriminatorDecl) => {
                    const discriminatorNode = this.findNamedProperty(typeAlias, discriminatorDecl.name);
                    if (discriminatorNode) {
                        source = source.replace(discriminatorNode.getText(), '');
                    }
                });
            }
        }
        return source;
    }
    removeAuxFieldsFromTypeAlias(typeAlias, source) {
        // remove `delegate_aux_*` fields from the type alias
        const auxDecls = this.findAuxDecls(typeAlias);
        if (auxDecls.length > 0) {
            auxDecls.forEach((d) => {
                source = source.replace(d.getText(), '');
            });
        }
        return source;
    }
    removeDelegateFieldsFromNestedMutationInput(typeAlias, _delegateInfo, source) {
        const name = typeAlias.getName();
        // remove delegate model fields (and corresponding fk fields) from
        // create/update input types nested inside concrete models
        const regex = new RegExp(`(.+)(Create|Update)Without${(0, upper_case_first_1.upperCaseFirst)(runtime_1.DELEGATE_AUX_RELATION_PREFIX)}_(.+)Input`);
        const match = name.match(regex);
        if (!match) {
            return source;
        }
        const nameTuple = match[3]; // [modelName]_[relationFieldName]_[concreteModelName]
        const [modelName, relationFieldName, _] = nameTuple.split('_');
        const fieldDef = this.findNamedProperty(typeAlias, relationFieldName);
        if (fieldDef) {
            // remove relation field of delegate type, e.g., `asset`
            source = source.replace(fieldDef.getText(), '');
        }
        // remove fk fields related to the delegate type relation, e.g., `assetId`
        const relationModel = this.model.declarations.find((d) => (0, ast_1.isDataModel)(d) && d.name === modelName);
        if (!relationModel) {
            return source;
        }
        const relationField = relationModel.fields.find((f) => f.name === relationFieldName);
        if (!relationField) {
            return source;
        }
        const relAttr = (0, sdk_1.getAttribute)(relationField, '@relation');
        if (!relAttr) {
            return source;
        }
        const fieldsArg = (0, sdk_1.getAttributeArg)(relAttr, 'fields');
        let fkFields = [];
        if ((0, ast_1.isArrayExpr)(fieldsArg)) {
            fkFields = fieldsArg.items.map((e) => e.target.$refText);
        }
        fkFields.forEach((fkField) => {
            const fieldDef = this.findNamedProperty(typeAlias, fkField);
            if (fieldDef) {
                source = source.replace(fieldDef.getText(), '');
            }
        });
        return source;
    }
    findNamedProperty(typeAlias, name) {
        return typeAlias.getFirstDescendant((d) => d.isKind(ts_morph_1.SyntaxKind.PropertySignature) && d.getName() === name);
    }
    findAuxDecls(node) {
        return node
            .getDescendantsOfKind(ts_morph_1.SyntaxKind.PropertySignature)
            .filter((n) => n.getName().startsWith(runtime_1.DELEGATE_AUX_RELATION_PREFIX));
    }
    getDiscriminatorField(delegate) {
        var _a;
        const delegateAttr = (0, sdk_1.getAttribute)(delegate, '@@delegate');
        if (!delegateAttr) {
            return undefined;
        }
        const arg = (_a = delegateAttr.args[0]) === null || _a === void 0 ? void 0 : _a.value;
        return (0, ast_1.isReferenceExpr)(arg) ? arg.target.ref : undefined;
    }
    getDiscriminatorFieldsRecursively(delegate, result = []) {
        if ((0, sdk_1.isDelegateModel)(delegate)) {
            const discriminator = this.getDiscriminatorField(delegate);
            if (discriminator) {
                result.push(discriminator);
            }
            for (const superType of delegate.superTypes) {
                if (superType.ref) {
                    result.push(...this.getDiscriminatorFieldsRecursively(superType.ref, result));
                }
            }
        }
        return result;
    }
    saveSourceFile(sf) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.options.preserveTsFiles) {
                yield sf.save();
            }
        });
    }
    get generatePermissionChecker() {
        return this.options.generatePermissionChecker === true;
    }
}
exports.EnhancerGenerator = EnhancerGenerator;
//# sourceMappingURL=index.js.map