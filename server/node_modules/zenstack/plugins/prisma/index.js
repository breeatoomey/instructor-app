"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.trackPrismaSchemaError = exports.description = exports.name = void 0;
const sdk_1 = require("@zenstackhq/sdk");
const ast_1 = require("@zenstackhq/sdk/ast");
const prisma_1 = require("@zenstackhq/sdk/prisma");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const strip_color_1 = __importDefault(require("strip-color"));
const telemetry_1 = __importDefault(require("../../telemetry"));
const exec_utils_1 = require("../../utils/exec-utils");
const pkg_utils_1 = require("../../utils/pkg-utils");
const schema_generator_1 = require("./schema-generator");
exports.name = 'Prisma';
exports.description = 'Generating Prisma schema';
const run = (model, options, _dmmf, _globalOptions) => __awaiter(void 0, void 0, void 0, function* () {
    // deal with calculation of the default output location
    const output = options.output
        ? (0, sdk_1.resolvePath)(options.output, options)
        : getDefaultPrismaOutputFile(options.schemaPath);
    const warnings = yield new schema_generator_1.PrismaSchemaGenerator(model).generate(Object.assign(Object.assign({}, options), { output }));
    let prismaClientPath = '@prisma/client';
    if (options.generateClient !== false) {
        let generateCmd = `prisma generate --schema "${output}"`;
        if (typeof options.generateArgs === 'string') {
            generateCmd += ` ${options.generateArgs}`;
        }
        try {
            // run 'prisma generate'
            yield (0, exec_utils_1.execPackage)(generateCmd, { stdio: 'ignore' });
        }
        catch (_a) {
            yield trackPrismaSchemaError(output);
            try {
                // run 'prisma generate' again with output to the console
                yield (0, exec_utils_1.execPackage)(generateCmd);
            }
            catch (_b) {
                // noop
            }
            throw new sdk_1.PluginError(exports.name, `Failed to run "prisma generate"`);
        }
        // extract user-provided prisma client output path
        const generator = model.declarations.find((d) => (0, ast_1.isGeneratorDecl)(d) &&
            d.fields.some((f) => f.name === 'provider' && (0, sdk_1.getLiteral)(f.value) === 'prisma-client-js'));
        const clientOutputField = generator === null || generator === void 0 ? void 0 : generator.fields.find((f) => f.name === 'output');
        const clientOutput = (0, sdk_1.getLiteral)(clientOutputField === null || clientOutputField === void 0 ? void 0 : clientOutputField.value);
        if (clientOutput) {
            if (path_1.default.isAbsolute(clientOutput)) {
                prismaClientPath = clientOutput;
            }
            else {
                // first get absolute path based on prisma schema location
                const absPath = path_1.default.resolve(path_1.default.dirname(output), clientOutput);
                // then make it relative to the zmodel schema location
                prismaClientPath = path_1.default.relative(path_1.default.dirname(options.schemaPath), absPath);
            }
        }
    }
    // load the result DMMF
    const dmmf = yield (0, prisma_1.getDMMF)({
        datamodel: fs_1.default.readFileSync(output, 'utf-8'),
    });
    return { warnings, dmmf, prismaClientPath };
});
function getDefaultPrismaOutputFile(schemaPath) {
    var _a;
    // handle override from package.json
    const pkgJsonPath = (0, pkg_utils_1.findUp)(['package.json'], path_1.default.dirname(schemaPath));
    if (pkgJsonPath) {
        const pkgJson = JSON.parse(fs_1.default.readFileSync(pkgJsonPath, 'utf-8'));
        if (typeof ((_a = pkgJson === null || pkgJson === void 0 ? void 0 : pkgJson.zenstack) === null || _a === void 0 ? void 0 : _a.prisma) === 'string') {
            if (path_1.default.isAbsolute(pkgJson.zenstack.prisma)) {
                return pkgJson.zenstack.prisma;
            }
            else {
                // resolve relative to package.json
                return path_1.default.resolve(path_1.default.dirname(pkgJsonPath), pkgJson.zenstack.prisma);
            }
        }
    }
    return (0, sdk_1.resolvePath)('./prisma/schema.prisma', { schemaPath });
}
function trackPrismaSchemaError(schema) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            yield (0, prisma_1.getDMMF)({ datamodel: fs_1.default.readFileSync(schema, 'utf-8') });
        }
        catch (err) {
            if (err instanceof Error) {
                // eslint-disable-next-line @typescript-eslint/no-var-requires
                telemetry_1.default.track('prisma:error', { command: 'generate', message: (0, strip_color_1.default)(err.message) });
            }
        }
    });
}
exports.trackPrismaSchemaError = trackPrismaSchemaError;
exports.default = run;
//# sourceMappingURL=index.js.map