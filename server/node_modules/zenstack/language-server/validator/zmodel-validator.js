"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZModelValidator = exports.ZModelValidationRegistry = void 0;
const langium_1 = require("langium");
const attribute_validator_1 = __importDefault(require("./attribute-validator"));
const datamodel_validator_1 = __importDefault(require("./datamodel-validator"));
const datasource_validator_1 = __importDefault(require("./datasource-validator"));
const enum_validator_1 = __importDefault(require("./enum-validator"));
const expression_validator_1 = __importDefault(require("./expression-validator"));
const function_decl_validator_1 = __importDefault(require("./function-decl-validator"));
const function_invocation_validator_1 = __importDefault(require("./function-invocation-validator"));
const schema_validator_1 = __importDefault(require("./schema-validator"));
/**
 * Registry for validation checks.
 */
class ZModelValidationRegistry extends langium_1.ValidationRegistry {
    constructor(services) {
        super(services);
        const validator = services.validation.ZModelValidator;
        const checks = {
            Model: validator.checkModel,
            DataSource: validator.checkDataSource,
            DataModel: validator.checkDataModel,
            Enum: validator.checkEnum,
            Attribute: validator.checkAttribute,
            Expression: validator.checkExpression,
            InvocationExpr: validator.checkFunctionInvocation,
            FunctionDecl: validator.checkFunctionDecl,
        };
        this.register(checks, validator);
    }
}
exports.ZModelValidationRegistry = ZModelValidationRegistry;
/**
 * Implementation of custom validations.
 */
class ZModelValidator {
    constructor(services) {
        this.services = services;
    }
    shouldCheck(node) {
        let doc;
        let currNode = node;
        while (currNode) {
            if (currNode.$document) {
                doc = currNode.$document;
                break;
            }
            currNode = currNode.$container;
        }
        return (doc === null || doc === void 0 ? void 0 : doc.parseResult.lexerErrors.length) === 0 && (doc === null || doc === void 0 ? void 0 : doc.parseResult.parserErrors.length) === 0;
    }
    checkModel(node, accept) {
        this.shouldCheck(node) &&
            new schema_validator_1.default(this.services.shared.workspace.LangiumDocuments).validate(node, accept);
    }
    checkDataSource(node, accept) {
        this.shouldCheck(node) && new datasource_validator_1.default().validate(node, accept);
    }
    checkDataModel(node, accept) {
        this.shouldCheck(node) && new datamodel_validator_1.default().validate(node, accept);
    }
    checkEnum(node, accept) {
        this.shouldCheck(node) && new enum_validator_1.default().validate(node, accept);
    }
    checkAttribute(node, accept) {
        this.shouldCheck(node) && new attribute_validator_1.default().validate(node, accept);
    }
    checkExpression(node, accept) {
        this.shouldCheck(node) && new expression_validator_1.default().validate(node, accept);
    }
    checkFunctionInvocation(node, accept) {
        this.shouldCheck(node) && new function_invocation_validator_1.default().validate(node, accept);
    }
    checkFunctionDecl(node, accept) {
        this.shouldCheck(node) && new function_decl_validator_1.default().validate(node, accept);
    }
}
exports.ZModelValidator = ZModelValidator;
//# sourceMappingURL=zmodel-validator.js.map