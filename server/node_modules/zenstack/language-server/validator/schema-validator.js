"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ast_1 = require("@zenstackhq/language/ast");
const sdk_1 = require("@zenstackhq/sdk");
const ast_utils_1 = require("../../utils/ast-utils");
const constants_1 = require("../constants");
const utils_1 = require("./utils");
/**
 * Validates toplevel schema.
 */
class SchemaValidator {
    constructor(documents) {
        this.documents = documents;
    }
    validate(model, accept) {
        var _a, _b;
        this.validateImports(model, accept);
        (0, utils_1.validateDuplicatedDeclarations)(model, model.declarations, accept);
        const importedModels = (0, ast_utils_1.resolveTransitiveImports)(this.documents, model);
        const importedNames = new Set(importedModels.flatMap((m) => m.declarations.map((d) => d.name)));
        for (const declaration of model.declarations) {
            if (importedNames.has(declaration.name)) {
                accept('error', `A ${declaration.name} already exists in an imported module`, {
                    node: declaration,
                    property: 'name',
                });
            }
        }
        if (!((_a = model.$document) === null || _a === void 0 ? void 0 : _a.uri.path.endsWith(constants_1.STD_LIB_MODULE_NAME)) &&
            !((_b = model.$document) === null || _b === void 0 ? void 0 : _b.uri.path.endsWith(constants_1.PLUGIN_MODULE_NAME))) {
            this.validateDataSources(model, accept);
        }
        // at most one `@@auth` model
        const authModels = model.declarations.filter((d) => (0, ast_1.isDataModel)(d) && (0, sdk_1.hasAttribute)(d, '@@auth'));
        if (authModels.length > 1) {
            accept('error', 'Multiple `@@auth` models are not allowed', { node: authModels[1] });
        }
    }
    validateDataSources(model, accept) {
        const dataSources = (0, ast_utils_1.getAllDeclarationsIncludingImports)(this.documents, model).filter((d) => (0, ast_1.isDataSource)(d));
        if (dataSources.length > 1) {
            accept('error', 'Multiple datasource declarations are not allowed', { node: dataSources[1] });
        }
    }
    validateImports(model, accept) {
        model.imports.forEach((imp) => {
            const importedModel = (0, ast_utils_1.resolveImport)(this.documents, imp);
            const importPath = imp.path.endsWith('.zmodel') ? imp.path : `${imp.path}.zmodel`;
            if (!importedModel) {
                accept('error', `Cannot find model file ${importPath}`, { node: imp });
            }
        });
    }
}
exports.default = SchemaValidator;
//# sourceMappingURL=schema-validator.js.map