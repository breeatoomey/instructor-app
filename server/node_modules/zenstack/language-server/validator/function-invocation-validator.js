"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ast_1 = require("@zenstackhq/language/ast");
const sdk_1 = require("@zenstackhq/sdk");
const ts_pattern_1 = require("ts-pattern");
const utils_1 = require("./utils");
/**
 * InvocationExpr validation
 */
class FunctionInvocationValidator {
    validate(expr, accept) {
        var _a, _b, _c, _d;
        const funcDecl = expr.function.ref;
        if (!funcDecl) {
            accept('error', 'function cannot be resolved', { node: expr });
            return;
        }
        if (!this.validateArgs(funcDecl, expr.args, accept)) {
            return;
        }
        if ((0, sdk_1.isFromStdlib)(funcDecl)) {
            // validate standard library functions
            // find the containing attribute context for the invocation
            let curr = expr.$container;
            let containerAttribute;
            while (curr) {
                if ((0, ast_1.isDataModelAttribute)(curr) || (0, ast_1.isDataModelFieldAttribute)(curr)) {
                    containerAttribute = curr;
                    break;
                }
                curr = curr.$container;
            }
            // validate the context allowed for the function
            const exprContext = (0, ts_pattern_1.match)(containerAttribute === null || containerAttribute === void 0 ? void 0 : containerAttribute.decl.$refText)
                .with('@default', () => sdk_1.ExpressionContext.DefaultValue)
                .with(ts_pattern_1.P.union('@@allow', '@@deny', '@allow', '@deny'), () => sdk_1.ExpressionContext.AccessPolicy)
                .with('@@validate', () => sdk_1.ExpressionContext.ValidationRule)
                .with('@@index', () => sdk_1.ExpressionContext.Index)
                .otherwise(() => undefined);
            // get the context allowed for the function
            const funcAllowedContext = (0, sdk_1.getFunctionExpressionContext)(funcDecl);
            if (exprContext && !funcAllowedContext.includes(exprContext)) {
                accept('error', `function "${funcDecl.name}" is not allowed in the current context: ${exprContext}`, {
                    node: expr,
                });
                return;
            }
            if (funcAllowedContext.includes(sdk_1.ExpressionContext.AccessPolicy) ||
                funcAllowedContext.includes(sdk_1.ExpressionContext.ValidationRule)) {
                // filter operation functions validation
                // first argument must refer to a model field
                const firstArg = (_b = (_a = expr.args) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.value;
                if (firstArg) {
                    if (!(0, sdk_1.getDataModelFieldReference)(firstArg)) {
                        accept('error', 'first argument must be a field reference', { node: firstArg });
                    }
                }
                // second argument must be a literal or array of literal
                const secondArg = (_d = (_c = expr.args) === null || _c === void 0 ? void 0 : _c[1]) === null || _d === void 0 ? void 0 : _d.value;
                if (secondArg &&
                    // literal
                    !(0, ast_1.isLiteralExpr)(secondArg) &&
                    // enum field
                    !(0, sdk_1.isEnumFieldReference)(secondArg) &&
                    // array of literal/enum
                    !((0, ast_1.isArrayExpr)(secondArg) &&
                        secondArg.items.every((item) => (0, ast_1.isLiteralExpr)(item) || (0, sdk_1.isEnumFieldReference)(item)))) {
                    accept('error', 'second argument must be a literal, an enum, or an array of them', {
                        node: secondArg,
                    });
                }
            }
        }
    }
    validateArgs(funcDecl, args, accept) {
        let success = true;
        for (let i = 0; i < funcDecl.params.length; i++) {
            const param = funcDecl.params[i];
            const arg = args[i];
            if (!arg) {
                if (!param.optional) {
                    accept('error', `missing argument for parameter "${param.name}"`, { node: funcDecl });
                    success = false;
                }
            }
            else {
                if (!this.validateInvocationArg(arg, param, accept)) {
                    success = false;
                }
            }
        }
        // TODO: do we need to complain for extra arguments?
        return success;
    }
    validateInvocationArg(arg, param, accept) {
        var _a;
        const argResolvedType = (_a = arg === null || arg === void 0 ? void 0 : arg.value) === null || _a === void 0 ? void 0 : _a.$resolvedType;
        if (!argResolvedType) {
            accept('error', 'argument type cannot be resolved', { node: arg });
            return false;
        }
        const dstType = param.type.type;
        if (!dstType) {
            accept('error', 'parameter type cannot be resolved', { node: param });
            return false;
        }
        const dstIsArray = param.type.array;
        const dstRef = param.type.reference;
        if (dstType === 'Any' && !dstIsArray) {
            // scalar 'any' can be assigned with anything
            return true;
        }
        if (typeof argResolvedType.decl === 'string') {
            // scalar type
            if (!(0, utils_1.typeAssignable)(dstType, argResolvedType.decl, arg.value) || dstIsArray !== argResolvedType.array) {
                accept('error', `argument is not assignable to parameter`, {
                    node: arg,
                });
                return false;
            }
        }
        else {
            // enum or model type
            if (((dstRef === null || dstRef === void 0 ? void 0 : dstRef.ref) !== argResolvedType.decl && dstType !== 'Any') || dstIsArray !== argResolvedType.array) {
                accept('error', `argument is not assignable to parameter`, {
                    node: arg,
                });
                return false;
            }
        }
        return true;
    }
}
exports.default = FunctionInvocationValidator;
//# sourceMappingURL=function-invocation-validator.js.map