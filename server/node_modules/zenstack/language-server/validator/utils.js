"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.assignableToAttributeParam = exports.mapBuiltinTypeToExpressionType = exports.typeAssignable = exports.getStringLiteral = exports.validateDuplicatedDeclarations = void 0;
const ast_1 = require("@zenstackhq/language/ast");
const sdk_1 = require("@zenstackhq/sdk");
/**
 * Checks if the given declarations have duplicated names
 */
function validateDuplicatedDeclarations(container, decls, accept) {
    const groupByName = decls.reduce((group, decl) => {
        var _a;
        group[decl.name] = (_a = group[decl.name]) !== null && _a !== void 0 ? _a : [];
        group[decl.name].push(decl);
        return group;
    }, {});
    for (const [name, decls] of Object.entries(groupByName)) {
        if (decls.length > 1) {
            let errorField = decls[1];
            if ((0, ast_1.isDataModelField)(decls[0])) {
                const nonInheritedFields = decls.filter((x) => !((0, ast_1.isDataModelField)(x) && x.$container !== container));
                if (nonInheritedFields.length > 0) {
                    errorField = nonInheritedFields.slice(-1)[0];
                }
            }
            accept('error', `Duplicated declaration name "${name}"`, {
                node: errorField,
            });
        }
    }
}
exports.validateDuplicatedDeclarations = validateDuplicatedDeclarations;
/**
 * Try getting string value from a potential string literal expression
 */
function getStringLiteral(node) {
    return (0, ast_1.isStringLiteral)(node) ? node.value : undefined;
}
exports.getStringLiteral = getStringLiteral;
const isoDateTimeRegex = /^\d{4}(-\d\d(-\d\d(T\d\d:\d\d(:\d\d)?(\.\d+)?(([+-]\d\d:\d\d)|Z)?)?)?)?$/i;
/**
 * Determines if the given sourceType is assignable to a destination of destType
 */
function typeAssignable(destType, sourceType, sourceExpr) {
    // implicit conversion from ISO datetime string to datetime
    if (destType === 'DateTime' && sourceType === 'String' && sourceExpr && (0, ast_1.isStringLiteral)(sourceExpr)) {
        const literal = getStringLiteral(sourceExpr);
        if (literal && isoDateTimeRegex.test(literal)) {
            // implicitly convert to DateTime
            sourceType = 'DateTime';
        }
    }
    switch (destType) {
        case 'Any':
            return true;
        case 'Float':
            return sourceType === 'Any' || sourceType === 'Int' || sourceType === 'Float';
        default:
            return sourceType === 'Any' || sourceType === destType;
    }
}
exports.typeAssignable = typeAssignable;
/**
 * Maps a ZModel builtin type to expression type
 */
function mapBuiltinTypeToExpressionType(type) {
    switch (type) {
        case 'Any':
        case 'Boolean':
        case 'String':
        case 'DateTime':
        case 'Int':
        case 'Float':
        case 'Null':
            return type;
        case 'BigInt':
            return 'Int';
        case 'Decimal':
            return 'Float';
        case 'Json':
        case 'Bytes':
            return 'Any';
        case 'Object':
            return 'Object';
        case 'Unsupported':
            return 'Unsupported';
    }
}
exports.mapBuiltinTypeToExpressionType = mapBuiltinTypeToExpressionType;
/**
 * Determines if the given attribute argument is assignable to the given attribute parameter
 */
function assignableToAttributeParam(arg, param, attr) {
    var _a, _b, _c, _d;
    const argResolvedType = arg.$resolvedType;
    if (!argResolvedType) {
        return false;
    }
    let dstType = param.type.type;
    let dstIsArray = param.type.array;
    const dstRef = param.type.reference;
    if (dstType === 'Any' && !dstIsArray) {
        return true;
    }
    // destination is field reference or transitive field reference, check if
    // argument is reference or array or reference
    if (dstType === 'FieldReference' || dstType === 'TransitiveFieldReference') {
        if (dstIsArray) {
            return ((0, ast_1.isArrayExpr)(arg.value) &&
                !arg.value.items.find((item) => !(0, ast_1.isReferenceExpr)(item) || !(0, ast_1.isDataModelField)(item.target.ref)));
        }
        else {
            return (0, ast_1.isReferenceExpr)(arg.value) && (0, ast_1.isDataModelField)(arg.value.target.ref);
        }
    }
    if ((0, ast_1.isEnum)(argResolvedType.decl)) {
        // enum type
        let attrArgDeclType = dstRef === null || dstRef === void 0 ? void 0 : dstRef.ref;
        if (dstType === 'ContextType' && (0, ast_1.isDataModelField)(attr.$container) && ((_b = (_a = attr.$container) === null || _a === void 0 ? void 0 : _a.type) === null || _b === void 0 ? void 0 : _b.reference)) {
            // attribute parameter type is ContextType, need to infer type from
            // the attribute's container
            attrArgDeclType = (0, sdk_1.resolved)(attr.$container.type.reference);
            dstIsArray = attr.$container.type.array;
        }
        return attrArgDeclType === argResolvedType.decl && dstIsArray === argResolvedType.array;
    }
    else if (dstType) {
        // scalar type
        if (typeof (argResolvedType === null || argResolvedType === void 0 ? void 0 : argResolvedType.decl) !== 'string') {
            // destination type is not a reference, so argument type must be a plain expression
            return false;
        }
        if (dstType === 'ContextType') {
            // attribute parameter type is ContextType, need to infer type from
            // the attribute's container
            if ((0, ast_1.isDataModelField)(attr.$container)) {
                if (!((_d = (_c = attr.$container) === null || _c === void 0 ? void 0 : _c.type) === null || _d === void 0 ? void 0 : _d.type)) {
                    return false;
                }
                dstType = mapBuiltinTypeToExpressionType(attr.$container.type.type);
                dstIsArray = attr.$container.type.array;
            }
            else {
                dstType = 'Any';
            }
        }
        return typeAssignable(dstType, argResolvedType.decl, arg.value) && dstIsArray === argResolvedType.array;
    }
    else {
        // reference type
        return ((dstRef === null || dstRef === void 0 ? void 0 : dstRef.ref) === argResolvedType.decl || dstType === 'Any') && dstIsArray === argResolvedType.array;
    }
}
exports.assignableToAttributeParam = assignableToAttributeParam;
//# sourceMappingURL=utils.js.map