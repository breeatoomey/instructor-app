"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZModelSemanticTokenProvider = void 0;
const ast_1 = require("@zenstackhq/language/ast");
const langium_1 = require("langium");
const vscode_languageserver_1 = require("vscode-languageserver");
class ZModelSemanticTokenProvider extends langium_1.AbstractSemanticTokenProvider {
    highlightElement(node, acceptor) {
        if ((0, ast_1.isDataModel)(node)) {
            acceptor({
                node,
                property: 'name',
                type: vscode_languageserver_1.SemanticTokenTypes.type,
            });
            acceptor({
                node,
                property: 'superTypes',
                type: vscode_languageserver_1.SemanticTokenTypes.type,
            });
        }
        else if ((0, ast_1.isDataSource)(node) || (0, ast_1.isGeneratorDecl)(node) || (0, ast_1.isPlugin)(node) || (0, ast_1.isEnum)(node)) {
            acceptor({
                node,
                property: 'name',
                type: vscode_languageserver_1.SemanticTokenTypes.type,
            });
        }
        else if ((0, ast_1.isDataModelField)(node) ||
            (0, ast_1.isConfigField)(node) ||
            (0, ast_1.isAttributeArg)(node) ||
            (0, ast_1.isPluginField)(node) ||
            (0, ast_1.isEnumField)(node)) {
            acceptor({
                node,
                property: 'name',
                type: vscode_languageserver_1.SemanticTokenTypes.variable,
            });
        }
        else if ((0, ast_1.isDataModelFieldType)(node)) {
            if (node.type) {
                acceptor({
                    node,
                    property: 'type',
                    type: vscode_languageserver_1.SemanticTokenTypes.type,
                });
            }
            else {
                acceptor({
                    node,
                    property: 'reference',
                    type: vscode_languageserver_1.SemanticTokenTypes.macro,
                });
            }
        }
        else if ((0, ast_1.isDataModelAttribute)(node) || (0, ast_1.isDataModelFieldAttribute)(node) || (0, ast_1.isInternalAttribute)(node)) {
            acceptor({
                node,
                property: 'decl',
                type: vscode_languageserver_1.SemanticTokenTypes.function,
            });
        }
        else if ((0, ast_1.isInvocationExpr)(node)) {
            acceptor({
                node,
                property: 'function',
                type: vscode_languageserver_1.SemanticTokenTypes.function,
            });
        }
        else if ((0, ast_1.isFunctionDecl)(node) || (0, ast_1.isAttribute)(node)) {
            acceptor({
                node,
                property: 'name',
                type: vscode_languageserver_1.SemanticTokenTypes.function,
            });
        }
        else if ((0, ast_1.isReferenceExpr)(node)) {
            acceptor({
                node,
                property: 'target',
                type: vscode_languageserver_1.SemanticTokenTypes.variable,
            });
        }
        else if ((0, ast_1.isMemberAccessExpr)(node)) {
            acceptor({
                node,
                property: 'member',
                type: vscode_languageserver_1.SemanticTokenTypes.property,
            });
        }
    }
}
exports.ZModelSemanticTokenProvider = ZModelSemanticTokenProvider;
//# sourceMappingURL=zmodel-semantic.js.map