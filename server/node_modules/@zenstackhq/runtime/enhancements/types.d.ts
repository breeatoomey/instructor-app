import { z } from 'zod';
import { FIELD_LEVEL_OVERRIDE_READ_GUARD_PREFIX, FIELD_LEVEL_OVERRIDE_UPDATE_GUARD_PREFIX, FIELD_LEVEL_READ_CHECKER_PREFIX, FIELD_LEVEL_READ_CHECKER_SELECTOR, FIELD_LEVEL_UPDATE_GUARD_PREFIX, HAS_FIELD_LEVEL_POLICY_FLAG, PRE_UPDATE_VALUE_SELECTOR } from '../constants';
import type { CheckerContext, CrudContract, PolicyCrudKind, PolicyOperationKind, QueryContext } from '../types';
/**
 * Common options for PrismaClient enhancements
 */
export interface CommonEnhancementOptions {
    /**
     * Path for loading CLI-generated code
     */
    loadPath?: string;
    /**
     * The `Prisma` module generated together with `PrismaClient`. You only need to
     * pass it when you specified a custom `PrismaClient` output path. The module can
     * be loaded like: `import { Prisma } from '<your PrismaClient output path>';`.
     */
    prismaModule?: any;
}
/**
 * Function for getting policy guard with a given context
 */
export type PolicyFunc = (context: QueryContext, db: CrudContract) => object;
/**
 * Function for checking if an operation is possibly allowed.
 */
export type CheckerFunc = (context: CheckerContext) => CheckerConstraint;
/**
 * Supported checker constraint checking value types.
 */
export type ConstraintValueTypes = 'boolean' | 'number' | 'string';
/**
 * Free variable constraint
 */
export type VariableConstraint = {
    kind: 'variable';
    name: string;
    type: ConstraintValueTypes;
};
/**
 * Constant value constraint
 */
export type ValueConstraint = {
    kind: 'value';
    value: number | boolean | string;
    type: ConstraintValueTypes;
};
/**
 * Terms for comparison constraints
 */
export type ComparisonTerm = VariableConstraint | ValueConstraint;
/**
 * Comparison constraint
 */
export type ComparisonConstraint = {
    kind: 'eq' | 'ne' | 'gt' | 'gte' | 'lt' | 'lte';
    left: ComparisonTerm;
    right: ComparisonTerm;
};
/**
 * Logical constraint
 */
export type LogicalConstraint = {
    kind: 'and' | 'or' | 'not';
    children: CheckerConstraint[];
};
/**
 * Operation allowability checking constraint
 */
export type CheckerConstraint = ValueConstraint | VariableConstraint | ComparisonConstraint | LogicalConstraint;
/**
 * Function for getting policy guard with a given context
 */
export type InputCheckFunc = (args: any, context: QueryContext) => boolean;
/**
 * Function for getting policy guard with a given context
 */
export type ReadFieldCheckFunc = (input: any, context: QueryContext) => boolean;
/**
 * Policy definition
 */
export type PolicyDef = {
    guard: Record<string, Partial<Record<PolicyOperationKind, PolicyFunc | boolean>> & Partial<Record<`${PolicyOperationKind}_input`, InputCheckFunc | boolean>> & Record<`${typeof FIELD_LEVEL_READ_CHECKER_PREFIX}${string}`, ReadFieldCheckFunc> & Record<`${typeof FIELD_LEVEL_OVERRIDE_READ_GUARD_PREFIX}${string}` | `${typeof FIELD_LEVEL_UPDATE_GUARD_PREFIX}${string}` | `${typeof FIELD_LEVEL_OVERRIDE_UPDATE_GUARD_PREFIX}${string}`, PolicyFunc> & {
        [PRE_UPDATE_VALUE_SELECTOR]?: object;
        [FIELD_LEVEL_READ_CHECKER_SELECTOR]?: object;
        [HAS_FIELD_LEVEL_POLICY_FLAG]?: boolean;
    }>;
    checker?: Record<string, Record<PolicyCrudKind, CheckerFunc | boolean>>;
    validation: Record<string, {
        hasValidation: boolean;
    }>;
    authSelector?: object;
};
/**
 * Zod schemas for validation
 */
export type ZodSchemas = {
    models: Record<string, z.ZodSchema>;
    input?: Record<string, Record<string, z.ZodSchema>>;
};
