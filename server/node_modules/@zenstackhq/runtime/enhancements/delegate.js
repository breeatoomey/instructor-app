"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DelegateProxyHandler = exports.withDelegate = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
const deepcopy_1 = __importDefault(require("deepcopy"));
const deepmerge_1 = __importDefault(require("deepmerge"));
const lower_case_first_1 = require("lower-case-first");
const constants_1 = require("../constants");
const cross_1 = require("../cross");
const logger_1 = require("./logger");
const proxy_1 = require("./proxy");
const query_utils_1 = require("./query-utils");
const utils_1 = require("./utils");
function withDelegate(prisma, options) {
    return (0, proxy_1.makeProxy)(prisma, options.modelMeta, (_prisma, model) => new DelegateProxyHandler(_prisma, model, options), 'delegate');
}
exports.withDelegate = withDelegate;
class DelegateProxyHandler extends proxy_1.DefaultPrismaProxyHandler {
    constructor(prisma, model, options) {
        super(prisma, model, options);
        this.logger = new logger_1.Logger(prisma);
        this.queryUtils = new query_utils_1.QueryUtils(prisma, this.options);
    }
    // #region find
    findFirst(args) {
        return this.doFind(this.prisma, this.model, 'findFirst', args);
    }
    findFirstOrThrow(args) {
        return this.doFind(this.prisma, this.model, 'findFirstOrThrow', args);
    }
    findUnique(args) {
        return this.doFind(this.prisma, this.model, 'findUnique', args);
    }
    findUniqueOrThrow(args) {
        return this.doFind(this.prisma, this.model, 'findUniqueOrThrow', args);
    }
    findMany(args) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.doFind(this.prisma, this.model, 'findMany', args);
        });
    }
    doFind(db, model, method, args) {
        const _superIndex = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.involvesDelegateModel(model)) {
                return _superIndex(method).call(this, args);
            }
            args = args ? (0, deepcopy_1.default)(args) : {};
            this.injectWhereHierarchy(model, args === null || args === void 0 ? void 0 : args.where);
            this.injectSelectIncludeHierarchy(model, args);
            if (args.orderBy) {
                // `orderBy` may contain fields from base types
                args.orderBy = this.buildWhereHierarchy(this.model, args.orderBy);
            }
            if (this.options.logPrismaQuery) {
                this.logger.info(`[delegate] \`${method}\` ${this.getModelName(model)}: ${(0, utils_1.formatObject)(args)}`);
            }
            const entity = yield db[model][method](args);
            if (Array.isArray(entity)) {
                return entity.map((item) => this.assembleHierarchy(model, item));
            }
            else {
                return this.assembleHierarchy(model, entity);
            }
        });
    }
    injectWhereHierarchy(model, where) {
        if (!where || typeof where !== 'object') {
            return;
        }
        Object.entries(where).forEach(([field, value]) => {
            if (['AND', 'OR', 'NOT'].includes(field)) {
                // recurse into logical group
                (0, cross_1.enumerate)(value).forEach((item) => this.injectWhereHierarchy(model, item));
                return;
            }
            const fieldInfo = (0, cross_1.resolveField)(this.options.modelMeta, model, field);
            if (!(fieldInfo === null || fieldInfo === void 0 ? void 0 : fieldInfo.inheritedFrom)) {
                return;
            }
            let base = this.getBaseModel(model);
            let target = where;
            while (base) {
                const baseRelationName = this.makeAuxRelationName(base);
                // prepare base layer where
                let thisLayer;
                if (target[baseRelationName]) {
                    thisLayer = target[baseRelationName];
                }
                else {
                    thisLayer = target[baseRelationName] = {};
                }
                if (base.name === fieldInfo.inheritedFrom) {
                    thisLayer[field] = value;
                    delete where[field];
                    break;
                }
                else {
                    target = thisLayer;
                    base = this.getBaseModel(base.name);
                }
            }
        });
    }
    buildWhereHierarchy(model, where) {
        if (!where) {
            return undefined;
        }
        where = (0, deepcopy_1.default)(where);
        Object.entries(where).forEach(([field, value]) => {
            const fieldInfo = (0, cross_1.resolveField)(this.options.modelMeta, model, field);
            if (!(fieldInfo === null || fieldInfo === void 0 ? void 0 : fieldInfo.inheritedFrom)) {
                return;
            }
            let base = this.getBaseModel(model);
            let target = where;
            while (base) {
                const baseRelationName = this.makeAuxRelationName(base);
                // prepare base layer where
                let thisLayer;
                if (target[baseRelationName]) {
                    thisLayer = target[baseRelationName];
                }
                else {
                    thisLayer = target[baseRelationName] = {};
                }
                if (base.name === fieldInfo.inheritedFrom) {
                    thisLayer[field] = value;
                    delete where[field];
                    break;
                }
                else {
                    target = thisLayer;
                    base = this.getBaseModel(base.name);
                }
            }
        });
        return where;
    }
    injectSelectIncludeHierarchy(model, args) {
        if (!args || typeof args !== 'object') {
            return;
        }
        for (const kind of ['select', 'include']) {
            if (args[kind] && typeof args[kind] === 'object') {
                for (const [field, value] of Object.entries(args[kind])) {
                    const fieldInfo = (0, cross_1.resolveField)(this.options.modelMeta, model, field);
                    if (fieldInfo && value !== undefined) {
                        if (value === null || value === void 0 ? void 0 : value.orderBy) {
                            // `orderBy` may contain fields from base types
                            value.orderBy = this.buildWhereHierarchy(fieldInfo.type, value.orderBy);
                        }
                        if (this.injectBaseFieldSelect(model, field, value, args, kind)) {
                            delete args[kind][field];
                        }
                        else {
                            if (fieldInfo && this.isDelegateOrDescendantOfDelegate(fieldInfo.type)) {
                                let nextValue = value;
                                if (nextValue === true) {
                                    // make sure the payload is an object
                                    args[kind][field] = nextValue = {};
                                }
                                this.injectSelectIncludeHierarchy(fieldInfo.type, nextValue);
                            }
                        }
                    }
                }
            }
        }
        if (!args.select) {
            // include base models upwards
            this.injectBaseIncludeRecursively(model, args);
            // include sub models downwards
            this.injectConcreteIncludeRecursively(model, args);
        }
    }
    buildSelectIncludeHierarchy(model, args) {
        args = (0, deepcopy_1.default)(args);
        const selectInclude = this.extractSelectInclude(args) || {};
        if (selectInclude.select && typeof selectInclude.select === 'object') {
            Object.entries(selectInclude.select).forEach(([field, value]) => {
                if (value) {
                    if (this.injectBaseFieldSelect(model, field, value, selectInclude, 'select')) {
                        delete selectInclude.select[field];
                    }
                }
            });
        }
        else if (selectInclude.include && typeof selectInclude.include === 'object') {
            Object.entries(selectInclude.include).forEach(([field, value]) => {
                if (value) {
                    if (this.injectBaseFieldSelect(model, field, value, selectInclude, 'include')) {
                        delete selectInclude.include[field];
                    }
                }
            });
        }
        if (!selectInclude.select) {
            this.injectBaseIncludeRecursively(model, selectInclude);
            this.injectConcreteIncludeRecursively(model, selectInclude);
        }
        return selectInclude;
    }
    injectBaseFieldSelect(model, field, value, selectInclude, context) {
        const fieldInfo = (0, cross_1.resolveField)(this.options.modelMeta, model, field);
        if (!(fieldInfo === null || fieldInfo === void 0 ? void 0 : fieldInfo.inheritedFrom)) {
            return false;
        }
        let base = this.getBaseModel(model);
        let target = selectInclude;
        while (base) {
            const baseRelationName = this.makeAuxRelationName(base);
            // prepare base layer select/include
            // let selectOrInclude = 'select';
            let thisLayer;
            if (target.include) {
                // selectOrInclude = 'include';
                thisLayer = target.include;
            }
            else if (target.select) {
                // selectOrInclude = 'select';
                thisLayer = target.select;
            }
            else {
                // selectInclude = 'include';
                thisLayer = target.select = {};
            }
            if (base.name === fieldInfo.inheritedFrom) {
                if (!thisLayer[baseRelationName]) {
                    thisLayer[baseRelationName] = { [context]: {} };
                }
                thisLayer[baseRelationName][context][field] = value;
                break;
            }
            else {
                if (!thisLayer[baseRelationName]) {
                    thisLayer[baseRelationName] = { select: {} };
                }
                target = thisLayer[baseRelationName];
                base = this.getBaseModel(base.name);
            }
        }
        return true;
    }
    injectBaseIncludeRecursively(model, selectInclude) {
        const base = this.getBaseModel(model);
        if (!base) {
            return;
        }
        const baseRelationName = this.makeAuxRelationName(base);
        if (selectInclude.select) {
            selectInclude.include = Object.assign({ [baseRelationName]: {} }, selectInclude.select);
            delete selectInclude.select;
        }
        else {
            selectInclude.include = Object.assign({ [baseRelationName]: {} }, selectInclude.include);
        }
        this.injectBaseIncludeRecursively(base.name, selectInclude.include[baseRelationName]);
    }
    injectConcreteIncludeRecursively(model, selectInclude) {
        const modelInfo = (0, cross_1.getModelInfo)(this.options.modelMeta, model);
        if (!modelInfo) {
            return;
        }
        // get sub models of this model
        const subModels = Object.values(this.options.modelMeta.models).filter((m) => { var _a; return (_a = m.baseTypes) === null || _a === void 0 ? void 0 : _a.includes(modelInfo.name); });
        for (const subModel of subModels) {
            // include sub model relation field
            const subRelationName = this.makeAuxRelationName(subModel);
            if (selectInclude.select) {
                selectInclude.include = Object.assign({ [subRelationName]: {} }, selectInclude.select);
                delete selectInclude.select;
            }
            else {
                selectInclude.include = Object.assign({ [subRelationName]: {} }, selectInclude.include);
            }
            this.injectConcreteIncludeRecursively(subModel.name, selectInclude.include[subRelationName]);
        }
    }
    // #endregion
    // #region create
    create(args) {
        const _super = Object.create(null, {
            create: { get: () => super.create }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (!args) {
                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, 'query argument is required');
            }
            if (!args.data) {
                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, 'data field is required in query argument');
            }
            if ((0, cross_1.isDelegateModel)(this.options.modelMeta, this.model)) {
                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, `Model "${this.model}" is a delegate and cannot be created directly`);
            }
            if (!this.involvesDelegateModel(this.model)) {
                return _super.create.call(this, args);
            }
            return this.doCreate(this.prisma, this.model, args);
        });
    }
    createMany(args) {
        if (!args) {
            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, 'query argument is required');
        }
        if (!args.data) {
            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, 'data field is required in query argument');
        }
        if (!this.involvesDelegateModel(this.model)) {
            return super.createMany(args);
        }
        if (this.isDelegateOrDescendantOfDelegate(this.model) && args.skipDuplicates) {
            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, '`createMany` with `skipDuplicates` set to true is not supported for delegated models');
        }
        // note that we can't call `createMany` directly because it doesn't support
        // nested created, which is needed for creating base entities
        return this.queryUtils.transaction(this.prisma, (tx) => __awaiter(this, void 0, void 0, function* () {
            const r = yield Promise.all((0, cross_1.enumerate)(args.data).map((item) => __awaiter(this, void 0, void 0, function* () {
                return this.doCreate(tx, this.model, { data: item });
            })));
            // filter out undefined value (due to skipping duplicates)
            return { count: r.filter((item) => !!item).length };
        }));
    }
    doCreate(db, model, args) {
        return __awaiter(this, void 0, void 0, function* () {
            args = (0, deepcopy_1.default)(args);
            yield this.injectCreateHierarchy(model, args);
            this.injectSelectIncludeHierarchy(model, args);
            if (this.options.logPrismaQuery) {
                this.logger.info(`[delegate] \`create\` ${this.getModelName(model)}: ${(0, utils_1.formatObject)(args)}`);
            }
            const result = yield db[model].create(args);
            return this.assembleHierarchy(model, result);
        });
    }
    injectCreateHierarchy(model, args) {
        return __awaiter(this, void 0, void 0, function* () {
            const visitor = new cross_1.NestedWriteVisitor(this.options.modelMeta, {
                create: (model, args, _context) => {
                    this.doProcessCreatePayload(model, args);
                },
                createMany: (model, args, _context) => {
                    if (args.skipDuplicates) {
                        throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, '`createMany` with `skipDuplicates` set to true is not supported for delegated models');
                    }
                    for (const item of (0, cross_1.enumerate)(args === null || args === void 0 ? void 0 : args.data)) {
                        this.doProcessCreatePayload(model, item);
                    }
                },
            });
            yield visitor.visit(model, 'create', args);
        });
    }
    doProcessCreatePayload(model, args) {
        if (!args) {
            return;
        }
        this.ensureBaseCreateHierarchy(model, args);
        for (const [field, value] of Object.entries(args)) {
            const fieldInfo = (0, cross_1.resolveField)(this.options.modelMeta, model, field);
            if (fieldInfo === null || fieldInfo === void 0 ? void 0 : fieldInfo.inheritedFrom) {
                this.injectBaseFieldData(model, fieldInfo, value, args, 'create');
                delete args[field];
            }
        }
    }
    // ensure the full nested "create" structure is created for base types
    ensureBaseCreateHierarchy(model, result) {
        let curr = result;
        let base = this.getBaseModel(model);
        let sub = this.getModelInfo(model);
        while (base) {
            const baseRelationName = this.makeAuxRelationName(base);
            if (!curr[baseRelationName]) {
                curr[baseRelationName] = {};
            }
            if (!curr[baseRelationName].create) {
                curr[baseRelationName].create = {};
                if (base.discriminator) {
                    // set discriminator field
                    curr[baseRelationName].create[base.discriminator] = sub.name;
                }
            }
            curr = curr[baseRelationName].create;
            sub = base;
            base = this.getBaseModel(base.name);
        }
    }
    // inject field data that belongs to base type into proper nesting structure
    injectBaseFieldData(model, fieldInfo, value, args, mode) {
        let base = this.getBaseModel(model);
        let curr = args;
        while (base) {
            if (base.discriminator === fieldInfo.name) {
                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, `fields "${fieldInfo.name}" is a discriminator and cannot be set directly`);
            }
            const baseRelationName = this.makeAuxRelationName(base);
            if (!curr[baseRelationName]) {
                curr[baseRelationName] = {};
            }
            if (!curr[baseRelationName][mode]) {
                curr[baseRelationName][mode] = {};
            }
            curr = curr[baseRelationName][mode];
            if (fieldInfo.inheritedFrom === base.name) {
                curr[fieldInfo.name] = value;
                break;
            }
            base = this.getBaseModel(base.name);
        }
    }
    // #endregion
    // #region update
    update(args) {
        if (!args) {
            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, 'query argument is required');
        }
        if (!args.data) {
            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, 'data field is required in query argument');
        }
        if (!this.involvesDelegateModel(this.model)) {
            return super.update(args);
        }
        return this.queryUtils.transaction(this.prisma, (tx) => this.doUpdate(tx, this.model, args));
    }
    updateMany(args) {
        const _super = Object.create(null, {
            updateMany: { get: () => super.updateMany }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (!args) {
                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, 'query argument is required');
            }
            if (!args.data) {
                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, 'data field is required in query argument');
            }
            if (!this.involvesDelegateModel(this.model)) {
                return _super.updateMany.call(this, args);
            }
            const simpleUpdateMany = Object.keys(args.data).every((key) => {
                // check if the `data` clause involves base fields
                const fieldInfo = (0, cross_1.resolveField)(this.options.modelMeta, this.model, key);
                return !(fieldInfo === null || fieldInfo === void 0 ? void 0 : fieldInfo.inheritedFrom);
            });
            return this.queryUtils.transaction(this.prisma, (tx) => this.doUpdateMany(tx, this.model, args, simpleUpdateMany));
        });
    }
    upsert(args) {
        const _super = Object.create(null, {
            upsert: { get: () => super.upsert }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (!args) {
                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, 'query argument is required');
            }
            if (!args.where) {
                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, 'where field is required in query argument');
            }
            if ((0, cross_1.isDelegateModel)(this.options.modelMeta, this.model)) {
                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, `Model "${this.model}" is a delegate and doesn't support upsert`);
            }
            if (!this.involvesDelegateModel(this.model)) {
                return _super.upsert.call(this, args);
            }
            args = (0, deepcopy_1.default)(args);
            this.injectWhereHierarchy(this.model, args === null || args === void 0 ? void 0 : args.where);
            this.injectSelectIncludeHierarchy(this.model, args);
            if (args.create) {
                this.doProcessCreatePayload(this.model, args.create);
            }
            if (args.update) {
                this.doProcessUpdatePayload(this.model, args.update);
            }
            if (this.options.logPrismaQuery) {
                this.logger.info(`[delegate] \`upsert\` ${this.getModelName(this.model)}: ${(0, utils_1.formatObject)(args)}`);
            }
            const result = yield this.prisma[this.model].upsert(args);
            return this.assembleHierarchy(this.model, result);
        });
    }
    doUpdate(db, model, args) {
        return __awaiter(this, void 0, void 0, function* () {
            args = (0, deepcopy_1.default)(args);
            yield this.injectUpdateHierarchy(db, model, args);
            this.injectSelectIncludeHierarchy(model, args);
            if (this.options.logPrismaQuery) {
                this.logger.info(`[delegate] \`update\` ${this.getModelName(model)}: ${(0, utils_1.formatObject)(args)}`);
            }
            const result = yield db[model].update(args);
            return this.assembleHierarchy(model, result);
        });
    }
    doUpdateMany(db, model, args, simpleUpdateMany) {
        return __awaiter(this, void 0, void 0, function* () {
            if (simpleUpdateMany) {
                // do a direct `updateMany`
                args = (0, deepcopy_1.default)(args);
                yield this.injectUpdateHierarchy(db, model, args);
                if (this.options.logPrismaQuery) {
                    this.logger.info(`[delegate] \`updateMany\` ${this.getModelName(model)}: ${(0, utils_1.formatObject)(args)}`);
                }
                return db[model].updateMany(args);
            }
            else {
                // translate to plain `update` for nested write into base fields
                const findArgs = {
                    where: (0, deepcopy_1.default)(args.where),
                    select: this.queryUtils.makeIdSelection(model),
                };
                yield this.injectUpdateHierarchy(db, model, findArgs);
                if (this.options.logPrismaQuery) {
                    this.logger.info(`[delegate] \`updateMany\` find candidates: ${this.getModelName(model)}: ${(0, utils_1.formatObject)(findArgs)}`);
                }
                const entities = yield db[model].findMany(findArgs);
                const updatePayload = { data: (0, deepcopy_1.default)(args.data), select: this.queryUtils.makeIdSelection(model) };
                yield this.injectUpdateHierarchy(db, model, updatePayload);
                const result = yield Promise.all(entities.map((entity) => {
                    const updateArgs = Object.assign({ where: entity }, updatePayload);
                    if (this.options.logPrismaQuery) {
                        this.logger.info(`[delegate] \`updateMany\` update: ${this.getModelName(model)}: ${(0, utils_1.formatObject)(updateArgs)}`);
                    }
                    return db[model].update(updateArgs);
                }));
                return { count: result.length };
            }
        });
    }
    injectUpdateHierarchy(db, model, args) {
        return __awaiter(this, void 0, void 0, function* () {
            const visitor = new cross_1.NestedWriteVisitor(this.options.modelMeta, {
                update: (model, args, _context) => {
                    this.injectWhereHierarchy(model, args === null || args === void 0 ? void 0 : args.where);
                    this.doProcessUpdatePayload(model, args === null || args === void 0 ? void 0 : args.data);
                },
                updateMany: (model, args, context) => __awaiter(this, void 0, void 0, function* () {
                    let simpleUpdateMany = Object.keys(args.data).every((key) => {
                        // check if the `data` clause involves base fields
                        const fieldInfo = (0, cross_1.resolveField)(this.options.modelMeta, model, key);
                        return !(fieldInfo === null || fieldInfo === void 0 ? void 0 : fieldInfo.inheritedFrom);
                    });
                    if (simpleUpdateMany) {
                        // check if the `where` clause involves base fields
                        simpleUpdateMany = Object.keys(args.where || {}).every((key) => {
                            const fieldInfo = (0, cross_1.resolveField)(this.options.modelMeta, model, key);
                            return !(fieldInfo === null || fieldInfo === void 0 ? void 0 : fieldInfo.inheritedFrom);
                        });
                    }
                    if (simpleUpdateMany) {
                        this.injectWhereHierarchy(model, args === null || args === void 0 ? void 0 : args.where);
                        this.doProcessUpdatePayload(model, args === null || args === void 0 ? void 0 : args.data);
                    }
                    else {
                        const where = this.queryUtils.buildReversedQuery(context, false, false);
                        yield this.queryUtils.transaction(db, (tx) => __awaiter(this, void 0, void 0, function* () {
                            yield this.doUpdateMany(tx, model, Object.assign(Object.assign({}, args), { where }), simpleUpdateMany);
                        }));
                        delete context.parent['updateMany'];
                    }
                }),
                upsert: (model, args, _context) => {
                    this.injectWhereHierarchy(model, args === null || args === void 0 ? void 0 : args.where);
                    if (args.create) {
                        this.doProcessCreatePayload(model, args === null || args === void 0 ? void 0 : args.create);
                    }
                    if (args.update) {
                        this.doProcessUpdatePayload(model, args === null || args === void 0 ? void 0 : args.update);
                    }
                },
                create: (model, args, _context) => {
                    if ((0, cross_1.isDelegateModel)(this.options.modelMeta, model)) {
                        throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, `Model "${model}" is a delegate and cannot be created directly`);
                    }
                    this.doProcessCreatePayload(model, args);
                },
                createMany: (model, args, _context) => {
                    if (args.skipDuplicates) {
                        throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, '`createMany` with `skipDuplicates` set to true is not supported for delegated models');
                    }
                    for (const item of (0, cross_1.enumerate)(args === null || args === void 0 ? void 0 : args.data)) {
                        this.doProcessCreatePayload(model, item);
                    }
                },
                connect: (model, args, _context) => {
                    this.injectWhereHierarchy(model, args);
                },
                connectOrCreate: (model, args, _context) => {
                    this.injectWhereHierarchy(model, args.where);
                    if (args.create) {
                        this.doProcessCreatePayload(model, args.create);
                    }
                },
                disconnect: (model, args, _context) => {
                    this.injectWhereHierarchy(model, args);
                },
                set: (model, args, _context) => {
                    this.injectWhereHierarchy(model, args);
                },
                delete: (model, _args, context) => __awaiter(this, void 0, void 0, function* () {
                    const where = this.queryUtils.buildReversedQuery(context, false, false);
                    yield this.queryUtils.transaction(db, (tx) => __awaiter(this, void 0, void 0, function* () {
                        yield this.doDelete(tx, model, { where });
                    }));
                    delete context.parent['delete'];
                }),
                deleteMany: (model, _args, context) => __awaiter(this, void 0, void 0, function* () {
                    const where = this.queryUtils.buildReversedQuery(context, false, false);
                    yield this.queryUtils.transaction(db, (tx) => __awaiter(this, void 0, void 0, function* () {
                        yield this.doDeleteMany(tx, model, where);
                    }));
                    delete context.parent['deleteMany'];
                }),
            });
            yield visitor.visit(model, 'update', args);
        });
    }
    doProcessUpdatePayload(model, data) {
        if (!data) {
            return;
        }
        for (const [field, value] of Object.entries(data)) {
            const fieldInfo = (0, cross_1.resolveField)(this.options.modelMeta, model, field);
            if (fieldInfo === null || fieldInfo === void 0 ? void 0 : fieldInfo.inheritedFrom) {
                this.injectBaseFieldData(model, fieldInfo, value, data, 'update');
                delete data[field];
            }
        }
    }
    // #endregion
    // #region delete
    delete(args) {
        if (!args) {
            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, 'query argument is required');
        }
        if (!this.involvesDelegateModel(this.model)) {
            return super.delete(args);
        }
        return this.queryUtils.transaction(this.prisma, (tx) => __awaiter(this, void 0, void 0, function* () {
            const selectInclude = this.buildSelectIncludeHierarchy(this.model, args);
            // make sure id fields are selected
            const idFields = this.getIdFields(this.model);
            for (const idField of idFields) {
                if ((selectInclude === null || selectInclude === void 0 ? void 0 : selectInclude.select) && !(idField.name in selectInclude.select)) {
                    selectInclude.select[idField.name] = true;
                }
            }
            const deleteArgs = Object.assign(Object.assign({}, (0, deepcopy_1.default)(args)), selectInclude);
            return this.doDelete(tx, this.model, deleteArgs);
        }));
    }
    deleteMany(args) {
        if (!this.involvesDelegateModel(this.model)) {
            return super.deleteMany(args);
        }
        return this.queryUtils.transaction(this.prisma, (tx) => this.doDeleteMany(tx, this.model, args === null || args === void 0 ? void 0 : args.where));
    }
    doDeleteMany(db, model, where) {
        return __awaiter(this, void 0, void 0, function* () {
            // query existing entities with id
            const idSelection = this.queryUtils.makeIdSelection(model);
            const findArgs = { where: (0, deepcopy_1.default)(where), select: idSelection };
            this.injectWhereHierarchy(model, findArgs.where);
            if (this.options.logPrismaQuery) {
                this.logger.info(`[delegate] \`deleteMany\` find candidates: ${this.getModelName(model)}: ${(0, utils_1.formatObject)(findArgs)}`);
            }
            const entities = yield db[model].findMany(findArgs);
            // recursively delete base entities (they all have the same id values)
            yield Promise.all(entities.map((entity) => this.doDelete(db, model, { where: entity })));
            return { count: entities.length };
        });
    }
    deleteBaseRecursively(db, model, idValues) {
        return __awaiter(this, void 0, void 0, function* () {
            let base = this.getBaseModel(model);
            while (base) {
                yield db[base.name].delete({ where: idValues });
                base = this.getBaseModel(base.name);
            }
        });
    }
    doDelete(db, model, args) {
        return __awaiter(this, void 0, void 0, function* () {
            this.injectWhereHierarchy(model, args.where);
            if (this.options.logPrismaQuery) {
                this.logger.info(`[delegate] \`delete\` ${this.getModelName(model)}: ${(0, utils_1.formatObject)(args)}`);
            }
            const result = yield db[model].delete(args);
            const idValues = this.queryUtils.getEntityIds(model, result);
            // recursively delete base entities (they all have the same id values)
            yield this.deleteBaseRecursively(db, model, idValues);
            return this.assembleHierarchy(model, result);
        });
    }
    // #endregion
    // #region aggregation
    aggregate(args) {
        if (!args) {
            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, 'query argument is required');
        }
        if (!this.involvesDelegateModel(this.model)) {
            return super.aggregate(args);
        }
        // check if any aggregation operator is using fields from base
        this.checkAggregationArgs('aggregate', args);
        args = (0, deepcopy_1.default)(args);
        if (args.cursor) {
            args.cursor = this.buildWhereHierarchy(this.model, args.cursor);
        }
        if (args.orderBy) {
            args.orderBy = this.buildWhereHierarchy(this.model, args.orderBy);
        }
        if (args.where) {
            args.where = this.buildWhereHierarchy(this.model, args.where);
        }
        if (this.options.logPrismaQuery) {
            this.logger.info(`[delegate] \`aggregate\` ${this.getModelName(this.model)}: ${(0, utils_1.formatObject)(args)}`);
        }
        return super.aggregate(args);
    }
    count(args) {
        if (!this.involvesDelegateModel(this.model)) {
            return super.count(args);
        }
        // check if count select is using fields from base
        this.checkAggregationArgs('count', args);
        args = (0, deepcopy_1.default)(args);
        if (args === null || args === void 0 ? void 0 : args.cursor) {
            args.cursor = this.buildWhereHierarchy(this.model, args.cursor);
        }
        if (args === null || args === void 0 ? void 0 : args.where) {
            args.where = this.buildWhereHierarchy(this.model, args.where);
        }
        if (this.options.logPrismaQuery) {
            this.logger.info(`[delegate] \`count\` ${this.getModelName(this.model)}: ${(0, utils_1.formatObject)(args)}`);
        }
        return super.count(args);
    }
    groupBy(args) {
        if (!args) {
            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, 'query argument is required');
        }
        if (!this.involvesDelegateModel(this.model)) {
            return super.groupBy(args);
        }
        // check if count select is using fields from base
        this.checkAggregationArgs('groupBy', args);
        if (args.by) {
            for (const by of (0, cross_1.enumerate)(args.by)) {
                const fieldInfo = (0, cross_1.resolveField)(this.options.modelMeta, this.model, by);
                if (fieldInfo && fieldInfo.inheritedFrom) {
                    throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, `groupBy with fields from base type is not supported yet: "${by}"`);
                }
            }
        }
        args = (0, deepcopy_1.default)(args);
        if (args.where) {
            args.where = this.buildWhereHierarchy(this.model, args.where);
        }
        if (this.options.logPrismaQuery) {
            this.logger.info(`[delegate] \`groupBy\` ${this.getModelName(this.model)}: ${(0, utils_1.formatObject)(args)}`);
        }
        return super.groupBy(args);
    }
    checkAggregationArgs(operation, args) {
        if (!args) {
            return;
        }
        for (const op of ['_count', '_sum', '_avg', '_min', '_max', 'select', 'having']) {
            if (args[op] && typeof args[op] === 'object') {
                for (const field of Object.keys(args[op])) {
                    const fieldInfo = (0, cross_1.resolveField)(this.options.modelMeta, this.model, field);
                    if (fieldInfo === null || fieldInfo === void 0 ? void 0 : fieldInfo.inheritedFrom) {
                        throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, `${operation} with fields from base type is not supported yet: "${field}"`);
                    }
                }
            }
        }
    }
    // #endregion
    // #region utils
    extractSelectInclude(args) {
        if (!args) {
            return undefined;
        }
        args = (0, deepcopy_1.default)(args);
        return 'select' in args
            ? { select: args['select'] }
            : 'include' in args
                ? { include: args['include'] }
                : undefined;
    }
    makeAuxRelationName(model) {
        return `${constants_1.DELEGATE_AUX_RELATION_PREFIX}_${(0, lower_case_first_1.lowerCaseFirst)(model.name)}`;
    }
    getModelName(model) {
        const info = (0, cross_1.getModelInfo)(this.options.modelMeta, model, true);
        return info.name;
    }
    getIdFields(model) {
        const idFields = (0, cross_1.getIdFields)(this.options.modelMeta, model);
        if (idFields && idFields.length > 0) {
            return idFields;
        }
        const base = this.getBaseModel(model);
        return base ? this.getIdFields(base.name) : [];
    }
    getModelInfo(model) {
        return (0, cross_1.getModelInfo)(this.options.modelMeta, model, true);
    }
    getBaseModel(model) {
        const baseNames = (0, cross_1.getModelInfo)(this.options.modelMeta, model, true).baseTypes;
        if (!baseNames) {
            return undefined;
        }
        if (baseNames.length > 1) {
            throw new Error('Multi-inheritance is not supported');
        }
        return this.options.modelMeta.models[(0, lower_case_first_1.lowerCaseFirst)(baseNames[0])];
    }
    involvesDelegateModel(model, visited) {
        if (this.isDelegateOrDescendantOfDelegate(model)) {
            return true;
        }
        visited = visited !== null && visited !== void 0 ? visited : new Set();
        if (visited.has(model)) {
            return false;
        }
        visited.add(model);
        const modelInfo = (0, cross_1.getModelInfo)(this.options.modelMeta, model, true);
        return Object.values(modelInfo.fields).some((field) => field.isDataModel && this.involvesDelegateModel(field.type, visited));
    }
    isDelegateOrDescendantOfDelegate(model) {
        var _a;
        if ((0, cross_1.isDelegateModel)(this.options.modelMeta, model)) {
            return true;
        }
        const baseTypes = (_a = (0, cross_1.getModelInfo)(this.options.modelMeta, model)) === null || _a === void 0 ? void 0 : _a.baseTypes;
        return !!(baseTypes &&
            baseTypes.length > 0 &&
            baseTypes.some((base) => this.isDelegateOrDescendantOfDelegate(base)));
    }
    assembleHierarchy(model, entity) {
        if (!entity || typeof entity !== 'object') {
            return entity;
        }
        const upMerged = this.assembleUp(model, entity);
        const downMerged = this.assembleDown(model, entity);
        // https://www.npmjs.com/package/deepmerge#arraymerge-example-combine-arrays
        const combineMerge = (target, source, options) => {
            const destination = target.slice();
            source.forEach((item, index) => {
                if (typeof destination[index] === 'undefined') {
                    destination[index] = options.cloneUnlessOtherwiseSpecified(item, options);
                }
                else if (options.isMergeableObject(item)) {
                    destination[index] = (0, deepmerge_1.default)(target[index], item, options);
                }
                else if (target.indexOf(item) === -1) {
                    destination.push(item);
                }
            });
            return destination;
        };
        const result = (0, deepmerge_1.default)(upMerged, downMerged, {
            arrayMerge: combineMerge,
        });
        return result;
    }
    assembleUp(model, entity) {
        const result = {};
        const base = this.getBaseModel(model);
        if (base) {
            // merge base fields
            const baseRelationName = this.makeAuxRelationName(base);
            const baseData = entity[baseRelationName];
            if (baseData && typeof baseData === 'object') {
                const baseAssembled = this.assembleUp(base.name, baseData);
                Object.assign(result, baseAssembled);
            }
        }
        const modelInfo = (0, cross_1.getModelInfo)(this.options.modelMeta, model, true);
        for (const [key, value] of Object.entries(entity)) {
            if (key.startsWith(constants_1.DELEGATE_AUX_RELATION_PREFIX)) {
                continue;
            }
            const field = modelInfo.fields[key];
            if (!field) {
                // not a field, could be `_count`, `_sum`, etc.
                result[key] = value;
                continue;
            }
            if (field.inheritedFrom) {
                // already merged from base
                continue;
            }
            if (field.isDataModel) {
                if (Array.isArray(value)) {
                    result[field.name] = value.map((item) => this.assembleUp(field.type, item));
                }
                else {
                    result[field.name] = this.assembleUp(field.type, value);
                }
            }
            else {
                result[field.name] = value;
            }
        }
        return result;
    }
    assembleDown(model, entity) {
        const result = {};
        const modelInfo = (0, cross_1.getModelInfo)(this.options.modelMeta, model, true);
        if (modelInfo.discriminator) {
            // model is a delegate, merge sub model fields
            const subModelName = entity[modelInfo.discriminator];
            if (subModelName) {
                const subModel = (0, cross_1.getModelInfo)(this.options.modelMeta, subModelName, true);
                const subRelationName = this.makeAuxRelationName(subModel);
                const subData = entity[subRelationName];
                if (subData && typeof subData === 'object') {
                    const subAssembled = this.assembleDown(subModel.name, subData);
                    Object.assign(result, subAssembled);
                }
            }
        }
        for (const [key, value] of Object.entries(entity)) {
            if (key.startsWith(constants_1.DELEGATE_AUX_RELATION_PREFIX)) {
                continue;
            }
            const field = modelInfo.fields[key];
            if (!field) {
                // not a field, could be `_count`, `_sum`, etc.
                result[key] = value;
                continue;
            }
            if (field.isDataModel) {
                if (Array.isArray(value)) {
                    result[field.name] = value.map((item) => this.assembleDown(field.type, item));
                }
                else {
                    result[field.name] = this.assembleDown(field.type, value);
                }
            }
            else {
                result[field.name] = value;
            }
        }
        return result;
    }
}
exports.DelegateProxyHandler = DelegateProxyHandler;
//# sourceMappingURL=delegate.js.map