import type { ModelMeta } from '../cross';
import type { DbClientContract } from '../types';
import type { InternalEnhancementOptions } from './create-enhancement';
/**
 * Prisma batch write operation result
 */
export type BatchResult = {
    count: number;
};
/**
 * Function for transforming errors.
 */
export type ErrorTransformer = (error: unknown) => unknown;
/**
 * Interface for proxy that intercepts Prisma operations.
 */
export interface PrismaProxyHandler {
    findUnique(args: any): Promise<unknown | null>;
    findUniqueOrThrow(args: any): Promise<unknown>;
    findFirst(args: any): Promise<unknown | null>;
    findFirstOrThrow(args: any): Promise<unknown>;
    findMany(args: any): Promise<unknown[]>;
    create(args: any): Promise<unknown>;
    createMany(args: {
        data: any;
        skipDuplicates?: boolean;
    }): Promise<BatchResult>;
    update(args: any): Promise<unknown>;
    updateMany(args: any): Promise<BatchResult>;
    upsert(args: any): Promise<unknown>;
    delete(args: any): Promise<unknown>;
    deleteMany(args: any): Promise<BatchResult>;
    aggregate(args: any): Promise<unknown>;
    groupBy(args: any): Promise<unknown>;
    count(args: any): Promise<unknown | number>;
    subscribe(args: any): Promise<unknown>;
}
/**
 * All Prisma operation names
 */
export type PrismaProxyActions = keyof PrismaProxyHandler;
/**
 * A default implementation of @see PrismaProxyHandler which directly
 * delegates to the wrapped Prisma client. It offers a few overridable
 * methods to allow more easily inject custom logic.
 */
export declare class DefaultPrismaProxyHandler implements PrismaProxyHandler {
    protected readonly prisma: DbClientContract;
    protected readonly model: string;
    protected readonly options: InternalEnhancementOptions;
    constructor(prisma: DbClientContract, model: string, options: InternalEnhancementOptions);
    protected withFluentCall(method: keyof PrismaProxyHandler, args: any, postProcess?: boolean): Promise<unknown>;
    protected deferred<TResult = unknown>(method: keyof PrismaProxyHandler, args: any, postProcess?: boolean): Promise<TResult>;
    findUnique(args: any): Promise<unknown>;
    findUniqueOrThrow(args: any): Promise<unknown>;
    findFirst(args: any): Promise<unknown>;
    findFirstOrThrow(args: any): Promise<unknown>;
    findMany(args: any): Promise<unknown[]>;
    create(args: any): Promise<unknown>;
    createMany(args: {
        data: any;
        skipDuplicates?: boolean;
    }): Promise<{
        count: number;
    }>;
    update(args: any): Promise<unknown>;
    updateMany(args: any): Promise<{
        count: number;
    }>;
    upsert(args: any): Promise<unknown>;
    delete(args: any): Promise<unknown>;
    deleteMany(args: any): Promise<{
        count: number;
    }>;
    aggregate(args: any): Promise<unknown>;
    groupBy(args: any): Promise<unknown>;
    count(args: any): Promise<unknown>;
    subscribe(args: any): Promise<unknown>;
    /**
     * Processes result entities before they're returned
     */
    protected processResultEntity<T>(data: T): Promise<T>;
    /**
     * Processes query args before they're passed to Prisma.
     */
    protected preprocessArgs(method: PrismaProxyActions, args: any): Promise<any>;
}
/**
 * Makes a Prisma client proxy.
 */
export declare function makeProxy<T extends PrismaProxyHandler>(prisma: any, modelMeta: ModelMeta, makeHandler: (prisma: object, model: string) => T, name?: string, errorTransformer?: ErrorTransformer): any;
