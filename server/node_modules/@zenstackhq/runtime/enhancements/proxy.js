"use strict";
/* eslint-disable @typescript-eslint/no-explicit-any */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeProxy = exports.DefaultPrismaProxyHandler = void 0;
const deepcopy_1 = __importDefault(require("deepcopy"));
const constants_1 = require("../constants");
const promise_1 = require("./promise");
/**
 * A default implementation of @see PrismaProxyHandler which directly
 * delegates to the wrapped Prisma client. It offers a few overridable
 * methods to allow more easily inject custom logic.
 */
class DefaultPrismaProxyHandler {
    constructor(prisma, model, options) {
        this.prisma = prisma;
        this.model = model;
        this.options = options;
    }
    withFluentCall(method, args, postProcess = true) {
        args = args ? (0, deepcopy_1.default)(args) : {};
        const promise = (0, promise_1.createFluentPromise)(() => __awaiter(this, void 0, void 0, function* () {
            args = yield this.preprocessArgs(method, args);
            const r = yield this.prisma[this.model][method](args);
            return postProcess ? this.processResultEntity(r) : r;
        }), args, this.options.modelMeta, this.model);
        return promise;
    }
    deferred(method, args, postProcess = true) {
        return (0, promise_1.createDeferredPromise)(() => __awaiter(this, void 0, void 0, function* () {
            args = yield this.preprocessArgs(method, args);
            const r = yield this.prisma[this.model][method](args);
            return postProcess ? this.processResultEntity(r) : r;
        }));
    }
    findUnique(args) {
        return this.withFluentCall('findUnique', args);
    }
    findUniqueOrThrow(args) {
        return this.withFluentCall('findUniqueOrThrow', args);
    }
    findFirst(args) {
        return this.withFluentCall('findFirst', args);
    }
    findFirstOrThrow(args) {
        return this.withFluentCall('findFirstOrThrow', args);
    }
    findMany(args) {
        return this.deferred('findMany', args);
    }
    create(args) {
        return this.deferred('create', args);
    }
    createMany(args) {
        return this.deferred('createMany', args, false);
    }
    update(args) {
        return this.deferred('update', args);
    }
    updateMany(args) {
        return this.deferred('updateMany', args, false);
    }
    upsert(args) {
        return this.deferred('upsert', args);
    }
    delete(args) {
        return this.deferred('delete', args);
    }
    deleteMany(args) {
        return this.deferred('deleteMany', args, false);
    }
    aggregate(args) {
        return this.deferred('aggregate', args, false);
    }
    groupBy(args) {
        return this.deferred('groupBy', args, false);
    }
    count(args) {
        return this.deferred('count', args, false);
    }
    subscribe(args) {
        return this.deferred('subscribe', args, false);
    }
    /**
     * Processes result entities before they're returned
     */
    processResultEntity(data) {
        return __awaiter(this, void 0, void 0, function* () {
            return data;
        });
    }
    /**
     * Processes query args before they're passed to Prisma.
     */
    preprocessArgs(method, args) {
        return __awaiter(this, void 0, void 0, function* () {
            return args;
        });
    }
}
exports.DefaultPrismaProxyHandler = DefaultPrismaProxyHandler;
// a marker for filtering error stack trace
const ERROR_MARKER = '__error_marker__';
const customInspect = Symbol.for('nodejs.util.inspect.custom');
/**
 * Makes a Prisma client proxy.
 */
function makeProxy(prisma, modelMeta, makeHandler, name = 'unnamed_enhancer', errorTransformer) {
    const models = Object.keys(modelMeta.models).map((k) => k.toLowerCase());
    const proxy = new Proxy(prisma, {
        get: (target, prop, receiver) => {
            // enhancer metadata
            if (prop === constants_1.PRISMA_PROXY_ENHANCER) {
                return name;
            }
            if (prop === '$transaction') {
                // for interactive transactions, we need to proxy the transaction function so that
                // when it runs the callback, it provides a proxy to the Prisma client wrapped with
                // the same handler
                //
                // TODO: batch transaction is not supported yet, how?
                const $transaction = Reflect.get(target, prop, receiver);
                if ($transaction) {
                    return (input, ...rest) => {
                        if (Array.isArray(input)) {
                            throw new Error('Sequential operations transaction is not supported by ZenStack enhanced Prisma client. Please use interactive transaction instead.');
                        }
                        else if (typeof input !== 'function') {
                            throw new Error('A function value input is expected');
                        }
                        const txFunc = input;
                        return $transaction.bind(target)((tx) => {
                            // create a proxy for the transaction function
                            const txProxy = makeProxy(tx, modelMeta, makeHandler, name + '$tx');
                            // call the transaction function with the proxy
                            return txFunc(txProxy);
                        }, ...rest);
                    };
                }
                else {
                    return $transaction;
                }
            }
            if (typeof prop !== 'string' || prop.startsWith('$') || !models.includes(prop.toLowerCase())) {
                // skip non-model fields
                return Reflect.get(target, prop, receiver);
            }
            const propVal = Reflect.get(target, prop, receiver);
            if (!propVal || typeof propVal !== 'object') {
                return propVal;
            }
            return createHandlerProxy(makeHandler(target, prop), propVal, prop, errorTransformer);
        },
    });
    proxy[customInspect] = `$zenstack_prisma_${prisma._clientVersion}`;
    return proxy;
}
exports.makeProxy = makeProxy;
// A proxy for capturing errors and processing stack trace
function createHandlerProxy(handler, origTarget, model, errorTransformer) {
    return new Proxy(handler, {
        get(target, propKey) {
            const prop = target[propKey];
            if (typeof prop !== 'function') {
                // the proxy handler doesn't have this method, fall back to the original target
                // this can happen for new methods added by Prisma Client Extensions
                return origTarget[propKey];
            }
            // eslint-disable-next-line @typescript-eslint/ban-types
            const origMethod = prop;
            return function (...args) {
                // using proxy with async functions results in messed-up error stack trace,
                // create an error to capture the current stack
                const capture = new Error(ERROR_MARKER);
                // the original proxy returned by the PrismaClient proxy
                const promise = origMethod.apply(handler, args);
                // modify the error stack
                const resultPromise = (0, promise_1.createDeferredPromise)(() => {
                    return new Promise((resolve, reject) => {
                        promise.then((value) => resolve(value), (err) => {
                            if (capture.stack && err instanceof Error) {
                                // save the original stack and replace it with a clean one
                                err.internalStack = err.stack;
                                err.stack = cleanCallStack(capture.stack, model, propKey.toString(), err.message);
                            }
                            if (errorTransformer) {
                                err = errorTransformer ? errorTransformer(err) : err;
                            }
                            reject(err);
                        });
                    });
                });
                // carry over extra fields from the original promise
                for (const [k, v] of Object.entries(promise)) {
                    if (!(k in resultPromise)) {
                        resultPromise[k] = v;
                    }
                }
                return resultPromise;
            };
        },
    });
}
// Filter out @zenstackhq/runtime stack (generated by proxy) from stack trace
function cleanCallStack(stack, model, method, message) {
    // message line
    let resultStack = `Error calling enhanced Prisma method \`${model}.${method}\`: ${message}`;
    const lines = stack.split('\n');
    let foundMarker = false;
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (!foundMarker) {
            // find marker, then stack trace lines follow
            if (line.includes(ERROR_MARKER)) {
                foundMarker = true;
            }
            continue;
        }
        // skip leading zenstack and anonymous lines
        if (line.includes('@zenstackhq/runtime') || line.includes('Proxy.<anonymous>')) {
            continue;
        }
        // capture remaining lines
        resultStack += lines
            .slice(i)
            .map((l) => '\n' + l)
            .join();
        break;
    }
    return resultStack;
}
//# sourceMappingURL=proxy.js.map