"use strict";
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
/* eslint-disable @typescript-eslint/no-explicit-any */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WhereVisitor = void 0;
const cross_1 = require("../cross");
const FILTER_OPERATORS = [
    'equals',
    'not',
    'in',
    'notIn',
    'lt',
    'lte',
    'gt',
    'gte',
    'contains',
    'search',
    'startsWith',
    'endsWith',
];
const RELATION_FILTER_OPERATORS = ['is', 'isNot', 'some', 'every', 'none'];
/**
 * Recursive visitor for where payload
 */
class WhereVisitor {
    constructor(modelMeta, callback) {
        this.modelMeta = modelMeta;
        this.callback = callback;
    }
    /**
     * Start visiting
     */
    visit(model, where) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            if (!where) {
                return;
            }
            for (const [k, v] of Object.entries(where)) {
                if (['AND', 'OR', 'NOT'].includes(k)) {
                    for (const item of (0, cross_1.enumerate)(v)) {
                        yield this.visit(model, item);
                    }
                    continue;
                }
                if (RELATION_FILTER_OPERATORS.includes(k)) {
                    // visit into filter body
                    yield this.visit(model, v);
                    continue;
                }
                const field = (0, cross_1.resolveField)(this.modelMeta, model, k);
                if (!field) {
                    continue;
                }
                if (typeof v === 'object') {
                    const filterOp = Object.keys(v).find((f) => FILTER_OPERATORS.includes(f));
                    if (filterOp) {
                        // reach into filter value
                        const newValue = yield ((_b = (_a = this.callback).field) === null || _b === void 0 ? void 0 : _b.call(_a, field, v[filterOp]));
                        v[filterOp] = newValue;
                        continue;
                    }
                    if (Object.keys(v).some((f) => RELATION_FILTER_OPERATORS.includes(f))) {
                        // filter payload
                        yield this.visit(field.type, v);
                        continue;
                    }
                }
                // scalar field
                const newValue = yield ((_d = (_c = this.callback).field) === null || _d === void 0 ? void 0 : _d.call(_c, field, v));
                where[k] = newValue;
            }
        });
    }
}
exports.WhereVisitor = WhereVisitor;
//# sourceMappingURL=where-visitor.js.map