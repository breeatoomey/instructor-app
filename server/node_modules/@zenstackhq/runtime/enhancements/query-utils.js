"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueryUtils = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
const cross_1 = require("../cross");
const version_1 = require("../version");
const utils_1 = require("./utils");
class QueryUtils {
    constructor(prisma, options) {
        this.prisma = prisma;
        this.options = options;
    }
    getIdFields(model) {
        return (0, cross_1.getIdFields)(this.options.modelMeta, model, true);
    }
    makeIdSelection(model) {
        const idFields = this.getIdFields(model);
        return Object.assign({}, ...idFields.map((f) => ({ [f.name]: true })));
    }
    getEntityIds(model, entityData) {
        const idFields = this.getIdFields(model);
        const result = {};
        for (const idField of idFields) {
            result[idField.name] = entityData[idField.name];
        }
        return result;
    }
    /**
     * Initiates a transaction.
     */
    transaction(db, action) {
        const fullDb = db;
        if (fullDb['$transaction']) {
            return fullDb.$transaction((tx) => {
                tx[Symbol.for('nodejs.util.inspect.custom')] = 'PrismaClient$tx';
                return action(tx);
            }, {
                maxWait: this.options.transactionMaxWait,
                timeout: this.options.transactionTimeout,
                isolationLevel: this.options.transactionIsolationLevel,
            });
        }
        else {
            // already in transaction, don't nest
            return action(db);
        }
    }
    /**
     * Builds a reversed query for the given nested path.
     */
    buildReversedQuery(context, forMutationPayload = false, unsafeOperation = false) {
        let result, currQuery;
        let currField;
        for (let i = context.nestingPath.length - 1; i >= 0; i--) {
            const { field, model, where } = context.nestingPath[i];
            // never modify the original where because it's shared in the structure
            const visitWhere = Object.assign({}, where);
            if (model && where) {
                // make sure composite unique condition is flattened
                this.flattenGeneratedUniqueField(model, visitWhere);
            }
            if (!result) {
                // first segment (bottom), just use its where clause
                result = currQuery = Object.assign({}, visitWhere);
                currField = field;
            }
            else {
                if (!currField) {
                    throw this.unknownError(`missing field in nested path`);
                }
                if (!currField.backLink) {
                    throw this.unknownError(`field ${currField.type}.${currField.name} doesn't have a backLink`);
                }
                const backLinkField = this.getModelField(currField.type, currField.backLink);
                if (!backLinkField) {
                    throw this.unknownError(`missing backLink field ${currField.backLink} in ${currField.type}`);
                }
                if (backLinkField.isArray && !forMutationPayload) {
                    // many-side of relationship, wrap with "some" query
                    currQuery[currField.backLink] = { some: Object.assign({}, visitWhere) };
                    currQuery = currQuery[currField.backLink].some;
                }
                else {
                    const fkMapping = where && backLinkField.isRelationOwner && backLinkField.foreignKeyMapping;
                    // calculate if we should preserve the relation condition (e.g., { user: { id: 1 } })
                    const shouldPreserveRelationCondition = 
                    // doing a mutation
                    forMutationPayload &&
                        // and it's a safe mutate
                        !unsafeOperation &&
                        // and the current segment is the direct parent (the last one is the mutate itself),
                        // the relation condition should be preserved and will be converted to a "connect" later
                        i === context.nestingPath.length - 2;
                    if (fkMapping && !shouldPreserveRelationCondition) {
                        // turn relation condition into foreign key condition, e.g.:
                        //     { user: { id: 1 } } => { userId: 1 }
                        for (const [r, fk] of Object.entries(fkMapping)) {
                            currQuery[fk] = visitWhere[r];
                        }
                        if (i > 0) {
                            // prepare for the next segment
                            currQuery[currField.backLink] = {};
                        }
                    }
                    else {
                        // preserve the original structure
                        currQuery[currField.backLink] = Object.assign({}, visitWhere);
                    }
                    if (forMutationPayload && currQuery[currField.backLink]) {
                        // reconstruct compound unique field
                        currQuery[currField.backLink] = this.composeCompoundUniqueField(backLinkField.type, currQuery[currField.backLink]);
                    }
                    currQuery = currQuery[currField.backLink];
                }
                currField = field;
            }
        }
        return result;
    }
    /**
     * Composes a compound unique field from multiple fields. E.g.:  { a: '1', b: '1' } => { a_b: { a: '1', b: '1' } }.
     */
    composeCompoundUniqueField(model, fieldData) {
        const uniqueConstraints = (0, cross_1.getUniqueConstraints)(this.options.modelMeta, model);
        if (!uniqueConstraints) {
            return fieldData;
        }
        const result = (0, utils_1.clone)(fieldData);
        for (const [name, constraint] of Object.entries(uniqueConstraints)) {
            if (constraint.fields.length > 1 && constraint.fields.every((f) => fieldData[f] !== undefined)) {
                // multi-field unique constraint, compose it
                result[name] = constraint.fields.reduce((prev, field) => (Object.assign(Object.assign({}, prev), { [field]: fieldData[field] })), {});
                constraint.fields.forEach((f) => delete result[f]);
            }
        }
        return result;
    }
    /**
     * Flattens a generated unique field. E.g.: { a_b: { a: '1', b: '1' } } => { a: '1', b: '1' }.
     */
    flattenGeneratedUniqueField(model, args) {
        const uniqueConstraints = (0, cross_1.getUniqueConstraints)(this.options.modelMeta, model);
        if (uniqueConstraints && Object.keys(uniqueConstraints).length > 0) {
            for (const [field, value] of Object.entries(args)) {
                if (uniqueConstraints[field] &&
                    uniqueConstraints[field].fields.length > 1 &&
                    typeof value === 'object') {
                    // multi-field unique constraint, flatten it
                    delete args[field];
                    if (value) {
                        for (const [f, v] of Object.entries(value)) {
                            args[f] = v;
                        }
                    }
                }
            }
        }
    }
    validationError(message) {
        return (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, message);
    }
    unknownError(message) {
        return (0, utils_1.prismaClientUnknownRequestError)(this.prisma, this.options.prismaModule, message, {
            clientVersion: (0, version_1.getVersion)(),
        });
    }
    getModelFields(model) {
        var _a;
        return (_a = (0, cross_1.getModelInfo)(this.options.modelMeta, model)) === null || _a === void 0 ? void 0 : _a.fields;
    }
    /**
     * Gets information for a specific model field.
     */
    getModelField(model, field) {
        return (0, cross_1.resolveField)(this.options.modelMeta, model, field);
    }
}
exports.QueryUtils = QueryUtils;
//# sourceMappingURL=query-utils.js.map