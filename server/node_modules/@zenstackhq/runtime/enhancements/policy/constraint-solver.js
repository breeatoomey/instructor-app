"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConstraintSolver = void 0;
const logic_solver_1 = __importDefault(require("logic-solver"));
const ts_pattern_1 = require("ts-pattern");
/**
 * A boolean constraint solver based on `logic-solver`. Only boolean and integer types are supported.
 */
class ConstraintSolver {
    constructor() {
        // a table for internalizing string literals
        this.stringTable = [];
        // a map for storing variable names and their corresponding formulas
        this.variables = new Map();
    }
    /**
     * Check the satisfiability of the given constraint.
     */
    checkSat(constraint) {
        // reset state
        this.stringTable = [];
        this.variables = new Map();
        // convert the constraint to a "logic-solver" formula
        const formula = this.buildFormula(constraint);
        // solve the formula
        const solver = new logic_solver_1.default.Solver();
        solver.require(formula);
        // DEBUG:
        // const solution = solver.solve();
        // if (solution) {
        //     console.log('Solution:');
        //     this.variables.forEach((v, k) => console.log(`\t${k}=${solution?.evaluate(v)}`));
        // } else {
        //     console.log('No solution');
        // }
        return !!solver.solve();
    }
    buildFormula(constraint) {
        return (0, ts_pattern_1.match)(constraint)
            .when((c) => c.kind === 'value', (c) => this.buildValueFormula(c))
            .when((c) => c.kind === 'variable', (c) => this.buildVariableFormula(c))
            .when((c) => ['eq', 'ne', 'gt', 'gte', 'lt', 'lte'].includes(c.kind), (c) => this.buildComparisonFormula(c))
            .when((c) => ['and', 'or', 'not'].includes(c.kind), (c) => this.buildLogicalFormula(c))
            .otherwise(() => {
            throw new Error(`Unsupported constraint format: ${JSON.stringify(constraint)}`);
        });
    }
    buildLogicalFormula(constraint) {
        return (0, ts_pattern_1.match)(constraint.kind)
            .with('and', () => this.buildAndFormula(constraint))
            .with('or', () => this.buildOrFormula(constraint))
            .with('not', () => this.buildNotFormula(constraint))
            .exhaustive();
    }
    buildAndFormula(constraint) {
        if (constraint.children.some((c) => this.isFalse(c))) {
            // short-circuit
            return logic_solver_1.default.FALSE;
        }
        return logic_solver_1.default.and(...constraint.children.map((c) => this.buildFormula(c)));
    }
    buildOrFormula(constraint) {
        if (constraint.children.some((c) => this.isTrue(c))) {
            // short-circuit
            return logic_solver_1.default.TRUE;
        }
        return logic_solver_1.default.or(...constraint.children.map((c) => this.buildFormula(c)));
    }
    buildNotFormula(constraint) {
        if (constraint.children.length !== 1) {
            throw new Error('"not" constraint must have exactly one child');
        }
        return logic_solver_1.default.not(this.buildFormula(constraint.children[0]));
    }
    isTrue(constraint) {
        return constraint.kind === 'value' && constraint.value === true;
    }
    isFalse(constraint) {
        return constraint.kind === 'value' && constraint.value === false;
    }
    buildComparisonFormula(constraint) {
        if (constraint.left.kind === 'value' && constraint.right.kind === 'value') {
            // constant comparison
            const left = constraint.left;
            const right = constraint.right;
            return (0, ts_pattern_1.match)(constraint.kind)
                .with('eq', () => (left.value === right.value ? logic_solver_1.default.TRUE : logic_solver_1.default.FALSE))
                .with('ne', () => (left.value !== right.value ? logic_solver_1.default.TRUE : logic_solver_1.default.FALSE))
                .with('gt', () => (left.value > right.value ? logic_solver_1.default.TRUE : logic_solver_1.default.FALSE))
                .with('gte', () => (left.value >= right.value ? logic_solver_1.default.TRUE : logic_solver_1.default.FALSE))
                .with('lt', () => (left.value < right.value ? logic_solver_1.default.TRUE : logic_solver_1.default.FALSE))
                .with('lte', () => (left.value <= right.value ? logic_solver_1.default.TRUE : logic_solver_1.default.FALSE))
                .exhaustive();
        }
        return (0, ts_pattern_1.match)(constraint.kind)
            .with('eq', () => this.transformEquality(constraint.left, constraint.right))
            .with('ne', () => this.transformInequality(constraint.left, constraint.right))
            .with('gt', () => this.transformComparison(constraint.left, constraint.right, (l, r) => logic_solver_1.default.greaterThan(l, r)))
            .with('gte', () => this.transformComparison(constraint.left, constraint.right, (l, r) => logic_solver_1.default.greaterThanOrEqual(l, r)))
            .with('lt', () => this.transformComparison(constraint.left, constraint.right, (l, r) => logic_solver_1.default.lessThan(l, r)))
            .with('lte', () => this.transformComparison(constraint.left, constraint.right, (l, r) => logic_solver_1.default.lessThanOrEqual(l, r)))
            .exhaustive();
    }
    buildVariableFormula(constraint) {
        return ((0, ts_pattern_1.match)(constraint.type)
            .with('boolean', () => this.booleanVariable(constraint.name))
            .with('number', () => this.intVariable(constraint.name))
            // strings are internalized and represented by their indices
            .with('string', () => this.intVariable(constraint.name))
            .exhaustive());
    }
    buildValueFormula(constraint) {
        return (0, ts_pattern_1.match)(constraint.value)
            .when((v) => typeof v === 'boolean', (v) => (v === true ? logic_solver_1.default.TRUE : logic_solver_1.default.FALSE))
            .when((v) => typeof v === 'number', (v) => logic_solver_1.default.constantBits(v))
            .when((v) => typeof v === 'string', (v) => {
            // internalize the string and use its index as formula representation
            const index = this.stringTable.indexOf(v);
            if (index === -1) {
                this.stringTable.push(v);
                return logic_solver_1.default.constantBits(this.stringTable.length - 1);
            }
            else {
                return logic_solver_1.default.constantBits(index);
            }
        })
            .exhaustive();
    }
    booleanVariable(name) {
        this.variables.set(name, name);
        return name;
    }
    intVariable(name) {
        const r = logic_solver_1.default.variableBits(name, 32);
        this.variables.set(name, r);
        return r;
    }
    transformEquality(left, right) {
        if (left.type !== right.type) {
            throw new Error(`Type mismatch in equality constraint: ${JSON.stringify(left)}, ${JSON.stringify(right)}`);
        }
        const leftFormula = this.buildFormula(left);
        const rightFormula = this.buildFormula(right);
        if (left.type === 'boolean' && right.type === 'boolean') {
            // logical equivalence
            return logic_solver_1.default.equiv(leftFormula, rightFormula);
        }
        else {
            // integer equality
            return logic_solver_1.default.equalBits(leftFormula, rightFormula);
        }
    }
    transformInequality(left, right) {
        return logic_solver_1.default.not(this.transformEquality(left, right));
    }
    transformComparison(left, right, func) {
        return func(this.buildFormula(left), this.buildFormula(right));
    }
}
exports.ConstraintSolver = ConstraintSolver;
//# sourceMappingURL=constraint-solver.js.map