import { ZodError } from 'zod';
import { CrudFailureReason } from '../../constants';
import { CrudContract, DbClientContract, PolicyCrudKind, PolicyOperationKind } from '../../types';
import type { EnhancementContext, InternalEnhancementOptions } from '../create-enhancement';
import { QueryUtils } from '../query-utils';
import type { CheckerFunc } from '../types';
/**
 * Access policy enforcement utilities
 */
export declare class PolicyUtil extends QueryUtils {
    private readonly db;
    private readonly shouldLogQuery;
    private readonly logger;
    private readonly modelMeta;
    private readonly policy;
    private readonly zodSchemas?;
    private readonly prismaModule;
    private readonly user?;
    constructor(db: DbClientContract, options: InternalEnhancementOptions, context?: EnhancementContext, shouldLogQuery?: boolean);
    /**
     * Creates a conjunction of a list of query conditions.
     */
    and(...conditions: (boolean | object | undefined)[]): object;
    /**
     * Creates a disjunction of a list of query conditions.
     */
    or(...conditions: (boolean | object | undefined)[]): object;
    /**
     * Creates a negation of a query condition.
     */
    not(condition: object | boolean | undefined): object;
    isTrue(condition: object): boolean;
    isFalse(condition: object): boolean;
    private makeTrue;
    private makeFalse;
    private reduce;
    private readonly FULLY_OPEN_AUTH_GUARD;
    private getModelAuthGuard;
    /**
     * Gets pregenerated authorization guard object for a given model and operation.
     *
     * @returns true if operation is unconditionally allowed, false if unconditionally denied,
     * otherwise returns a guard object
     */
    getAuthGuard(db: CrudContract, model: string, operation: PolicyOperationKind, preValue?: any): object;
    /**
     * Get field-level read auth guard that overrides the model-level
     */
    getFieldOverrideReadAuthGuard(db: CrudContract, model: string, field: string): object;
    /**
     * Get field-level update auth guard
     */
    getFieldUpdateAuthGuard(db: CrudContract, model: string, field: string): object;
    /**
     * Get field-level update auth guard that overrides the model-level
     */
    getFieldOverrideUpdateAuthGuard(db: CrudContract, model: string, field: string): object;
    /**
     * Checks if the given model has a policy guard for the given operation.
     */
    hasAuthGuard(model: string, operation: PolicyOperationKind): boolean;
    /**
     * Checks if the given model has any field-level override policy guard for the given operation.
     */
    hasOverrideAuthGuard(model: string, operation: PolicyOperationKind): boolean;
    /**
     * Checks model creation policy based on static analysis to the input args.
     *
     * @returns boolean if static analysis is enough to determine the result, undefined if not
     */
    checkInputGuard(model: string, args: any, operation: 'create'): boolean | undefined;
    /**
     * Injects model auth guard as where clause.
     */
    injectAuthGuardAsWhere(db: CrudContract, args: any, model: string, operation: PolicyOperationKind): boolean;
    private injectGuardForRelationFields;
    private injectGuardForToManyField;
    private injectGuardForToOneField;
    /**
     * Injects auth guard for read operations.
     */
    injectForRead(db: CrudContract, model: string, args: any): boolean;
    /**
     * Gets checker constraints for the given model and operation.
     */
    getCheckerConstraint(model: string, operation: PolicyCrudKind): ReturnType<CheckerFunc> | boolean;
    private getModelChecker;
    /**
     * Gets unique constraints for the given model.
     */
    getUniqueConstraints(model: string): Record<string, import("../../cross").UniqueConstraint>;
    private injectNestedReadConditions;
    /**
     * Given a model and a unique filter, checks the operation is allowed by policies and field validations.
     * Rejects with an error if not allowed.
     */
    checkPolicyForUnique(model: string, uniqueFilter: any, operation: PolicyOperationKind, db: CrudContract, args: any, preValue?: any): Promise<void>;
    private getFieldReadGuards;
    private getFieldUpdateGuards;
    /**
     * Tries rejecting a request based on static "false" policy.
     */
    tryReject(db: CrudContract, model: string, operation: PolicyOperationKind): void;
    /**
     * Checks if a model exists given a unique filter.
     */
    checkExistence(db: CrudContract, model: string, uniqueFilter: any, throwIfNotFound?: boolean): Promise<any>;
    /**
     * Returns an entity given a unique filter with read policy checked. Reject if not readable.
     */
    readBack(db: CrudContract, model: string, operation: PolicyOperationKind, selectInclude: {
        select?: any;
        include?: any;
    }, uniqueFilter: any): Promise<{
        result: unknown;
        error?: Error;
    }>;
    /**
     * Injects field selection needed for checking field-level read policy into query args.
     * @returns
     */
    injectReadCheckSelect(model: string, args: any): void;
    private doInjectReadCheckSelect;
    private makeAllScalarFieldSelect;
    deniedByPolicy(model: string, operation: PolicyOperationKind, extra?: string, reason?: CrudFailureReason, zodErrors?: ZodError): Error;
    notFound(model: string): Error;
    /**
     * Gets field selection for fetching pre-update entity values for the given model.
     */
    getPreValueSelect(model: string): object | undefined;
    private getReadFieldSelect;
    private checkReadField;
    private hasFieldValidation;
    private hasFieldLevelPolicy;
    /**
     * Gets Zod schema for the given model and access kind.
     *
     * @param kind If undefined, returns the full schema.
     */
    getZodSchema(model: string, kind?: 'create' | 'update' | undefined): import("zod").ZodType<any, import("zod").ZodTypeDef, any> | undefined;
    /**
     * Post processing checks and clean-up for read model entities.
     */
    postProcessForRead(data: any, model: string, queryArgs: any): void;
    private doPostProcessForRead;
    /**
     * Clones an object and makes sure it's not empty.
     */
    clone(value: unknown): any;
    /**
     * Replace content of `target` object with `withObject` in-place.
     */
    replace(target: any, withObject: any): void;
    /**
     * Picks properties from an object.
     */
    pick<T>(value: T, ...props: (keyof T)[]): Pick<T, (typeof props)[number]>;
    private mergeWhereClause;
    private requireGuard;
    /**
     * Given an entity data, returns an object only containing id fields.
     */
    getIdFieldValues(model: string, data: any): {
        [k: string]: any;
    } | undefined;
}
