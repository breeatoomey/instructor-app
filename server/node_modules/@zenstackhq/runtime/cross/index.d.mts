/**
 * Callback for @see ModelDataVisitor.
 */
type ModelDataVisitorCallback = (model: string, data: any, scalarData: any) => void;
/**
 * Visitor that traverses data returned by a Prisma query.
 */
declare class ModelDataVisitor {
    private modelMeta;
    constructor(modelMeta: ModelMeta);
    /**
     * Visits the given model data.
     */
    visit(model: string, data: any, callback: ModelDataVisitorCallback): void;
}

/**
 * Runtime information of a data model or field attribute
 */
type RuntimeAttribute = {
    /**
     * Attribute name
     */
    name: string;
    /**
     * Attribute arguments
     */
    args: Array<{
        name?: string;
        value: unknown;
    }>;
};
/**
 * Function for computing default value for a field
 */
type FieldDefaultValueProvider = (userContext: unknown) => unknown;
/**
 * Runtime information of a data model field
 */
type FieldInfo = {
    /**
     * Field name
     */
    name: string;
    /**
     * Field type name
     */
    type: string;
    /**
     * If the field is an ID field or part of a multi-field ID
     */
    isId?: boolean;
    /**
     * If the field type is a data model (or an optional/array of data model)
     */
    isDataModel?: boolean;
    /**
     * If the field is an array
     */
    isArray?: boolean;
    /**
     * If the field is optional
     */
    isOptional?: boolean;
    /**
     * Attributes on the field
     */
    attributes?: RuntimeAttribute[];
    /**
     * If the field is a relation field, the field name of the reverse side of the relation
     */
    backLink?: string;
    /**
     * If the field is the owner side of a relation
     */
    isRelationOwner?: boolean;
    /**
     * If the field is a foreign key field
     */
    isForeignKey?: boolean;
    /**
     * If the field is a foreign key field, the field name of the corresponding relation field.
     * Only available on foreign key fields.
     */
    relationField?: string;
    /**
     * Mapping from foreign key field names to relation field names.
     * Only available on relation fields.
     */
    foreignKeyMapping?: Record<string, string>;
    /**
     * Model from which the field is inherited
     */
    inheritedFrom?: string;
    /**
     * A function that provides a default value for the field
     */
    defaultValueProvider?: FieldDefaultValueProvider;
    /**
     * If the field is an auto-increment field
     */
    isAutoIncrement?: boolean;
};
/**
 * Metadata for a model-level unique constraint
 * e.g.: @@unique([a, b])
 */
type UniqueConstraint = {
    name: string;
    fields: string[];
};
/**
 * Metadata for a data model
 */
type ModelInfo = {
    /**
     * Model name
     */
    name: string;
    /**
     * Base types (not including abstract base models).
     */
    baseTypes?: string[];
    /**
     * Fields
     */
    fields: Record<string, FieldInfo>;
    /**
     * Unique constraints
     */
    uniqueConstraints?: Record<string, UniqueConstraint>;
    /**
     * Attributes on the model
     */
    attributes?: RuntimeAttribute[];
    /**
     * Discriminator field name
     */
    discriminator?: string;
};
/**
 * ZModel data model metadata
 */
type ModelMeta = {
    /**
     * Data models
     */
    models: Record<string, ModelInfo>;
    /**
     * Mapping from model name to models that will be deleted because of it due to cascade delete
     */
    deleteCascade?: Record<string, string[]>;
    /**
     * Name of model that backs the `auth()` function
     */
    authModel?: string;
};
/**
 * Resolves a model field to its metadata. Returns undefined if not found.
 */
declare function resolveField(modelMeta: ModelMeta, model: string, field: string): FieldInfo | undefined;
/**
 * Resolves a model field to its metadata. Throws an error if not found.
 */
declare function requireField(modelMeta: ModelMeta, model: string, field: string): FieldInfo;
/**
 * Gets all fields of a model.
 */
declare function getFields(modelMeta: ModelMeta, model: string): Record<string, FieldInfo>;
/**
 * Gets unique constraints of a model.
 */
declare function getUniqueConstraints(modelMeta: ModelMeta, model: string): Record<string, UniqueConstraint> | undefined;

/**
 * Tries to apply a mutation to a query result.
 *
 * @param queryModel the model of the query
 * @param queryOp the operation of the query
 * @param queryData the result data of the query
 * @param mutationModel the model of the mutation
 * @param mutationOp the operation of the mutation
 * @param mutationArgs the arguments of the mutation
 * @param modelMeta the model metadata
 * @param logging whether to log the mutation application
 * @returns the updated query data if the mutation is applicable, otherwise undefined
 */
declare function applyMutation(queryModel: string, queryOp: string, queryData: any, mutationModel: string, mutationOp: PrismaWriteActionType, mutationArgs: any, modelMeta: ModelMeta, logging: boolean): Promise<any>;

type NestedReadVisitorCallback = {
    field?: (model: string, field: FieldInfo | undefined, kind: 'include' | 'select' | undefined, args: unknown) => void | boolean;
};
/**
 * Visitor for nested read payload.
 */
declare class NestedReadVisitor {
    private readonly modelMeta;
    private readonly callback;
    constructor(modelMeta: ModelMeta, callback: NestedReadVisitorCallback);
    doVisit(model: string, field: FieldInfo | undefined, kind: 'include' | 'select' | undefined, args: unknown): void;
    visit(model: string, args: unknown): void;
}

/**
 * Prisma write operation kinds
 */
declare const PrismaWriteActions: readonly ["create", "createMany", "connectOrCreate", "update", "updateMany", "upsert", "connect", "disconnect", "set", "delete", "deleteMany"];
/**
 * Prisma write operation kinds
 */
type PrismaWriteActionType = (typeof PrismaWriteActions)[number];
/**
 * Maybe promise
 */
type MaybePromise<T> = T | Promise<T> | PromiseLike<T>;

type NestingPathItem = {
    field?: FieldInfo;
    model: string;
    where: any;
    unique: boolean;
};
/**
 * Context for visiting
 */
type NestedWriteVisitorContext = {
    /**
     * Parent data, can be used to replace fields
     */
    parent: any;
    /**
     * Current field, undefined if toplevel
     */
    field?: FieldInfo;
    /**
     * A top-down path of all nested update conditions and corresponding field till now
     */
    nestingPath: NestingPathItem[];
};
/**
 * NestedWriteVisitor's callback actions. A call back function should return true or void to indicate
 * that the visitor should continue traversing its children, or false to stop. It can also return an object
 * to let the visitor traverse it instead of its original children.
 */
type NestedWriterVisitorCallback = {
    create?: (model: string, data: any, context: NestedWriteVisitorContext) => MaybePromise<boolean | object | void>;
    createMany?: (model: string, args: {
        data: any;
        skipDuplicates?: boolean;
    }, context: NestedWriteVisitorContext) => MaybePromise<boolean | object | void>;
    connectOrCreate?: (model: string, args: {
        where: object;
        create: any;
    }, context: NestedWriteVisitorContext) => MaybePromise<boolean | object | void>;
    connect?: (model: string, args: object, context: NestedWriteVisitorContext) => MaybePromise<boolean | object | void>;
    disconnect?: (model: string, args: object, context: NestedWriteVisitorContext) => MaybePromise<boolean | object | void>;
    set?: (model: string, args: object, context: NestedWriteVisitorContext) => MaybePromise<boolean | object | void>;
    update?: (model: string, args: object, context: NestedWriteVisitorContext) => MaybePromise<boolean | object | void>;
    updateMany?: (model: string, args: {
        where?: object;
        data: any;
    }, context: NestedWriteVisitorContext) => MaybePromise<boolean | object | void>;
    upsert?: (model: string, args: {
        where: object;
        create: any;
        update: any;
    }, context: NestedWriteVisitorContext) => MaybePromise<boolean | object | void>;
    delete?: (model: string, args: object | boolean, context: NestedWriteVisitorContext) => MaybePromise<boolean | object | void>;
    deleteMany?: (model: string, args: any | object, context: NestedWriteVisitorContext) => MaybePromise<boolean | object | void>;
    field?: (field: FieldInfo, action: PrismaWriteActionType, data: any, context: NestedWriteVisitorContext) => MaybePromise<void>;
};
/**
 * Recursive visitor for nested write (create/update) payload.
 */
declare class NestedWriteVisitor {
    private readonly modelMeta;
    private readonly callback;
    constructor(modelMeta: ModelMeta, callback: NestedWriterVisitorCallback);
    private isPrismaWriteAction;
    /**
     * Start visiting
     *
     * @see NestedWriterVisitorCallback
     */
    visit(model: string, action: PrismaWriteActionType, args: any): Promise<void>;
    private doVisit;
    private visitSubPayload;
    private enumerateReverse;
}

/**
 * Gets models read (including nested ones) given a query args.
 * @param model
 * @param targetModels
 * @param modelMeta
 * @param args
 * @returns
 */
declare function getReadModels(model: string, modelMeta: ModelMeta, args: any): string[];
/**
 * Gets mutated models (including nested ones) given a mutation args.
 */
declare function getMutatedModels(model: string, operation: PrismaWriteActionType, mutationArgs: any, modelMeta: ModelMeta): Promise<string[]>;

/**
 * Gets field names in a data model entity, filtering out internal fields.
 */
declare function getModelFields(data: object): string[];
/**
 * Array or scalar
 */
type Enumerable<T> = T | Array<T>;
/**
 * Uniformly enumerates an array or scalar.
 */
declare function enumerate<T>(x: Enumerable<T>): T[];
/**
 * Zip two arrays or scalars.
 */
declare function zip<T1, T2>(x: Enumerable<T1>, y: Enumerable<T2>): Array<[T1, T2]>;
declare function getIdFields(modelMeta: ModelMeta, model: string, throwIfNotFound?: boolean): FieldInfo[];
declare function getModelInfo<Throw extends boolean = false>(modelMeta: ModelMeta, model: string, throwIfNotFound?: Throw): Throw extends true ? ModelInfo : ModelInfo | undefined;
declare function isDelegateModel(modelMeta: ModelMeta, model: string): boolean;

export { type Enumerable, type FieldDefaultValueProvider, type FieldInfo, type MaybePromise, ModelDataVisitor, type ModelDataVisitorCallback, type ModelInfo, type ModelMeta, NestedReadVisitor, type NestedReadVisitorCallback, NestedWriteVisitor, type NestedWriteVisitorContext, type NestedWriterVisitorCallback, type PrismaWriteActionType, PrismaWriteActions, type RuntimeAttribute, type UniqueConstraint, applyMutation, enumerate, getFields, getIdFields, getModelFields, getModelInfo, getMutatedModels, getReadModels, getUniqueConstraints, isDelegateModel, requireField, resolveField, zip };
