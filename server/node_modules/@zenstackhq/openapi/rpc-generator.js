"use strict";
// Inspired by: https://github.com/omar-dulaimi/prisma-trpc-generator
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RPCOpenAPIGenerator = void 0;
const sdk_1 = require("@zenstackhq/sdk");
const ast_1 = require("@zenstackhq/sdk/ast");
const dmmf_helpers_1 = require("@zenstackhq/sdk/dmmf-helpers");
const prisma_1 = require("@zenstackhq/sdk/prisma");
const fs = __importStar(require("fs"));
const lower_case_first_1 = require("lower-case-first");
const path = __importStar(require("path"));
const tiny_invariant_1 = __importDefault(require("tiny-invariant"));
const ts_pattern_1 = require("ts-pattern");
const upper_case_first_1 = require("upper-case-first");
const yaml_1 = __importDefault(require("yaml"));
const _1 = require(".");
const generator_base_1 = require("./generator-base");
const meta_1 = require("./meta");
/**
 * Generates OpenAPI specification.
 */
class RPCOpenAPIGenerator extends generator_base_1.OpenAPIGeneratorBase {
    constructor() {
        super(...arguments);
        this.inputObjectTypes = [];
        this.outputObjectTypes = [];
        this.usedComponents = new Set();
        this.warnings = [];
    }
    generate() {
        let output = (0, sdk_1.requireOption)(this.options, 'output', _1.name);
        output = (0, sdk_1.resolvePath)(output, this.options);
        // input types
        this.inputObjectTypes.push(...this.dmmf.schema.inputObjectTypes.prisma);
        this.outputObjectTypes.push(...this.dmmf.schema.outputObjectTypes.prisma);
        // add input object types that are missing from Prisma dmmf
        (0, dmmf_helpers_1.addMissingInputObjectTypesForModelArgs)(this.inputObjectTypes, this.dmmf.datamodel.models);
        (0, dmmf_helpers_1.addMissingInputObjectTypesForInclude)(this.inputObjectTypes, this.dmmf.datamodel.models);
        (0, dmmf_helpers_1.addMissingInputObjectTypesForSelect)(this.inputObjectTypes, this.outputObjectTypes, this.dmmf.datamodel.models);
        (0, dmmf_helpers_1.addMissingInputObjectTypesForAggregate)(this.inputObjectTypes, this.outputObjectTypes);
        this.aggregateOperationSupport = (0, dmmf_helpers_1.resolveAggregateOperationSupport)(this.inputObjectTypes);
        const components = this.generateComponents();
        const paths = this.generatePaths(components);
        // generate security schemes, and root-level security
        components.securitySchemes = this.generateSecuritySchemes();
        let security = undefined;
        if (components.securitySchemes && Object.keys(components.securitySchemes).length > 0) {
            security = Object.keys(components.securitySchemes).map((scheme) => ({ [scheme]: [] }));
        }
        // prune unused component schemas
        this.pruneComponents(paths, components);
        const openapi = {
            openapi: this.getOption('specVersion', this.DEFAULT_SPEC_VERSION),
            info: {
                title: this.getOption('title', 'ZenStack Generated API'),
                version: this.getOption('version', '1.0.0'),
                description: this.getOption('description'),
                summary: this.getOption('summary'),
            },
            tags: this.includedModels.map((model) => {
                var _a;
                const meta = (0, meta_1.getModelResourceMeta)(model);
                return {
                    name: (0, lower_case_first_1.lowerCaseFirst)(model.name),
                    description: (_a = meta === null || meta === void 0 ? void 0 : meta.tagDescription) !== null && _a !== void 0 ? _a : `${model.name} operations`,
                };
            }),
            components,
            paths,
            security,
        };
        const ext = path.extname(output);
        if (ext && (ext.toLowerCase() === '.yaml' || ext.toLowerCase() === '.yml')) {
            fs.writeFileSync(output, yaml_1.default.stringify(openapi));
        }
        else {
            fs.writeFileSync(output, JSON.stringify(openapi, undefined, 2));
        }
        return { warnings: this.warnings };
    }
    generatePaths(components) {
        let result = {};
        for (const model of this.dmmf.datamodel.models) {
            const zmodel = this.model.declarations.find((d) => (0, ast_1.isDataModel)(d) && d.name === model.name);
            if (zmodel) {
                result = Object.assign(Object.assign({}, result), this.generatePathsForModel(model, zmodel, components));
            }
            else {
                this.warnings.push(`Unable to load ZModel definition for: ${model.name}}`);
            }
        }
        return result;
    }
    generatePathsForModel(model, zmodel, components) {
        var _a, _b, _c, _d, _e;
        const result = {};
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const ops = this.dmmf.mappings.modelOperations.find((ops) => ops.model === model.name);
        if (!ops) {
            this.warnings.push(`Unable to find mapping for model ${model.name}`);
            return undefined;
        }
        const modelName = (0, upper_case_first_1.upperCaseFirst)(model.name);
        const definitions = [];
        const hasRelation = zmodel.fields.some((f) => { var _a; return (0, ast_1.isDataModel)((_a = f.type.reference) === null || _a === void 0 ? void 0 : _a.ref); });
        // analyze access policies to determine default security
        const { create, read, update, delete: del } = (0, sdk_1.analyzePolicies)(zmodel);
        if (ops['createOne']) {
            definitions.push({
                method: 'post',
                operation: 'create',
                inputType: this.component(`${modelName}CreateArgs`, {
                    type: 'object',
                    required: ['data'],
                    properties: {
                        select: this.ref(`${modelName}Select`),
                        include: hasRelation ? this.ref(`${modelName}Include`) : undefined,
                        data: this.ref(`${modelName}CreateInput`),
                        meta: this.ref('_Meta'),
                    },
                }, components),
                outputType: this.response(this.ref(modelName)),
                description: `Create a new ${modelName}`,
                successCode: 201,
                security: create === true ? [] : undefined,
            });
        }
        if (ops['createMany'] && (0, prisma_1.supportCreateMany)(zmodel.$container)) {
            definitions.push({
                method: 'post',
                operation: 'createMany',
                inputType: this.component(`${modelName}CreateManyArgs`, {
                    type: 'object',
                    required: ['data'],
                    properties: {
                        data: this.oneOf(this.ref(`${modelName}CreateManyInput`), this.array(this.ref(`${modelName}CreateManyInput`))),
                        skipDuplicates: {
                            type: 'boolean',
                            description: 'Do not insert records with unique fields or ID fields that already exist.',
                        },
                        meta: this.ref('_Meta'),
                    },
                }, components),
                outputType: this.response(this.ref('BatchPayload')),
                description: `Create several ${modelName}`,
                successCode: 201,
                security: create === true ? [] : undefined,
            });
        }
        if (ops['findUnique']) {
            definitions.push({
                method: 'get',
                operation: 'findUnique',
                inputType: this.component(`${modelName}FindUniqueArgs`, {
                    type: 'object',
                    required: ['where'],
                    properties: {
                        select: this.ref(`${modelName}Select`),
                        include: hasRelation ? this.ref(`${modelName}Include`) : undefined,
                        where: this.ref(`${modelName}WhereUniqueInput`),
                        meta: this.ref('_Meta'),
                    },
                }, components),
                outputType: this.response(this.ref(modelName)),
                description: `Find one unique ${modelName}`,
                security: read === true ? [] : undefined,
            });
        }
        if (ops['findFirst']) {
            definitions.push({
                method: 'get',
                operation: 'findFirst',
                inputType: this.component(`${modelName}FindFirstArgs`, {
                    type: 'object',
                    properties: {
                        select: this.ref(`${modelName}Select`),
                        include: hasRelation ? this.ref(`${modelName}Include`) : undefined,
                        where: this.ref(`${modelName}WhereInput`),
                        meta: this.ref('_Meta'),
                    },
                }, components),
                outputType: this.response(this.ref(modelName)),
                description: `Find the first ${modelName} matching the given condition`,
                security: read === true ? [] : undefined,
            });
        }
        if (ops['findMany']) {
            definitions.push({
                method: 'get',
                operation: 'findMany',
                inputType: this.component(`${modelName}FindManyArgs`, {
                    type: 'object',
                    properties: {
                        select: this.ref(`${modelName}Select`),
                        include: hasRelation ? this.ref(`${modelName}Include`) : undefined,
                        where: this.ref(`${modelName}WhereInput`),
                        meta: this.ref('_Meta'),
                    },
                }, components),
                outputType: this.response(this.array(this.ref(modelName))),
                description: `Find a list of ${modelName}`,
                security: read === true ? [] : undefined,
            });
        }
        if (ops['updateOne']) {
            definitions.push({
                method: 'patch',
                operation: 'update',
                inputType: this.component(`${modelName}UpdateArgs`, {
                    type: 'object',
                    required: ['where', 'data'],
                    properties: {
                        select: this.ref(`${modelName}Select`),
                        include: hasRelation ? this.ref(`${modelName}Include`) : undefined,
                        where: this.ref(`${modelName}WhereUniqueInput`),
                        data: this.ref(`${modelName}UpdateInput`),
                        meta: this.ref('_Meta'),
                    },
                }, components),
                outputType: this.response(this.ref(modelName)),
                description: `Update a ${modelName}`,
                security: update === true ? [] : undefined,
            });
        }
        if (ops['updateMany']) {
            definitions.push({
                operation: 'updateMany',
                method: 'patch',
                inputType: this.component(`${modelName}UpdateManyArgs`, {
                    type: 'object',
                    required: ['data'],
                    properties: {
                        where: this.ref(`${modelName}WhereInput`),
                        data: this.ref(`${modelName}UpdateManyMutationInput`),
                        meta: this.ref('_Meta'),
                    },
                }, components),
                outputType: this.response(this.ref('BatchPayload')),
                description: `Update ${modelName}s matching the given condition`,
                security: update === true ? [] : undefined,
            });
        }
        if (ops['upsertOne']) {
            definitions.push({
                method: 'post',
                operation: 'upsert',
                inputType: this.component(`${modelName}UpsertArgs`, {
                    type: 'object',
                    required: ['create', 'update', 'where'],
                    properties: {
                        select: this.ref(`${modelName}Select`),
                        include: hasRelation ? this.ref(`${modelName}Include`) : undefined,
                        where: this.ref(`${modelName}WhereUniqueInput`),
                        create: this.ref(`${modelName}CreateInput`),
                        update: this.ref(`${modelName}UpdateInput`),
                        meta: this.ref('_Meta'),
                    },
                }, components),
                outputType: this.response(this.ref(modelName)),
                description: `Upsert a ${modelName}`,
                security: create === true && update == true ? [] : undefined,
            });
        }
        if (ops['deleteOne']) {
            definitions.push({
                method: 'delete',
                operation: 'delete',
                inputType: this.component(`${modelName}DeleteUniqueArgs`, {
                    type: 'object',
                    required: ['where'],
                    properties: {
                        select: this.ref(`${modelName}Select`),
                        include: hasRelation ? this.ref(`${modelName}Include`) : undefined,
                        where: this.ref(`${modelName}WhereUniqueInput`),
                        meta: this.ref('_Meta'),
                    },
                }, components),
                outputType: this.response(this.ref(modelName)),
                description: `Delete one unique ${modelName}`,
                security: del === true ? [] : undefined,
            });
        }
        if (ops['deleteMany']) {
            definitions.push({
                method: 'delete',
                operation: 'deleteMany',
                inputType: this.component(`${modelName}DeleteManyArgs`, {
                    type: 'object',
                    properties: {
                        where: this.ref(`${modelName}WhereInput`),
                        meta: this.ref('_Meta'),
                    },
                }, components),
                outputType: this.response(this.ref('BatchPayload')),
                description: `Delete ${modelName}s matching the given condition`,
                security: del === true ? [] : undefined,
            });
        }
        // somehow dmmf doesn't contain "count" operation, so we unconditionally add it here
        definitions.push({
            method: 'get',
            operation: 'count',
            inputType: this.component(`${modelName}CountArgs`, {
                type: 'object',
                properties: {
                    select: this.ref(`${modelName}Select`),
                    where: this.ref(`${modelName}WhereInput`),
                    meta: this.ref('_Meta'),
                },
            }, components),
            outputType: this.response(this.oneOf({ type: 'integer' }, this.ref(`${modelName}CountAggregateOutputType`))),
            description: `Find a list of ${modelName}`,
            security: read === true ? [] : undefined,
        });
        // OrderByWithRelationInput's name is different when "fullTextSearch" is enabled
        const orderByWithRelationInput = this.inputObjectTypes
            .map((o) => (0, upper_case_first_1.upperCaseFirst)(o.name))
            .includes(`${modelName}OrderByWithRelationInput`)
            ? `${modelName}OrderByWithRelationInput`
            : `${modelName}OrderByWithRelationAndSearchRelevanceInput`;
        if (ops['aggregate']) {
            definitions.push({
                method: 'get',
                operation: 'aggregate',
                inputType: this.component(`${modelName}AggregateArgs`, {
                    type: 'object',
                    properties: Object.assign(Object.assign({ where: this.ref(`${modelName}WhereInput`), orderBy: this.ref(orderByWithRelationInput), cursor: this.ref(`${modelName}WhereUniqueInput`), take: { type: 'integer' }, skip: { type: 'integer' } }, this.aggregateFields(model)), { meta: this.ref('_Meta') }),
                }, components),
                outputType: this.response(this.ref(`Aggregate${modelName}`)),
                description: `Aggregate ${modelName}s`,
                security: read === true ? [] : undefined,
            });
        }
        if (ops['groupBy']) {
            definitions.push({
                method: 'get',
                operation: 'groupBy',
                inputType: this.component(`${modelName}GroupByArgs`, {
                    type: 'object',
                    properties: Object.assign(Object.assign({ where: this.ref(`${modelName}WhereInput`), orderBy: this.ref(orderByWithRelationInput), by: this.ref(`${modelName}ScalarFieldEnum`), having: this.ref(`${modelName}ScalarWhereWithAggregatesInput`), take: { type: 'integer' }, skip: { type: 'integer' } }, this.aggregateFields(model)), { meta: this.ref('_Meta') }),
                }, components),
                outputType: this.response(this.array(this.ref(`${modelName}GroupByOutputType`))),
                description: `Group ${modelName}s by fields`,
                security: read === true ? [] : undefined,
            });
        }
        // get meta specified with @@openapi.meta
        const resourceMeta = (0, meta_1.getModelResourceMeta)(zmodel);
        for (const { method, operation, description, inputType, outputType, successCode, security } of definitions) {
            const meta = resourceMeta === null || resourceMeta === void 0 ? void 0 : resourceMeta[operation];
            if ((meta === null || meta === void 0 ? void 0 : meta.ignore) === true) {
                continue;
            }
            const resolvedMethod = (_a = meta === null || meta === void 0 ? void 0 : meta.method) !== null && _a !== void 0 ? _a : method;
            let resolvedPath = (_b = meta === null || meta === void 0 ? void 0 : meta.path) !== null && _b !== void 0 ? _b : operation;
            if (resolvedPath.startsWith('/')) {
                resolvedPath = resolvedPath.substring(1);
            }
            let prefix = this.getOption('prefix', '');
            if (prefix.endsWith('/')) {
                prefix = prefix.substring(0, prefix.length - 1);
            }
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const def = {
                operationId: `${operation}${modelName}`,
                description: (_c = meta === null || meta === void 0 ? void 0 : meta.description) !== null && _c !== void 0 ? _c : description,
                tags: (meta === null || meta === void 0 ? void 0 : meta.tags) || [(0, lower_case_first_1.lowerCaseFirst)(model.name)],
                summary: meta === null || meta === void 0 ? void 0 : meta.summary,
                // security priority: operation-level > model-level > inferred
                security: (_e = (_d = meta === null || meta === void 0 ? void 0 : meta.security) !== null && _d !== void 0 ? _d : resourceMeta === null || resourceMeta === void 0 ? void 0 : resourceMeta.security) !== null && _e !== void 0 ? _e : security,
                deprecated: meta === null || meta === void 0 ? void 0 : meta.deprecated,
                responses: {
                    [successCode !== undefined ? successCode : '200']: {
                        description: 'Successful operation',
                        content: {
                            'application/json': {
                                schema: outputType,
                            },
                        },
                    },
                    '400': {
                        content: {
                            'application/json': {
                                schema: this.ref('_Error'),
                            },
                        },
                        description: 'Invalid request',
                    },
                    '403': {
                        content: {
                            'application/json': {
                                schema: this.ref('_Error'),
                            },
                        },
                        description: 'Request is forbidden',
                    },
                    '422': {
                        content: {
                            'application/json': {
                                schema: this.ref('_Error'),
                            },
                        },
                        description: 'Request is unprocessable due to validation errors',
                    },
                },
            };
            if (inputType) {
                if (['post', 'put', 'patch'].includes(resolvedMethod)) {
                    def.requestBody = {
                        content: {
                            'application/json': {
                                schema: inputType,
                            },
                        },
                    };
                }
                else {
                    def.parameters = [
                        {
                            name: 'q',
                            in: 'query',
                            required: true,
                            description: 'Superjson-serialized Prisma query object',
                            content: {
                                'application/json': {
                                    schema: inputType,
                                },
                            },
                        },
                        {
                            name: 'meta',
                            in: 'query',
                            description: 'Superjson serialization metadata for parameter "q"',
                            content: {
                                'application/json': {
                                    schema: {},
                                },
                            },
                        },
                    ];
                }
            }
            const includeModelNames = this.includedModels.map((d) => d.name);
            if (includeModelNames.includes(model.name)) {
                result[`${prefix}/${(0, lower_case_first_1.lowerCaseFirst)(model.name)}/${resolvedPath}`] = {
                    [resolvedMethod]: def,
                };
            }
        }
        return result;
    }
    aggregateFields(model) {
        const result = {};
        const supportedOps = this.aggregateOperationSupport[model.name];
        const modelName = (0, upper_case_first_1.upperCaseFirst)(model.name);
        if (supportedOps) {
            if (supportedOps.count) {
                result._count = this.oneOf({ type: 'boolean' }, this.ref(`${modelName}CountAggregateInput`));
            }
            if (supportedOps.min) {
                result._min = this.ref(`${modelName}MinAggregateInput`);
            }
            if (supportedOps.max) {
                result._max = this.ref(`${modelName}MaxAggregateInput`);
            }
            if (supportedOps.sum) {
                result._sum = this.ref(`${modelName}SumAggregateInput`);
            }
            if (supportedOps.avg) {
                result._avg = this.ref(`${modelName}AvgAggregateInput`);
            }
        }
        return result;
    }
    component(name, def, components) {
        (0, tiny_invariant_1.default)(components.schemas);
        components.schemas[name] = def;
        return this.ref(name);
    }
    generateComponents() {
        var _a;
        const schemas = {};
        const components = {
            schemas,
        };
        // user-defined and built-in enums
        for (const _enum of [...((_a = this.dmmf.schema.enumTypes.model) !== null && _a !== void 0 ? _a : []), ...this.dmmf.schema.enumTypes.prisma]) {
            schemas[(0, upper_case_first_1.upperCaseFirst)(_enum.name)] = this.generateEnumComponent(_enum);
        }
        // data models
        for (const model of this.dmmf.datamodel.models) {
            schemas[(0, upper_case_first_1.upperCaseFirst)(model.name)] = this.generateEntityComponent(model);
        }
        for (const input of this.inputObjectTypes) {
            schemas[(0, upper_case_first_1.upperCaseFirst)(input.name)] = this.generateInputComponent(input);
        }
        for (const output of this.outputObjectTypes.filter((t) => !['Query', 'Mutation'].includes(t.name))) {
            schemas[(0, upper_case_first_1.upperCaseFirst)(output.name)] = this.generateOutputComponent(output);
        }
        schemas['_Meta'] = {
            type: 'object',
            properties: {
                meta: {
                    type: 'object',
                    description: 'Meta information about the request or response',
                    properties: {
                        serialization: {
                            description: 'Serialization metadata',
                        },
                    },
                    additionalProperties: true,
                },
            },
        };
        schemas['_Error'] = {
            type: 'object',
            required: ['error'],
            properties: {
                error: {
                    type: 'object',
                    required: ['message'],
                    properties: {
                        prisma: {
                            type: 'boolean',
                            description: 'Indicates if the error occurred during a Prisma call',
                        },
                        rejectedByPolicy: {
                            type: 'boolean',
                            description: 'Indicates if the error was due to rejection by a policy',
                        },
                        code: {
                            type: 'string',
                            description: 'Prisma error code. Only available when "prisma" field is true.',
                        },
                        message: {
                            type: 'string',
                            description: 'Error message',
                        },
                        reason: {
                            type: 'string',
                            description: 'Detailed error reason',
                        },
                        zodErrors: {
                            type: 'object',
                            additionalProperties: true,
                            description: 'Zod validation errors if the error is due to data validation failure',
                        },
                    },
                    additionalProperties: true,
                },
            },
        };
        // misc types
        schemas['BatchPayload'] = {
            type: 'object',
            properties: {
                count: { type: 'integer' },
            },
        };
        return components;
    }
    generateEnumComponent(_enum) {
        const schema = {
            type: 'string',
            enum: _enum.values,
        };
        return schema;
    }
    generateEntityComponent(model) {
        const properties = {};
        const required = [];
        for (const field of model.fields) {
            properties[field.name] = this.generateField(field);
            if (field.isRequired && !(field.relationName && field.isList)) {
                required.push(field.name);
            }
        }
        const result = { type: 'object', properties };
        if (required.length > 0) {
            result.required = required;
        }
        return result;
    }
    generateField(def) {
        switch (def.kind) {
            case 'scalar':
                return this.wrapArray(this.prismaTypeToOpenAPIType(def.type, !def.isRequired), def.isList);
            case 'enum':
            case 'object':
                return this.wrapArray(this.wrapNullable(this.ref(def.type, false), !def.isRequired), def.isList);
            default:
                throw new sdk_1.PluginError(_1.name, `Unsupported field kind: ${def.kind}`);
        }
    }
    generateInputComponent(input) {
        const properties = {};
        for (const field of input.fields) {
            const options = field.inputTypes
                .filter((f) => f.type !== 'Null' &&
                // fieldRefTypes refer to other fields in the model and don't need to be generated as part of schema
                f.location !== 'fieldRefTypes')
                .map((f) => {
                return this.wrapArray(this.prismaTypeToOpenAPIType(f.type, false), f.isList);
            });
            let prop = options.length > 1 ? { oneOf: options } : options[0];
            // if types include 'Null', make it nullable
            prop = this.wrapNullable(prop, field.inputTypes.some((f) => f.type === 'Null'));
            properties[field.name] = prop;
        }
        const result = { type: 'object', properties };
        this.setInputRequired(input.fields, result);
        return result;
    }
    generateOutputComponent(output) {
        const properties = {};
        for (const field of output.fields) {
            let outputType;
            switch (field.outputType.location) {
                case 'scalar':
                case 'enumTypes':
                    outputType = this.prismaTypeToOpenAPIType(field.outputType.type, !!field.isNullable);
                    break;
                case 'outputObjectTypes':
                    outputType = this.prismaTypeToOpenAPIType(field.outputType.type, !!field.isNullable);
                    break;
            }
            field.outputType;
            properties[field.name] = this.wrapArray(outputType, field.outputType.isList);
        }
        const result = { type: 'object', properties };
        this.setOutputRequired(output.fields, result);
        return result;
    }
    setInputRequired(fields, result) {
        const required = fields.filter((f) => f.isRequired).map((f) => f.name);
        if (required.length > 0) {
            result.required = required;
        }
    }
    setOutputRequired(fields, result) {
        const required = fields.filter((f) => f.isNullable !== true).map((f) => f.name);
        if (required.length > 0) {
            result.required = required;
        }
    }
    prismaTypeToOpenAPIType(type, nullable) {
        const result = (0, ts_pattern_1.match)(type)
            .with('String', () => ({ type: 'string' }))
            .with(ts_pattern_1.P.union('Int', 'BigInt'), () => ({ type: 'integer' }))
            .with('Float', () => ({ type: 'number' }))
            .with('Decimal', () => this.oneOf({ type: 'string' }, { type: 'number' }))
            .with(ts_pattern_1.P.union('Boolean', 'True'), () => ({ type: 'boolean' }))
            .with('DateTime', () => ({ type: 'string', format: 'date-time' }))
            .with('Bytes', () => ({ type: 'string', format: 'byte' }))
            .with(ts_pattern_1.P.union('JSON', 'Json'), () => ({}))
            .otherwise((type) => this.ref(type.toString(), false));
        return this.wrapNullable(result, nullable);
    }
    ref(type, rooted = true, description) {
        if (rooted) {
            this.usedComponents.add(type);
        }
        return { $ref: `#/components/schemas/${(0, upper_case_first_1.upperCaseFirst)(type)}`, description };
    }
    response(schema) {
        return {
            type: 'object',
            required: ['data'],
            properties: {
                data: Object.assign(Object.assign({}, schema), { description: 'The Prisma response data serialized with superjson' }),
                meta: this.ref('_Meta', true, 'The superjson serialization metadata for the "data" field'),
            },
        };
    }
}
exports.RPCOpenAPIGenerator = RPCOpenAPIGenerator;
//# sourceMappingURL=rpc-generator.js.map