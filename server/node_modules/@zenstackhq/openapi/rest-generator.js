"use strict";
// Inspired by: https://github.com/omar-dulaimi/prisma-trpc-generator
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RESTfulOpenAPIGenerator = void 0;
const sdk_1 = require("@zenstackhq/sdk");
const ast_1 = require("@zenstackhq/sdk/ast");
const fs_1 = __importDefault(require("fs"));
const lower_case_first_1 = require("lower-case-first");
const path_1 = __importDefault(require("path"));
const pluralize_1 = __importDefault(require("pluralize"));
const tiny_invariant_1 = __importDefault(require("tiny-invariant"));
const ts_pattern_1 = require("ts-pattern");
const yaml_1 = __importDefault(require("yaml"));
const _1 = require(".");
const generator_base_1 = require("./generator-base");
const meta_1 = require("./meta");
/**
 * Generates RESTful style OpenAPI specification.
 */
class RESTfulOpenAPIGenerator extends generator_base_1.OpenAPIGeneratorBase {
    constructor() {
        super(...arguments);
        this.warnings = [];
    }
    generate() {
        let output = (0, sdk_1.requireOption)(this.options, 'output', _1.name);
        output = (0, sdk_1.resolvePath)(output, this.options);
        const components = this.generateComponents();
        const paths = this.generatePaths();
        // prune unused component schemas
        this.pruneComponents(paths, components);
        // generate security schemes, and root-level security
        components.securitySchemes = this.generateSecuritySchemes();
        let security = undefined;
        if (components.securitySchemes && Object.keys(components.securitySchemes).length > 0) {
            security = Object.keys(components.securitySchemes).map((scheme) => ({ [scheme]: [] }));
        }
        const openapi = {
            openapi: this.getOption('specVersion', this.DEFAULT_SPEC_VERSION),
            info: {
                title: this.getOption('title', 'ZenStack Generated API'),
                version: this.getOption('version', '1.0.0'),
                description: this.getOption('description'),
                summary: this.getOption('summary'),
            },
            tags: this.includedModels.map((model) => {
                var _a;
                const meta = (0, meta_1.getModelResourceMeta)(model);
                return {
                    name: (0, lower_case_first_1.lowerCaseFirst)(model.name),
                    description: (_a = meta === null || meta === void 0 ? void 0 : meta.tagDescription) !== null && _a !== void 0 ? _a : `${model.name} operations`,
                };
            }),
            paths,
            components,
            security,
        };
        const ext = path_1.default.extname(output);
        if (ext && (ext.toLowerCase() === '.yaml' || ext.toLowerCase() === '.yml')) {
            fs_1.default.writeFileSync(output, yaml_1.default.stringify(openapi));
        }
        else {
            fs_1.default.writeFileSync(output, JSON.stringify(openapi, undefined, 2));
        }
        return { warnings: this.warnings };
    }
    generatePaths() {
        let result = {};
        const includeModelNames = this.includedModels.map((d) => d.name);
        for (const model of this.dmmf.datamodel.models) {
            if (includeModelNames.includes(model.name)) {
                const zmodel = this.model.declarations.find((d) => (0, ast_1.isDataModel)(d) && d.name === model.name);
                if (zmodel) {
                    result = Object.assign(Object.assign({}, result), this.generatePathsForModel(model, zmodel));
                }
                else {
                    this.warnings.push(`Unable to load ZModel definition for: ${model.name}}`);
                }
            }
        }
        return result;
    }
    generatePathsForModel(model, zmodel) {
        var _a;
        const result = {};
        // analyze access policies to determine default security
        const policies = (0, sdk_1.analyzePolicies)(zmodel);
        let prefix = this.getOption('prefix', '');
        if (prefix.endsWith('/')) {
            prefix = prefix.substring(0, prefix.length - 1);
        }
        const resourceMeta = (0, meta_1.getModelResourceMeta)(zmodel);
        // GET /resource
        // POST /resource
        result[`${prefix}/${(0, lower_case_first_1.lowerCaseFirst)(model.name)}`] = {
            get: this.makeResourceList(zmodel, policies, resourceMeta),
            post: this.makeResourceCreate(zmodel, policies, resourceMeta),
        };
        // GET /resource/{id}
        // PUT /resource/{id}
        // PATCH /resource/{id}
        // DELETE /resource/{id}
        result[`${prefix}/${(0, lower_case_first_1.lowerCaseFirst)(model.name)}/{id}`] = {
            get: this.makeResourceFetch(zmodel, policies, resourceMeta),
            put: this.makeResourceUpdate(zmodel, policies, `update-${model.name}-put`, resourceMeta),
            patch: this.makeResourceUpdate(zmodel, policies, `update-${model.name}-patch`, resourceMeta),
            delete: this.makeResourceDelete(zmodel, policies, resourceMeta),
        };
        // paths for related resources and relationships
        for (const field of zmodel.fields) {
            const relationDecl = (_a = field.type.reference) === null || _a === void 0 ? void 0 : _a.ref;
            if (!(0, ast_1.isDataModel)(relationDecl)) {
                continue;
            }
            // GET /resource/{id}/{relationship}
            const relatedDataPath = `${prefix}/${(0, lower_case_first_1.lowerCaseFirst)(model.name)}/{id}/${field.name}`;
            let container = result[relatedDataPath];
            if (!container) {
                container = result[relatedDataPath] = {};
            }
            container.get = this.makeRelatedFetch(zmodel, field, relationDecl, resourceMeta);
            const relationshipPath = `${prefix}/${(0, lower_case_first_1.lowerCaseFirst)(model.name)}/{id}/relationships/${field.name}`;
            container = result[relationshipPath];
            if (!container) {
                container = result[relationshipPath] = {};
            }
            // GET /resource/{id}/relationships/{relationship}
            container.get = this.makeRelationshipFetch(zmodel, field, policies, resourceMeta);
            // PUT /resource/{id}/relationships/{relationship}
            container.put = this.makeRelationshipUpdate(zmodel, field, policies, `update-${model.name}-relationship-${field.name}-put`, resourceMeta);
            // PATCH /resource/{id}/relationships/{relationship}
            container.patch = this.makeRelationshipUpdate(zmodel, field, policies, `update-${model.name}-relationship-${field.name}-patch`, resourceMeta);
            if (field.type.array) {
                // POST /resource/{id}/relationships/{relationship}
                container.post = this.makeRelationshipCreate(zmodel, field, policies, resourceMeta);
            }
        }
        return result;
    }
    makeResourceList(model, policies, resourceMeta) {
        var _a;
        return {
            operationId: `list-${model.name}`,
            description: `List "${model.name}" resources`,
            tags: [(0, lower_case_first_1.lowerCaseFirst)(model.name)],
            parameters: [
                this.parameter('include'),
                this.parameter('sort'),
                this.parameter('page-offset'),
                this.parameter('page-limit'),
                ...this.generateFilterParameters(model),
            ],
            responses: {
                '200': this.success(`${model.name}ListResponse`),
                '403': this.forbidden(),
            },
            security: ((_a = resourceMeta === null || resourceMeta === void 0 ? void 0 : resourceMeta.security) !== null && _a !== void 0 ? _a : policies.read === true) ? [] : undefined,
        };
    }
    makeResourceCreate(model, policies, resourceMeta) {
        var _a;
        return {
            operationId: `create-${model.name}`,
            description: `Create a "${model.name}" resource`,
            tags: [(0, lower_case_first_1.lowerCaseFirst)(model.name)],
            requestBody: {
                content: {
                    'application/vnd.api+json': {
                        schema: this.ref(`${model.name}CreateRequest`),
                    },
                },
            },
            responses: {
                '201': this.success(`${model.name}Response`),
                '403': this.forbidden(),
                '422': this.validationError(),
            },
            security: ((_a = resourceMeta === null || resourceMeta === void 0 ? void 0 : resourceMeta.security) !== null && _a !== void 0 ? _a : policies.create === true) ? [] : undefined,
        };
    }
    makeResourceFetch(model, policies, resourceMeta) {
        var _a;
        return {
            operationId: `fetch-${model.name}`,
            description: `Fetch a "${model.name}" resource`,
            tags: [(0, lower_case_first_1.lowerCaseFirst)(model.name)],
            parameters: [this.parameter('id'), this.parameter('include')],
            responses: {
                '200': this.success(`${model.name}Response`),
                '403': this.forbidden(),
                '404': this.notFound(),
            },
            security: ((_a = resourceMeta === null || resourceMeta === void 0 ? void 0 : resourceMeta.security) !== null && _a !== void 0 ? _a : policies.read === true) ? [] : undefined,
        };
    }
    makeRelatedFetch(model, field, relationDecl, resourceMeta) {
        var _a;
        const policies = (0, sdk_1.analyzePolicies)(relationDecl);
        const parameters = [this.parameter('id'), this.parameter('include')];
        if (field.type.array) {
            parameters.push(this.parameter('sort'), this.parameter('page-offset'), this.parameter('page-limit'), ...this.generateFilterParameters(model));
        }
        const result = {
            operationId: `fetch-${model.name}-related-${field.name}`,
            description: `Fetch the related "${field.name}" resource for "${model.name}"`,
            tags: [(0, lower_case_first_1.lowerCaseFirst)(model.name)],
            parameters,
            responses: {
                '200': this.success(field.type.array ? `${relationDecl.name}ListResponse` : `${relationDecl.name}Response`),
                '403': this.forbidden(),
                '404': this.notFound(),
            },
            security: ((_a = resourceMeta === null || resourceMeta === void 0 ? void 0 : resourceMeta.security) !== null && _a !== void 0 ? _a : policies.read === true) ? [] : undefined,
        };
        return result;
    }
    makeResourceUpdate(model, policies, operationId, resourceMeta) {
        var _a;
        return {
            operationId,
            description: `Update a "${model.name}" resource`,
            tags: [(0, lower_case_first_1.lowerCaseFirst)(model.name)],
            parameters: [this.parameter('id')],
            requestBody: {
                content: {
                    'application/vnd.api+json': {
                        schema: this.ref(`${model.name}UpdateRequest`),
                    },
                },
            },
            responses: {
                '200': this.success(`${model.name}Response`),
                '403': this.forbidden(),
                '404': this.notFound(),
                '422': this.validationError(),
            },
            security: ((_a = resourceMeta === null || resourceMeta === void 0 ? void 0 : resourceMeta.security) !== null && _a !== void 0 ? _a : policies.update === true) ? [] : undefined,
        };
    }
    makeResourceDelete(model, policies, resourceMeta) {
        var _a;
        return {
            operationId: `delete-${model.name}`,
            description: `Delete a "${model.name}" resource`,
            tags: [(0, lower_case_first_1.lowerCaseFirst)(model.name)],
            parameters: [this.parameter('id')],
            responses: {
                '200': this.success(),
                '403': this.forbidden(),
                '404': this.notFound(),
            },
            security: ((_a = resourceMeta === null || resourceMeta === void 0 ? void 0 : resourceMeta.security) !== null && _a !== void 0 ? _a : policies.delete === true) ? [] : undefined,
        };
    }
    makeRelationshipFetch(model, field, policies, resourceMeta) {
        var _a;
        const parameters = [this.parameter('id')];
        if (field.type.array) {
            parameters.push(this.parameter('sort'), this.parameter('page-offset'), this.parameter('page-limit'), ...this.generateFilterParameters(model));
        }
        return {
            operationId: `fetch-${model.name}-relationship-${field.name}`,
            description: `Fetch the "${field.name}" relationships for a "${model.name}"`,
            tags: [(0, lower_case_first_1.lowerCaseFirst)(model.name)],
            parameters,
            responses: {
                '200': field.type.array
                    ? this.success('_toManyRelationshipResponse')
                    : this.success('_toOneRelationshipResponse'),
                '403': this.forbidden(),
                '404': this.notFound(),
            },
            security: ((_a = resourceMeta === null || resourceMeta === void 0 ? void 0 : resourceMeta.security) !== null && _a !== void 0 ? _a : policies.read === true) ? [] : undefined,
        };
    }
    makeRelationshipCreate(model, field, policies, resourceMeta) {
        var _a;
        return {
            operationId: `create-${model.name}-relationship-${field.name}`,
            description: `Create new "${field.name}" relationships for a "${model.name}"`,
            tags: [(0, lower_case_first_1.lowerCaseFirst)(model.name)],
            parameters: [this.parameter('id')],
            requestBody: {
                content: {
                    'application/vnd.api+json': {
                        schema: this.ref('_toManyRelationshipRequest'),
                    },
                },
            },
            responses: {
                '200': this.success('_toManyRelationshipResponse'),
                '403': this.forbidden(),
                '404': this.notFound(),
            },
            security: ((_a = resourceMeta === null || resourceMeta === void 0 ? void 0 : resourceMeta.security) !== null && _a !== void 0 ? _a : policies.update === true) ? [] : undefined,
        };
    }
    makeRelationshipUpdate(model, field, policies, operationId, resourceMeta) {
        var _a;
        return {
            operationId,
            description: `Update "${field.name}" ${(0, pluralize_1.default)('relationship', field.type.array ? 2 : 1)} for a "${model.name}"`,
            tags: [(0, lower_case_first_1.lowerCaseFirst)(model.name)],
            parameters: [this.parameter('id')],
            requestBody: {
                content: {
                    'application/vnd.api+json': {
                        schema: field.type.array
                            ? this.ref('_toManyRelationshipRequest')
                            : this.ref('_toOneRelationshipRequest'),
                    },
                },
            },
            responses: {
                '200': field.type.array
                    ? this.success('_toManyRelationshipResponse')
                    : this.success('_toOneRelationshipResponse'),
                '403': this.forbidden(),
                '404': this.notFound(),
            },
            security: ((_a = resourceMeta === null || resourceMeta === void 0 ? void 0 : resourceMeta.security) !== null && _a !== void 0 ? _a : policies.update === true) ? [] : undefined,
        };
    }
    generateFilterParameters(model) {
        const result = [];
        for (const field of model.fields) {
            if ((0, sdk_1.isForeignKeyField)(field)) {
                // no filtering with foreign keys because one can filter
                // directly on the relationship
                continue;
            }
            if ((0, sdk_1.isIdField)(field)) {
                // id filter
                result.push(this.makeFilterParameter(field, 'id', 'Id filter'));
                continue;
            }
            // equality filter
            result.push(this.makeFilterParameter(field, '', 'Equality filter', field.type.array));
            if ((0, sdk_1.isRelationshipField)(field)) {
                // TODO: how to express nested filters?
                continue;
            }
            if (field.type.array) {
                // collection filters
                result.push(this.makeFilterParameter(field, '$has', 'Collection contains filter'));
                result.push(this.makeFilterParameter(field, '$hasEvery', 'Collection contains-all filter', true));
                result.push(this.makeFilterParameter(field, '$hasSome', 'Collection contains-any filter', true));
                result.push(this.makeFilterParameter(field, '$isEmpty', 'Collection is empty filter', false, {
                    type: 'boolean',
                }));
            }
            else {
                if (field.type.type && ['Int', 'BigInt', 'Float', 'Decimal', 'DateTime'].includes(field.type.type)) {
                    // comparison filters
                    result.push(this.makeFilterParameter(field, '$lt', 'Less-than filter'));
                    result.push(this.makeFilterParameter(field, '$lte', 'Less-than or equal filter'));
                    result.push(this.makeFilterParameter(field, '$gt', 'Greater-than filter'));
                    result.push(this.makeFilterParameter(field, '$gte', 'Greater-than or equal filter'));
                }
                if (field.type.type === 'String') {
                    result.push(this.makeFilterParameter(field, '$contains', 'String contains filter'));
                    result.push(this.makeFilterParameter(field, '$icontains', 'String case-insensitive contains filter'));
                    result.push(this.makeFilterParameter(field, '$search', 'String full-text search filter'));
                    result.push(this.makeFilterParameter(field, '$startsWith', 'String startsWith filter'));
                    result.push(this.makeFilterParameter(field, '$endsWith', 'String endsWith filter'));
                }
            }
        }
        return result;
    }
    makeFilterParameter(field, name, description, array = false, schemaOverride) {
        var _a;
        let schema;
        if (schemaOverride) {
            schema = schemaOverride;
        }
        else {
            const fieldDecl = (_a = field.type.reference) === null || _a === void 0 ? void 0 : _a.ref;
            if ((0, ast_1.isEnum)(fieldDecl)) {
                schema = this.ref(fieldDecl.name);
            }
            else if ((0, ast_1.isDataModel)(fieldDecl)) {
                schema = { type: 'string' };
            }
            else {
                (0, tiny_invariant_1.default)(field.type.type);
                schema = this.fieldTypeToOpenAPISchema(field.type);
            }
        }
        schema = this.wrapArray(schema, array);
        return {
            name: name === 'id' ? 'filter[id]' : `filter[${field.name}${name}]`,
            required: false,
            description: name === 'id' ? description : `${description} for "${field.name}"`,
            in: 'query',
            style: 'form',
            explode: false,
            schema,
        };
    }
    generateComponents() {
        const schemas = {};
        const parameters = {};
        const components = {
            schemas,
            parameters,
        };
        for (const [name, value] of Object.entries(this.generateSharedComponents())) {
            schemas[name] = value;
        }
        for (const [name, value] of Object.entries(this.generateParameters())) {
            parameters[name] = value;
        }
        for (const _enum of this.model.declarations.filter((d) => (0, ast_1.isEnum)(d))) {
            schemas[_enum.name] = this.generateEnumComponent(_enum);
        }
        // data models
        for (const model of (0, sdk_1.getDataModels)(this.model)) {
            for (const [name, value] of Object.entries(this.generateDataModelComponents(model))) {
                schemas[name] = value;
            }
        }
        return components;
    }
    generateSharedComponents() {
        return {
            _jsonapi: {
                type: 'object',
                description: 'An object describing the server’s implementation',
                required: ['version'],
                properties: {
                    version: { type: 'string' },
                },
            },
            _meta: {
                type: 'object',
                description: 'Meta information about the request or response',
                properties: {
                    serialization: {
                        description: 'Superjson serialization metadata',
                    },
                },
                additionalProperties: true,
            },
            _resourceIdentifier: {
                type: 'object',
                description: 'Identifier for a resource',
                required: ['type', 'id'],
                properties: {
                    type: { type: 'string', description: 'Resource type' },
                    id: { type: 'string', description: 'Resource id' },
                },
            },
            _resource: this.allOf(this.ref('_resourceIdentifier'), {
                type: 'object',
                description: 'A resource with attributes and relationships',
                properties: {
                    attributes: { type: 'object', description: 'Resource attributes' },
                    relationships: { type: 'object', description: 'Resource relationships' },
                },
            }),
            _links: {
                type: 'object',
                required: ['self'],
                description: 'Links related to the resource',
                properties: { self: { type: 'string', description: 'Link for refetching the curent results' } },
            },
            _pagination: {
                type: 'object',
                description: 'Pagination information',
                required: ['first', 'last', 'prev', 'next'],
                properties: {
                    first: this.wrapNullable({ type: 'string', description: 'Link to the first page' }, true),
                    last: this.wrapNullable({ type: 'string', description: 'Link to the last page' }, true),
                    prev: this.wrapNullable({ type: 'string', description: 'Link to the previous page' }, true),
                    next: this.wrapNullable({ type: 'string', description: 'Link to the next page' }, true),
                },
            },
            _errors: {
                type: 'array',
                description: 'An array of error objects',
                items: {
                    type: 'object',
                    required: ['status', 'code'],
                    properties: {
                        status: { type: 'string', description: 'HTTP status' },
                        code: { type: 'string', description: 'Error code' },
                        prismaCode: {
                            type: 'string',
                            description: 'Prisma error code if the error is thrown by Prisma',
                        },
                        title: { type: 'string', description: 'Error title' },
                        detail: { type: 'string', description: 'Error detail' },
                        reason: {
                            type: 'string',
                            description: 'Detailed error reason',
                        },
                        zodErrors: {
                            type: 'object',
                            additionalProperties: true,
                            description: 'Zod validation errors if the error is due to data validation failure',
                        },
                    },
                },
            },
            _errorResponse: {
                type: 'object',
                required: ['errors'],
                description: 'An error response',
                properties: {
                    jsonapi: this.ref('_jsonapi'),
                    errors: this.ref('_errors'),
                },
            },
            _relationLinks: {
                type: 'object',
                required: ['self', 'related'],
                description: 'Links related to a relationship',
                properties: {
                    self: { type: 'string', description: 'Link for fetching this relationship' },
                    related: {
                        type: 'string',
                        description: 'Link for fetching the resource represented by this relationship',
                    },
                },
            },
            _toOneRelationship: {
                type: 'object',
                description: 'A to-one relationship',
                properties: {
                    data: this.wrapNullable(this.ref('_resourceIdentifier'), true),
                },
            },
            _toOneRelationshipWithLinks: {
                type: 'object',
                required: ['links', 'data'],
                description: 'A to-one relationship with links',
                properties: {
                    links: this.ref('_relationLinks'),
                    data: this.wrapNullable(this.ref('_resourceIdentifier'), true),
                },
            },
            _toManyRelationship: {
                type: 'object',
                required: ['data'],
                description: 'A to-many relationship',
                properties: {
                    data: this.array(this.ref('_resourceIdentifier')),
                },
            },
            _toManyRelationshipWithLinks: {
                type: 'object',
                required: ['links', 'data'],
                description: 'A to-many relationship with links',
                properties: {
                    links: this.ref('_pagedRelationLinks'),
                    data: this.array(this.ref('_resourceIdentifier')),
                },
            },
            _pagedRelationLinks: Object.assign({ description: 'Relationship links with pagination information' }, this.allOf(this.ref('_pagination'), this.ref('_relationLinks'))),
            _toManyRelationshipRequest: {
                type: 'object',
                required: ['data'],
                description: 'Input for manipulating a to-many relationship',
                properties: {
                    data: {
                        type: 'array',
                        items: this.ref('_resourceIdentifier'),
                    },
                },
            },
            _toOneRelationshipRequest: Object.assign({ description: 'Input for manipulating a to-one relationship' }, this.wrapNullable({
                type: 'object',
                required: ['data'],
                properties: {
                    data: this.ref('_resourceIdentifier'),
                },
            }, true)),
            _toManyRelationshipResponse: Object.assign({ description: 'Response for a to-many relationship' }, this.allOf(this.ref('_toManyRelationshipWithLinks'), {
                type: 'object',
                properties: {
                    jsonapi: this.ref('_jsonapi'),
                },
            })),
            _toOneRelationshipResponse: Object.assign({ description: 'Response for a to-one relationship' }, this.allOf(this.ref('_toOneRelationshipWithLinks'), {
                type: 'object',
                properties: {
                    jsonapi: this.ref('_jsonapi'),
                },
            })),
        };
    }
    generateParameters() {
        return {
            id: {
                name: 'id',
                in: 'path',
                description: 'The resource id',
                required: true,
                schema: { type: 'string' },
            },
            include: {
                name: 'include',
                in: 'query',
                description: 'Relationships to include',
                required: false,
                style: 'form',
                schema: { type: 'string' },
            },
            sort: {
                name: 'sort',
                in: 'query',
                description: 'Fields to sort by',
                required: false,
                style: 'form',
                schema: { type: 'string' },
            },
            'page-offset': {
                name: 'page[offset]',
                in: 'query',
                description: 'Offset for pagination',
                required: false,
                style: 'form',
                schema: { type: 'integer' },
            },
            'page-limit': {
                name: 'page[limit]',
                in: 'query',
                description: 'Limit for pagination',
                required: false,
                style: 'form',
                schema: { type: 'integer' },
            },
        };
    }
    generateEnumComponent(_enum) {
        const schema = {
            type: 'string',
            description: `The "${_enum.name}" Enum`,
            enum: _enum.fields.map((f) => f.name),
        };
        return schema;
    }
    generateDataModelComponents(model) {
        const result = {};
        result[`${model.name}`] = this.generateModelEntity(model, 'read');
        result[`${model.name}CreateRequest`] = {
            type: 'object',
            description: `Input for creating a "${model.name}"`,
            required: ['data'],
            properties: {
                data: this.generateModelEntity(model, 'create'),
                meta: this.ref('_meta'),
            },
        };
        result[`${model.name}UpdateRequest`] = {
            type: 'object',
            description: `Input for updating a "${model.name}"`,
            required: ['data'],
            properties: { data: this.generateModelEntity(model, 'update'), meta: this.ref('_meta') },
        };
        const relationships = {};
        for (const field of model.fields) {
            if ((0, sdk_1.isRelationshipField)(field)) {
                if (field.type.array) {
                    relationships[field.name] = this.ref('_toManyRelationship');
                }
                else {
                    relationships[field.name] = this.ref('_toOneRelationship');
                }
            }
        }
        result[`${model.name}Response`] = {
            type: 'object',
            description: `Response for a "${model.name}"`,
            required: ['data'],
            properties: {
                jsonapi: this.ref('_jsonapi'),
                data: this.allOf(this.ref(`${model.name}`), {
                    type: 'object',
                    properties: { relationships: { type: 'object', properties: relationships } },
                }),
                meta: this.ref('_meta'),
                included: {
                    type: 'array',
                    items: this.ref('_resource'),
                },
                links: this.ref('_links'),
            },
        };
        result[`${model.name}ListResponse`] = {
            type: 'object',
            description: `Response for a list of "${model.name}"`,
            required: ['data', 'links'],
            properties: {
                jsonapi: this.ref('_jsonapi'),
                data: this.array(this.allOf(this.ref(`${model.name}`), {
                    type: 'object',
                    properties: { relationships: { type: 'object', properties: relationships } },
                })),
                meta: this.ref('_meta'),
                included: {
                    type: 'array',
                    items: this.ref('_resource'),
                },
                links: this.allOf(this.ref('_links'), this.ref('_pagination')),
            },
        };
        return result;
    }
    generateModelEntity(model, mode) {
        var _a;
        const fields = model.fields.filter((f) => !(0, sdk_1.isIdField)(f));
        const attributes = {};
        const relationships = {};
        const required = [];
        for (const field of fields) {
            if ((0, sdk_1.isRelationshipField)(field)) {
                let relType;
                if (mode === 'create' || mode === 'update') {
                    relType = field.type.array ? '_toManyRelationship' : '_toOneRelationship';
                }
                else {
                    relType = field.type.array ? '_toManyRelationshipWithLinks' : '_toOneRelationshipWithLinks';
                }
                relationships[field.name] = this.wrapNullable(this.ref(relType), field.type.optional);
            }
            else {
                attributes[field.name] = this.generateField(field);
                if (mode === 'create' &&
                    !field.type.optional &&
                    !(0, sdk_1.hasAttribute)(field, '@default') &&
                    // collection relation fields are implicitly optional
                    !((0, ast_1.isDataModel)((_a = field.$resolvedType) === null || _a === void 0 ? void 0 : _a.decl) && field.type.array)) {
                    required.push(field.name);
                }
            }
        }
        const toplevelRequired = ['type', 'attributes'];
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        let properties = {
            type: { type: 'string' },
            attributes: {
                type: 'object',
                required: required.length > 0 ? required : undefined,
                properties: attributes,
            },
        };
        if (mode === 'create') {
            // 'id' is required if there's no default value
            const idField = model.fields.find((f) => (0, sdk_1.isIdField)(f));
            if (idField && !(0, sdk_1.hasAttribute)(idField, '@default')) {
                properties = Object.assign({ id: { type: 'string' } }, properties);
                toplevelRequired.unshift('id');
            }
        }
        else {
            // 'id' always required for read and update
            properties = Object.assign({ id: { type: 'string' } }, properties);
            toplevelRequired.unshift('id');
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const result = {
            type: 'object',
            description: `The "${model.name}" model`,
            required: toplevelRequired,
            properties,
        };
        if (Object.keys(relationships).length > 0) {
            result.properties.relationships = {
                type: 'object',
                properties: relationships,
            };
        }
        return result;
    }
    generateField(field) {
        return this.wrapArray(this.wrapNullable(this.fieldTypeToOpenAPISchema(field.type), field.type.optional), field.type.array);
    }
    fieldTypeToOpenAPISchema(type) {
        return (0, ts_pattern_1.match)(type.type)
            .with('String', () => ({ type: 'string' }))
            .with(ts_pattern_1.P.union('Int', 'BigInt'), () => ({ type: 'integer' }))
            .with('Float', () => ({ type: 'number' }))
            .with('Decimal', () => this.oneOf({ type: 'number' }, { type: 'string' }))
            .with('Boolean', () => ({ type: 'boolean' }))
            .with('DateTime', () => ({ type: 'string', format: 'date-time' }))
            .with('Bytes', () => ({ type: 'string', format: 'byte', description: 'Base64 encoded byte array' }))
            .with('Json', () => ({}))
            .otherwise((t) => {
            var _a;
            const fieldDecl = (_a = type.reference) === null || _a === void 0 ? void 0 : _a.ref;
            (0, tiny_invariant_1.default)(fieldDecl, `Type ${t} is not a model reference`);
            return this.ref(fieldDecl === null || fieldDecl === void 0 ? void 0 : fieldDecl.name);
        });
    }
    ref(type) {
        return { $ref: `#/components/schemas/${type}` };
    }
    parameter(type) {
        return { $ref: `#/components/parameters/${type}` };
    }
    forbidden() {
        return {
            description: 'Request is forbidden',
            content: {
                'application/vnd.api+json': {
                    schema: this.ref('_errorResponse'),
                },
            },
        };
    }
    validationError() {
        return {
            description: 'Request is unprocessable due to validation errors',
            content: {
                'application/vnd.api+json': {
                    schema: this.ref('_errorResponse'),
                },
            },
        };
    }
    notFound() {
        return {
            description: 'Resource is not found',
            content: {
                'application/vnd.api+json': {
                    schema: this.ref('_errorResponse'),
                },
            },
        };
    }
    success(responseComponent) {
        return {
            description: 'Successful operation',
            content: responseComponent
                ? {
                    'application/vnd.api+json': {
                        schema: this.ref(responseComponent),
                    },
                }
                : undefined,
        };
    }
}
exports.RESTfulOpenAPIGenerator = RESTfulOpenAPIGenerator;
//# sourceMappingURL=rest-generator.js.map