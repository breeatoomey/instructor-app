"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OpenAPIGeneratorBase = void 0;
const sdk_1 = require("@zenstackhq/sdk");
const semver_1 = __importDefault(require("semver"));
const zod_validation_error_1 = require("zod-validation-error");
const _1 = require(".");
const schema_1 = require("./schema");
class OpenAPIGeneratorBase {
    constructor(model, options, dmmf) {
        this.model = model;
        this.options = options;
        this.dmmf = dmmf;
        this.DEFAULT_SPEC_VERSION = '3.1.0';
    }
    get includedModels() {
        return (0, sdk_1.getDataModels)(this.model).filter((d) => !(0, sdk_1.hasAttribute)(d, '@@openapi.ignore'));
    }
    wrapArray(schema, isArray) {
        if (isArray) {
            return { type: 'array', items: schema };
        }
        else {
            return schema;
        }
    }
    wrapNullable(schema, isNullable) {
        if (!isNullable) {
            return schema;
        }
        const specVersion = this.getOption('specVersion', this.DEFAULT_SPEC_VERSION);
        // https://stackoverflow.com/questions/48111459/how-to-define-a-property-that-can-be-string-or-null-in-openapi-swagger
        // https://stackoverflow.com/questions/40920441/how-to-specify-a-property-can-be-null-or-a-reference-with-swagger
        if (semver_1.default.gte(specVersion, '3.1.0')) {
            // OAPI 3.1.0 and above has native 'null' type
            if (schema.oneOf) {
                // merge into existing 'oneOf'
                return { oneOf: [...schema.oneOf, { type: 'null' }] };
            }
            else {
                // wrap into a 'oneOf'
                return { oneOf: [{ type: 'null' }, schema] };
            }
        }
        else {
            if (schema.$ref) {
                // nullable $ref needs to be represented as: { allOf: [{ $ref: ... }], nullable: true }
                return {
                    allOf: [schema],
                    nullable: true,
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                };
            }
            else {
                // nullable scalar: { type: ..., nullable: true }
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                return Object.assign(Object.assign({}, schema), { nullable: true });
            }
        }
    }
    array(itemType) {
        return { type: 'array', items: itemType };
    }
    oneOf(...schemas) {
        return { oneOf: schemas };
    }
    allOf(...schemas) {
        return { allOf: schemas };
    }
    getOption(name, defaultValue) {
        const value = this.options[name];
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-expect-error
        return value === undefined ? defaultValue : value;
    }
    generateSecuritySchemes() {
        const securitySchemes = this.getOption('securitySchemes');
        if (securitySchemes) {
            const parsed = schema_1.SecuritySchemesSchema.safeParse(securitySchemes);
            if (!parsed.success) {
                throw new sdk_1.PluginError(_1.name, `"securitySchemes" option is invalid: ${(0, zod_validation_error_1.fromZodError)(parsed.error)}`);
            }
            return parsed.data;
        }
        return undefined;
    }
    pruneComponents(paths, components) {
        const schemas = components.schemas;
        if (schemas) {
            const roots = new Set();
            for (const path of Object.values(paths)) {
                this.collectUsedComponents(path, roots);
            }
            // build a transitive closure for all reachable schemas from roots
            const allUsed = new Set(roots);
            let todo = [...allUsed];
            while (todo.length > 0) {
                const curr = new Set(allUsed);
                Object.entries(schemas)
                    .filter(([key]) => todo.includes(key))
                    .forEach(([, value]) => {
                    this.collectUsedComponents(value, allUsed);
                });
                todo = [...allUsed].filter((e) => !curr.has(e));
            }
            // prune unused schemas
            Object.keys(schemas).forEach((key) => {
                if (!allUsed.has(key)) {
                    delete schemas[key];
                }
            });
        }
    }
    collectUsedComponents(value, allUsed) {
        if (!value) {
            return;
        }
        if (Array.isArray(value)) {
            value.forEach((item) => {
                this.collectUsedComponents(item, allUsed);
            });
        }
        else if (typeof value === 'object') {
            Object.entries(value).forEach(([subKey, subValue]) => {
                if (subKey === '$ref') {
                    const ref = subValue;
                    const name = ref.split('/').pop();
                    if (name && !allUsed.has(name)) {
                        allUsed.add(name);
                    }
                }
                else {
                    this.collectUsedComponents(subValue, allUsed);
                }
            });
        }
    }
}
exports.OpenAPIGeneratorBase = OpenAPIGeneratorBase;
//# sourceMappingURL=generator-base.js.map