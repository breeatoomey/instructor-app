import { Expression } from '@zenstackhq/language/ast';
import { ExpressionContext } from './constants';
export declare class TypeScriptExpressionTransformerError extends Error {
    constructor(message: string);
}
type Options = {
    isPostGuard?: boolean;
    fieldReferenceContext?: string;
    thisExprContext?: string;
    context: ExpressionContext;
};
/**
 * Transforms ZModel expression to plain TypeScript expression.
 */
export declare class TypeScriptExpressionTransformer {
    private readonly options;
    /**
     * Constructs a new TypeScriptExpressionTransformer.
     *
     * @param isPostGuard indicates if we're writing for post-update conditions
     */
    constructor(options: Options);
    /**
     * Transforms the given expression to a TypeScript expression.
     * @param normalizeUndefined if undefined values should be normalized to null
     * @returns
     */
    transform(expr: Expression, normalizeUndefined?: boolean): string;
    private this;
    private memberAccess;
    private invocation;
    private _auth;
    private _now;
    private _length;
    private _contains;
    private _startsWith;
    private _endsWith;
    private _regex;
    private _email;
    private _datetime;
    private _url;
    private _has;
    private _hasEvery;
    private _hasSome;
    private _isEmpty;
    private ensureBoolean;
    private ensureBooleanTernary;
    private reference;
    private null;
    private array;
    private literal;
    private unary;
    private isModelType;
    private binary;
    private extractNullComparison;
    private collectionPredicate;
}
export {};
