"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeScriptExpressionTransformer = exports.TypeScriptExpressionTransformerError = void 0;
const ast_1 = require("@zenstackhq/language/ast");
const ts_pattern_1 = require("ts-pattern");
const constants_1 = require("./constants");
const utils_1 = require("./utils");
class TypeScriptExpressionTransformerError extends Error {
    constructor(message) {
        super(message);
    }
}
exports.TypeScriptExpressionTransformerError = TypeScriptExpressionTransformerError;
// a registry of function handlers marked with @func
const functionHandlers = new Map();
// function handler decorator
function func(name) {
    return function (target, propertyKey, descriptor) {
        if (!functionHandlers.get(name)) {
            functionHandlers.set(name, descriptor);
        }
        return descriptor;
    };
}
/**
 * Transforms ZModel expression to plain TypeScript expression.
 */
class TypeScriptExpressionTransformer {
    /**
     * Constructs a new TypeScriptExpressionTransformer.
     *
     * @param isPostGuard indicates if we're writing for post-update conditions
     */
    constructor(options) {
        this.options = options;
    }
    /**
     * Transforms the given expression to a TypeScript expression.
     * @param normalizeUndefined if undefined values should be normalized to null
     * @returns
     */
    transform(expr, normalizeUndefined = true) {
        switch (expr.$type) {
            case ast_1.StringLiteral:
            case ast_1.NumberLiteral:
            case ast_1.BooleanLiteral:
                return this.literal(expr);
            case ast_1.ArrayExpr:
                return this.array(expr, normalizeUndefined);
            case ast_1.NullExpr:
                return this.null();
            case ast_1.ThisExpr:
                return this.this(expr);
            case ast_1.ReferenceExpr:
                return this.reference(expr);
            case ast_1.InvocationExpr:
                return this.invocation(expr, normalizeUndefined);
            case ast_1.MemberAccessExpr:
                return this.memberAccess(expr, normalizeUndefined);
            case ast_1.UnaryExpr:
                return this.unary(expr, normalizeUndefined);
            case ast_1.BinaryExpr:
                return this.binary(expr, normalizeUndefined);
            default:
                throw new TypeScriptExpressionTransformerError(`Unsupported expression type: ${expr.$type}`);
        }
    }
    this(_expr) {
        var _a;
        // "this" is mapped to the input argument
        return (_a = this.options.thisExprContext) !== null && _a !== void 0 ? _a : 'input';
    }
    memberAccess(expr, normalizeUndefined) {
        var _a;
        if (!expr.member.ref) {
            throw new TypeScriptExpressionTransformerError(`Unresolved MemberAccessExpr`);
        }
        if ((0, utils_1.isFutureExpr)(expr.operand)) {
            if (((_a = this.options) === null || _a === void 0 ? void 0 : _a.isPostGuard) !== true) {
                throw new TypeScriptExpressionTransformerError(`future() is only supported in postUpdate rules`);
            }
            return expr.member.ref.name;
        }
        else {
            if (normalizeUndefined) {
                // normalize field access to null instead of undefined to avoid accidentally use undefined in filter
                return `(${this.transform(expr.operand, normalizeUndefined)}?.${expr.member.ref.name} ?? null)`;
            }
            else {
                return `${this.transform(expr.operand, normalizeUndefined)}?.${expr.member.ref.name}`;
            }
        }
    }
    invocation(expr, normalizeUndefined) {
        if (!expr.function.ref) {
            throw new TypeScriptExpressionTransformerError(`Unresolved InvocationExpr`);
        }
        const funcName = expr.function.ref.name;
        const isStdFunc = (0, utils_1.isFromStdlib)(expr.function.ref);
        if (!isStdFunc) {
            throw new TypeScriptExpressionTransformerError('User-defined functions are not supported yet');
        }
        const handler = functionHandlers.get(funcName);
        if (!handler) {
            throw new TypeScriptExpressionTransformerError(`Unsupported function: ${funcName}`);
        }
        const args = expr.args.map((arg) => arg.value);
        return handler.value.call(this, args, normalizeUndefined);
    }
    // #region function invocation handlers
    // arguments have been type-checked
    _auth() {
        return 'user';
    }
    _now() {
        return `(new Date())`;
    }
    _length(args) {
        const field = this.transform(args[0], false);
        const min = (0, utils_1.getLiteral)(args[1]);
        const max = (0, utils_1.getLiteral)(args[2]);
        let result;
        if (min === undefined) {
            result = this.ensureBooleanTernary(args[0], field, `${field}?.length > 0`);
        }
        else if (max === undefined) {
            result = this.ensureBooleanTernary(args[0], field, `${field}?.length >= ${min}`);
        }
        else {
            result = this.ensureBooleanTernary(args[0], field, `${field}?.length >= ${min} && ${field}?.length <= ${max}`);
        }
        return result;
    }
    _contains(args, normalizeUndefined) {
        const field = this.transform(args[0], false);
        const caseInsensitive = (0, utils_1.getLiteral)(args[2]) === true;
        let result;
        if (caseInsensitive) {
            result = `${field}?.toLowerCase().includes(${this.transform(args[1], normalizeUndefined)}?.toLowerCase())`;
        }
        else {
            result = `${field}?.includes(${this.transform(args[1], normalizeUndefined)})`;
        }
        return this.ensureBoolean(result);
    }
    _startsWith(args, normalizeUndefined) {
        const field = this.transform(args[0], false);
        const result = `${field}?.startsWith(${this.transform(args[1], normalizeUndefined)})`;
        return this.ensureBoolean(result);
    }
    _endsWith(args, normalizeUndefined) {
        const field = this.transform(args[0], false);
        const result = `${field}?.endsWith(${this.transform(args[1], normalizeUndefined)})`;
        return this.ensureBoolean(result);
    }
    _regex(args) {
        const field = this.transform(args[0], false);
        const pattern = (0, utils_1.getLiteral)(args[1]);
        return this.ensureBooleanTernary(args[0], field, `new RegExp(${JSON.stringify(pattern)}).test(${field})`);
    }
    _email(args) {
        const field = this.transform(args[0], false);
        return this.ensureBooleanTernary(args[0], field, `z.string().email().safeParse(${field}).success`);
    }
    _datetime(args) {
        const field = this.transform(args[0], false);
        return this.ensureBooleanTernary(args[0], field, `z.string().datetime({ offset: true }).safeParse(${field}).success`);
    }
    _url(args) {
        const field = this.transform(args[0], false);
        return this.ensureBooleanTernary(args[0], field, `z.string().url().safeParse(${field}).success`);
    }
    _has(args, normalizeUndefined) {
        const field = this.transform(args[0], false);
        const result = `${field}?.includes(${this.transform(args[1], normalizeUndefined)})`;
        return this.ensureBoolean(result);
    }
    _hasEvery(args, normalizeUndefined) {
        const field = this.transform(args[0], false);
        return this.ensureBooleanTernary(args[0], field, `${this.transform(args[1], normalizeUndefined)}?.every((item) => ${field}?.includes(item))`);
    }
    _hasSome(args, normalizeUndefined) {
        const field = this.transform(args[0], false);
        return this.ensureBooleanTernary(args[0], field, `${this.transform(args[1], normalizeUndefined)}?.some((item) => ${field}?.includes(item))`);
    }
    _isEmpty(args) {
        const field = this.transform(args[0], false);
        return `(!${field} || ${field}?.length === 0)`;
    }
    ensureBoolean(expr) {
        if (this.options.context === constants_1.ExpressionContext.ValidationRule) {
            // all fields are optional in a validation context, so we treat undefined
            // as boolean true
            return `(${expr} ?? true)`;
        }
        else {
            return `((${expr}) ?? false)`;
        }
    }
    ensureBooleanTernary(predicate, transformedPredicate, value) {
        if ((0, ast_1.isLiteralExpr)(predicate) || (0, ast_1.isArrayExpr)(predicate)) {
            // these are never undefined
            return value;
        }
        if (this.options.context === constants_1.ExpressionContext.ValidationRule) {
            // all fields are optional in a validation context, so we treat undefined
            // as boolean true
            return `((${transformedPredicate}) !== undefined ? (${value}): true)`;
        }
        else {
            return `((${transformedPredicate}) !== undefined ? (${value}): false)`;
        }
    }
    // #endregion
    reference(expr) {
        var _a, _b;
        if (!expr.target.ref) {
            throw new TypeScriptExpressionTransformerError(`Unresolved ReferenceExpr`);
        }
        if ((0, ast_1.isEnumField)(expr.target.ref)) {
            return `${expr.target.ref.$container.name}.${expr.target.ref.name}`;
        }
        else {
            if ((_a = this.options) === null || _a === void 0 ? void 0 : _a.isPostGuard) {
                // if we're processing post-update, any direct field access should be
                // treated as access to context.preValue, which is entity's value before
                // the update
                return `context.preValue?.${expr.target.ref.name}`;
            }
            else {
                return ((_b = this.options) === null || _b === void 0 ? void 0 : _b.fieldReferenceContext)
                    ? `${this.options.fieldReferenceContext}?.${expr.target.ref.name}`
                    : expr.target.ref.name;
            }
        }
    }
    null() {
        return 'null';
    }
    array(expr, normalizeUndefined) {
        return `[${expr.items.map((item) => this.transform(item, normalizeUndefined)).join(', ')}]`;
    }
    literal(expr) {
        if (expr.$type === ast_1.StringLiteral) {
            return `'${expr.value}'`;
        }
        else {
            return expr.value.toString();
        }
    }
    unary(expr, normalizeUndefined) {
        const operand = this.transform(expr.operand, normalizeUndefined);
        let result = `(${expr.operator} ${operand})`;
        if (expr.operator === '!' &&
            this.options.context === constants_1.ExpressionContext.ValidationRule &&
            (0, utils_1.isDataModelFieldReference)(expr.operand)) {
            // in a validation context, we treat unary involving undefined as boolean true
            result = this.ensureBooleanTernary(expr.operand, operand, result);
        }
        return result;
    }
    isModelType(expr) {
        var _a;
        return (0, ast_1.isDataModel)((_a = expr.$resolvedType) === null || _a === void 0 ? void 0 : _a.decl);
    }
    binary(expr, normalizeUndefined) {
        let left = this.transform(expr.left, normalizeUndefined);
        let right = this.transform(expr.right, normalizeUndefined);
        if (this.isModelType(expr.left) && this.isModelType(expr.right)) {
            // comparison between model type values, map to id comparison
            left = `(${left}?.id ?? null)`;
            right = `(${right}?.id ?? null)`;
        }
        let _default = `(${left} ${expr.operator} ${right})`;
        if (this.options.context === constants_1.ExpressionContext.ValidationRule) {
            const nullComparison = this.extractNullComparison(expr);
            if (nullComparison) {
                // null comparison covers both null and undefined
                const { fieldRef } = nullComparison;
                const field = this.transform(fieldRef, normalizeUndefined);
                if (expr.operator === '==') {
                    _default = `(${field} === null || ${field} === undefined)`;
                }
                else if (expr.operator === '!=') {
                    _default = `(${field} !== null && ${field} !== undefined)`;
                }
            }
            else {
                // for other comparisons, in a validation context,
                // we treat binary involving undefined as boolean true
                if ((0, utils_1.isDataModelFieldReference)(expr.left)) {
                    _default = this.ensureBooleanTernary(expr.left, left, _default);
                }
                if ((0, utils_1.isDataModelFieldReference)(expr.right)) {
                    _default = this.ensureBooleanTernary(expr.right, right, _default);
                }
            }
        }
        return (0, ts_pattern_1.match)(expr.operator)
            .with('in', () => {
            const left = `${this.transform(expr.left, normalizeUndefined)}`;
            const right = `${this.transform(expr.right, false)}`;
            let result = `${right}?.includes(${left})`;
            if (this.options.context === constants_1.ExpressionContext.ValidationRule) {
                // in a validation context, we treat binary involving undefined as boolean true
                result = this.ensureBooleanTernary(expr.left, left, this.ensureBooleanTernary(expr.right, right, result));
            }
            else {
                result = this.ensureBoolean(result);
            }
            return result;
        })
            .with(ts_pattern_1.P.union('==', '!='), () => {
            var _a;
            if ((0, ast_1.isThisExpr)(expr.left) || (0, ast_1.isThisExpr)(expr.right)) {
                // map equality comparison with `this` to id comparison
                const _this = (0, ast_1.isThisExpr)(expr.left) ? expr.left : expr.right;
                const model = (_a = _this.$resolvedType) === null || _a === void 0 ? void 0 : _a.decl;
                const idFields = (0, utils_1.getIdFields)(model);
                if (!idFields || idFields.length === 0) {
                    throw new TypeScriptExpressionTransformerError(`model "${model.name}" does not have an id field`);
                }
                let result = `allFieldsEqual(${this.transform(expr.left, false)}, 
                ${this.transform(expr.right, false)}, [${idFields.map((f) => "'" + f.name + "'").join(', ')}])`;
                if (expr.operator === '!=') {
                    result = `!${result}`;
                }
                return result;
            }
            else {
                return _default;
            }
        })
            .with(ts_pattern_1.P.union('?', '!', '^'), (op) => this.collectionPredicate(expr, op, normalizeUndefined))
            .otherwise(() => _default);
    }
    extractNullComparison(expr) {
        if (expr.operator !== '==' && expr.operator !== '!=') {
            return undefined;
        }
        if ((0, utils_1.isDataModelFieldReference)(expr.left) && (0, ast_1.isNullExpr)(expr.right)) {
            return { fieldRef: expr.left, nullExpr: expr.right };
        }
        else if ((0, utils_1.isDataModelFieldReference)(expr.right) && (0, ast_1.isNullExpr)(expr.left)) {
            return { fieldRef: expr.right, nullExpr: expr.left };
        }
        else {
            return undefined;
        }
    }
    collectionPredicate(expr, operator, normalizeUndefined) {
        const operand = this.transform(expr.left, normalizeUndefined);
        const innerTransformer = new TypeScriptExpressionTransformer(Object.assign(Object.assign({}, this.options), { isPostGuard: false, fieldReferenceContext: '_item', thisExprContext: '_item' }));
        const predicate = innerTransformer.transform(expr.right, normalizeUndefined);
        return (0, ts_pattern_1.match)(operator)
            .with('?', () => this.ensureBoolean(`(${operand})?.some((_item: any) => ${predicate})`))
            .with('!', () => this.ensureBoolean(`(${operand})?.every((_item: any) => ${predicate})`))
            .with('^', () => `!((${operand})?.some((_item: any) => ${predicate}))`)
            .exhaustive();
    }
}
exports.TypeScriptExpressionTransformer = TypeScriptExpressionTransformer;
__decorate([
    func('auth')
], TypeScriptExpressionTransformer.prototype, "_auth", null);
__decorate([
    func('now')
], TypeScriptExpressionTransformer.prototype, "_now", null);
__decorate([
    func('length')
], TypeScriptExpressionTransformer.prototype, "_length", null);
__decorate([
    func('contains')
], TypeScriptExpressionTransformer.prototype, "_contains", null);
__decorate([
    func('startsWith')
], TypeScriptExpressionTransformer.prototype, "_startsWith", null);
__decorate([
    func('endsWith')
], TypeScriptExpressionTransformer.prototype, "_endsWith", null);
__decorate([
    func('regex')
], TypeScriptExpressionTransformer.prototype, "_regex", null);
__decorate([
    func('email')
], TypeScriptExpressionTransformer.prototype, "_email", null);
__decorate([
    func('datetime')
], TypeScriptExpressionTransformer.prototype, "_datetime", null);
__decorate([
    func('url')
], TypeScriptExpressionTransformer.prototype, "_url", null);
__decorate([
    func('has')
], TypeScriptExpressionTransformer.prototype, "_has", null);
__decorate([
    func('hasEvery')
], TypeScriptExpressionTransformer.prototype, "_hasEvery", null);
__decorate([
    func('hasSome')
], TypeScriptExpressionTransformer.prototype, "_hasSome", null);
__decorate([
    func('isEmpty')
], TypeScriptExpressionTransformer.prototype, "_isEmpty", null);
//# sourceMappingURL=typescript-expression-transformer.js.map