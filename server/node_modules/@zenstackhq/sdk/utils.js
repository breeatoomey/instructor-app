"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDataSourceProvider = exports.ensureEmptyDir = exports.getRecursiveBases = exports.getModelFieldsWithBases = exports.getDataModelFieldReference = exports.getIdFields = exports.isDiscriminatorField = exports.isDelegateModel = exports.getAuthModel = exports.getPreviewFeatures = exports.getContainingModel = exports.isFromStdlib = exports.isAuthInvocation = exports.isFutureExpr = exports.getFunctionExpressionContext = exports.parseOptionAsStrings = exports.requireOption = exports.resolvePath = exports.getRelationField = exports.getRelationKeyPairs = exports.isForeignKeyField = exports.isRelationshipField = exports.isIdField = exports.getModelUniqueFields = exports.getModelIdFields = exports.isDataModelFieldReference = exports.isEnumFieldReference = exports.getAttributeArgLiteral = exports.getAttributeArg = exports.getAttributeArgs = exports.getAttribute = exports.hasAttribute = exports.indentString = exports.getObjectLiteral = exports.getLiteralArray = exports.getArray = exports.getLiteral = exports.resolved = exports.getDataModels = void 0;
const ast_1 = require("@zenstackhq/language/ast");
const node_fs_1 = __importDefault(require("node:fs"));
const path_1 = __importDefault(require("path"));
const constants_1 = require("./constants");
const types_1 = require("./types");
/**
 * Gets data models in the ZModel schema.
 */
function getDataModels(model, includeIgnored = false) {
    const r = model.declarations.filter((d) => (0, ast_1.isDataModel)(d));
    if (includeIgnored) {
        return r;
    }
    else {
        return r.filter((model) => !hasAttribute(model, '@@ignore'));
    }
}
exports.getDataModels = getDataModels;
function resolved(ref) {
    if (!ref.ref) {
        throw new Error(`Reference not resolved: ${ref.$refText}`);
    }
    return ref.ref;
}
exports.resolved = resolved;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function getLiteral(expr) {
    switch (expr === null || expr === void 0 ? void 0 : expr.$type) {
        case 'ObjectExpr':
            return getObjectLiteral(expr);
        case 'StringLiteral':
        case 'BooleanLiteral':
            return expr.value;
        case 'NumberLiteral':
            return parseFloat(expr.value);
        default:
            return undefined;
    }
}
exports.getLiteral = getLiteral;
function getArray(expr) {
    return (0, ast_1.isArrayExpr)(expr) || (0, ast_1.isConfigArrayExpr)(expr) ? expr.items : undefined;
}
exports.getArray = getArray;
function getLiteralArray(expr) {
    const arr = getArray(expr);
    if (!arr) {
        return undefined;
    }
    return arr.map((item) => (0, ast_1.isExpression)(item) && getLiteral(item)).filter((v) => v !== undefined);
}
exports.getLiteralArray = getLiteralArray;
function getObjectLiteral(expr) {
    if (!expr || !(0, ast_1.isObjectExpr)(expr)) {
        return undefined;
    }
    const result = {};
    for (const field of expr.fields) {
        let fieldValue;
        if ((0, ast_1.isLiteralExpr)(field.value)) {
            fieldValue = getLiteral(field.value);
        }
        else if ((0, ast_1.isArrayExpr)(field.value)) {
            fieldValue = getLiteralArray(field.value);
        }
        else if ((0, ast_1.isObjectExpr)(field.value)) {
            fieldValue = getObjectLiteral(field.value);
        }
        if (fieldValue === undefined) {
            return undefined;
        }
        else {
            result[field.name] = fieldValue;
        }
    }
    return result;
}
exports.getObjectLiteral = getObjectLiteral;
function indentString(string, count = 4) {
    const indent = ' ';
    return string.replace(/^(?!\s*$)/gm, indent.repeat(count));
}
exports.indentString = indentString;
function hasAttribute(decl, name) {
    return !!getAttribute(decl, name);
}
exports.hasAttribute = hasAttribute;
function getAttribute(decl, name) {
    return decl.attributes.find((attr) => attr.decl.$refText === name);
}
exports.getAttribute = getAttribute;
function getAttributeArgs(attr) {
    const result = {};
    for (const arg of attr.args) {
        if (!arg.$resolvedParam) {
            continue;
        }
        result[arg.$resolvedParam.name] = arg.value;
    }
    return result;
}
exports.getAttributeArgs = getAttributeArgs;
function getAttributeArg(attr, name) {
    var _a;
    for (const arg of attr.args) {
        if (((_a = arg.$resolvedParam) === null || _a === void 0 ? void 0 : _a.name) === name) {
            return arg.value;
        }
    }
    return undefined;
}
exports.getAttributeArg = getAttributeArg;
function getAttributeArgLiteral(attr, name) {
    var _a;
    for (const arg of attr.args) {
        if (((_a = arg.$resolvedParam) === null || _a === void 0 ? void 0 : _a.name) === name) {
            return getLiteral(arg.value);
        }
    }
    return undefined;
}
exports.getAttributeArgLiteral = getAttributeArgLiteral;
function isEnumFieldReference(node) {
    return (0, ast_1.isReferenceExpr)(node) && (0, ast_1.isEnumField)(node.target.ref);
}
exports.isEnumFieldReference = isEnumFieldReference;
function isDataModelFieldReference(node) {
    return (0, ast_1.isReferenceExpr)(node) && (0, ast_1.isDataModelField)(node.target.ref);
}
exports.isDataModelFieldReference = isDataModelFieldReference;
/**
 * Gets `@@id` fields declared at the data model level (including search in base models)
 */
function getModelIdFields(model) {
    const modelsToCheck = model.$baseMerged ? [model] : [model, ...getRecursiveBases(model)];
    for (const modelToCheck of modelsToCheck) {
        const idAttr = modelToCheck.attributes.find((attr) => attr.decl.$refText === '@@id');
        if (!idAttr) {
            continue;
        }
        const fieldsArg = idAttr.args.find((a) => { var _a; return ((_a = a.$resolvedParam) === null || _a === void 0 ? void 0 : _a.name) === 'fields'; });
        if (!fieldsArg || !(0, ast_1.isArrayExpr)(fieldsArg.value)) {
            continue;
        }
        return fieldsArg.value.items
            .filter((item) => (0, ast_1.isReferenceExpr)(item))
            .map((item) => resolved(item.target));
    }
    return [];
}
exports.getModelIdFields = getModelIdFields;
/**
 * Gets `@@unique` fields declared at the data model level (including search in base models)
 */
function getModelUniqueFields(model) {
    const modelsToCheck = model.$baseMerged ? [model] : [model, ...getRecursiveBases(model)];
    for (const modelToCheck of modelsToCheck) {
        const uniqueAttr = modelToCheck.attributes.find((attr) => attr.decl.$refText === '@@unique');
        if (!uniqueAttr) {
            continue;
        }
        const fieldsArg = uniqueAttr.args.find((a) => { var _a; return ((_a = a.$resolvedParam) === null || _a === void 0 ? void 0 : _a.name) === 'fields'; });
        if (!fieldsArg || !(0, ast_1.isArrayExpr)(fieldsArg.value)) {
            continue;
        }
        return fieldsArg.value.items
            .filter((item) => (0, ast_1.isReferenceExpr)(item))
            .map((item) => resolved(item.target));
    }
    return [];
}
exports.getModelUniqueFields = getModelUniqueFields;
/**
 * Returns if the given field is declared as an id field.
 */
function isIdField(field) {
    // field-level @id attribute
    if (hasAttribute(field, '@id')) {
        return true;
    }
    // NOTE: we have to use name to match fields because the fields
    // may be inherited from an abstract base and have cloned identities
    const model = field.$container;
    // model-level @@id attribute with a list of fields
    const modelLevelIds = getModelIdFields(model);
    if (modelLevelIds.map((f) => f.name).includes(field.name)) {
        return true;
    }
    if (model.fields.some((f) => hasAttribute(f, '@id')) || modelLevelIds.length > 0) {
        // the model already has id field, don't check @unique and @@unique
        return false;
    }
    // then, the first field with @unique can be used as id
    const firstUniqueField = model.fields.find((f) => hasAttribute(f, '@unique'));
    if (firstUniqueField) {
        return firstUniqueField.name === field.name;
    }
    // last, the first model level @@unique can be used as id
    const modelLevelUnique = getModelUniqueFields(model);
    if (modelLevelUnique.map((f) => f.name).includes(field.name)) {
        return true;
    }
    return false;
}
exports.isIdField = isIdField;
/**
 * Returns if the given field is a relation field.
 */
function isRelationshipField(field) {
    var _a;
    return (0, ast_1.isDataModel)((_a = field.type.reference) === null || _a === void 0 ? void 0 : _a.ref);
}
exports.isRelationshipField = isRelationshipField;
/**
 * Returns if the given field is a relation foreign key field.
 */
function isForeignKeyField(field) {
    const model = field.$container;
    return model.fields.some((f) => {
        // find @relation attribute
        const relAttr = f.attributes.find((attr) => { var _a; return ((_a = attr.decl.ref) === null || _a === void 0 ? void 0 : _a.name) === '@relation'; });
        if (relAttr) {
            // find "fields" arg
            const fieldsArg = relAttr.args.find((a) => { var _a; return ((_a = a.$resolvedParam) === null || _a === void 0 ? void 0 : _a.name) === 'fields'; });
            if (fieldsArg && (0, ast_1.isArrayExpr)(fieldsArg.value)) {
                // find a matching field reference
                return fieldsArg.value.items.some((item) => {
                    if ((0, ast_1.isReferenceExpr)(item)) {
                        return item.target.ref === field;
                    }
                    else {
                        return false;
                    }
                });
            }
        }
        return false;
    });
}
exports.isForeignKeyField = isForeignKeyField;
/**
 * Gets the foreign key-id field pairs from the given relation field.
 */
function getRelationKeyPairs(relationField) {
    if (!isRelationshipField(relationField)) {
        return [];
    }
    const relAttr = relationField.attributes.find((attr) => { var _a; return ((_a = attr.decl.ref) === null || _a === void 0 ? void 0 : _a.name) === '@relation'; });
    if (relAttr) {
        // find "fields" arg
        const fieldsArg = getAttributeArg(relAttr, 'fields');
        let fkFields;
        if (fieldsArg && (0, ast_1.isArrayExpr)(fieldsArg)) {
            fkFields = fieldsArg.items
                .filter((item) => (0, ast_1.isReferenceExpr)(item))
                .map((item) => item.target.ref);
        }
        else {
            return [];
        }
        // find "references" arg
        const referencesArg = getAttributeArg(relAttr, 'references');
        let idFields;
        if (referencesArg && (0, ast_1.isArrayExpr)(referencesArg)) {
            idFields = referencesArg.items
                .filter((item) => (0, ast_1.isReferenceExpr)(item))
                .map((item) => item.target.ref);
        }
        else {
            return [];
        }
        if (idFields.length !== fkFields.length) {
            throw new Error(`Relation's references arg and fields are must have equal length`);
        }
        return idFields.map((idField, i) => ({ id: idField, foreignKey: fkFields[i] }));
    }
    return [];
}
exports.getRelationKeyPairs = getRelationKeyPairs;
/**
 * Gets the relation field of the given foreign key field.
 */
function getRelationField(fkField) {
    const model = fkField.$container;
    return model.fields.find((f) => {
        const relAttr = f.attributes.find((attr) => { var _a; return ((_a = attr.decl.ref) === null || _a === void 0 ? void 0 : _a.name) === '@relation'; });
        if (relAttr) {
            const fieldsArg = getAttributeArg(relAttr, 'fields');
            if (fieldsArg && (0, ast_1.isArrayExpr)(fieldsArg)) {
                return fieldsArg.items.some((item) => (0, ast_1.isReferenceExpr)(item) && item.target.ref === fkField);
            }
        }
        return false;
    });
}
exports.getRelationField = getRelationField;
function resolvePath(_path, options) {
    if (path_1.default.isAbsolute(_path)) {
        return _path;
    }
    else {
        return path_1.default.resolve(path_1.default.dirname(options.schemaPath), _path);
    }
}
exports.resolvePath = resolvePath;
function requireOption(options, name, pluginName) {
    const value = options[name];
    if (value === undefined) {
        throw new types_1.PluginError(pluginName, `required option "${name}" is not provided`);
    }
    return value;
}
exports.requireOption = requireOption;
function parseOptionAsStrings(options, optionName, pluginName) {
    const value = options[optionName];
    if (value === undefined) {
        return undefined;
    }
    else if (typeof value === 'string') {
        // comma separated string
        return value
            .split(',')
            .filter((i) => !!i)
            .map((i) => i.trim());
    }
    else if (Array.isArray(value) && value.every((i) => typeof i === 'string')) {
        // string array
        return value;
    }
    else {
        throw new types_1.PluginError(pluginName, `Invalid "${optionName}" option: must be a comma-separated string or an array of strings`);
    }
}
exports.parseOptionAsStrings = parseOptionAsStrings;
function getFunctionExpressionContext(funcDecl) {
    const funcAllowedContext = [];
    const funcAttr = funcDecl.attributes.find((attr) => attr.decl.$refText === '@@@expressionContext');
    if (funcAttr) {
        const contextArg = funcAttr.args[0].value;
        if ((0, ast_1.isArrayExpr)(contextArg)) {
            contextArg.items.forEach((item) => {
                if (isEnumFieldReference(item)) {
                    funcAllowedContext.push(item.target.$refText);
                }
            });
        }
    }
    return funcAllowedContext;
}
exports.getFunctionExpressionContext = getFunctionExpressionContext;
function isFutureExpr(node) {
    var _a;
    return (0, ast_1.isInvocationExpr)(node) && ((_a = node.function.ref) === null || _a === void 0 ? void 0 : _a.name) === 'future' && isFromStdlib(node.function.ref);
}
exports.isFutureExpr = isFutureExpr;
function isAuthInvocation(node) {
    var _a;
    return (0, ast_1.isInvocationExpr)(node) && ((_a = node.function.ref) === null || _a === void 0 ? void 0 : _a.name) === 'auth' && isFromStdlib(node.function.ref);
}
exports.isAuthInvocation = isAuthInvocation;
function isFromStdlib(node) {
    const model = getContainingModel(node);
    return !!model && !!model.$document && model.$document.uri.path.endsWith(constants_1.STD_LIB_MODULE_NAME);
}
exports.isFromStdlib = isFromStdlib;
function getContainingModel(node) {
    if (!node) {
        return null;
    }
    return (0, ast_1.isModel)(node) ? node : getContainingModel(node.$container);
}
exports.getContainingModel = getContainingModel;
function getPreviewFeatures(model) {
    const jsGenerator = model.declarations.find((d) => (0, ast_1.isGeneratorDecl)(d) &&
        d.fields.some((f) => f.name === 'provider' && getLiteral(f.value) === 'prisma-client-js'));
    if (jsGenerator) {
        const previewFeaturesField = jsGenerator.fields.find((f) => f.name === 'previewFeatures');
        if (previewFeaturesField) {
            return getLiteralArray(previewFeaturesField.value);
        }
    }
    return [];
}
exports.getPreviewFeatures = getPreviewFeatures;
function getAuthModel(dataModels) {
    let authModel = dataModels.find((m) => hasAttribute(m, '@@auth'));
    if (!authModel) {
        authModel = dataModels.find((m) => m.name === 'User');
    }
    return authModel;
}
exports.getAuthModel = getAuthModel;
function isDelegateModel(node) {
    return (0, ast_1.isDataModel)(node) && hasAttribute(node, '@@delegate');
}
exports.isDelegateModel = isDelegateModel;
function isDiscriminatorField(field) {
    var _a, _b;
    const model = (_a = field.$inheritedFrom) !== null && _a !== void 0 ? _a : field.$container;
    const delegateAttr = getAttribute(model, '@@delegate');
    if (!delegateAttr) {
        return false;
    }
    const arg = (_b = delegateAttr.args[0]) === null || _b === void 0 ? void 0 : _b.value;
    return isDataModelFieldReference(arg) && arg.target.$refText === field.name;
}
exports.isDiscriminatorField = isDiscriminatorField;
function getIdFields(dataModel) {
    const fieldLevelId = getModelFieldsWithBases(dataModel).find((f) => f.attributes.some((attr) => attr.decl.$refText === '@id'));
    if (fieldLevelId) {
        return [fieldLevelId];
    }
    else {
        // get model level @@id attribute
        const modelIdAttr = dataModel.attributes.find((attr) => { var _a, _b; return ((_b = (_a = attr.decl) === null || _a === void 0 ? void 0 : _a.ref) === null || _b === void 0 ? void 0 : _b.name) === '@@id'; });
        if (modelIdAttr) {
            // get fields referenced in the attribute: @@id([field1, field2]])
            if (!(0, ast_1.isArrayExpr)(modelIdAttr.args[0].value)) {
                return [];
            }
            const argValue = modelIdAttr.args[0].value;
            return argValue.items
                .filter((expr) => (0, ast_1.isReferenceExpr)(expr) && !!getDataModelFieldReference(expr))
                .map((expr) => expr.target.ref);
        }
    }
    return [];
}
exports.getIdFields = getIdFields;
function getDataModelFieldReference(expr) {
    if ((0, ast_1.isReferenceExpr)(expr) && (0, ast_1.isDataModelField)(expr.target.ref)) {
        return expr.target.ref;
    }
    else if ((0, ast_1.isMemberAccessExpr)(expr) && (0, ast_1.isDataModelField)(expr.member.ref)) {
        return expr.member.ref;
    }
    else {
        return undefined;
    }
}
exports.getDataModelFieldReference = getDataModelFieldReference;
function getModelFieldsWithBases(model, includeDelegate = true) {
    if (model.$baseMerged) {
        return model.fields;
    }
    else {
        return [...model.fields, ...getRecursiveBases(model, includeDelegate).flatMap((base) => base.fields)];
    }
}
exports.getModelFieldsWithBases = getModelFieldsWithBases;
function getRecursiveBases(dataModel, includeDelegate = true) {
    const result = [];
    dataModel.superTypes.forEach((superType) => {
        const baseDecl = superType.ref;
        if (baseDecl) {
            if (!includeDelegate && isDelegateModel(baseDecl)) {
                return;
            }
            result.push(baseDecl);
            result.push(...getRecursiveBases(baseDecl, includeDelegate));
        }
    });
    return result;
}
exports.getRecursiveBases = getRecursiveBases;
function ensureEmptyDir(dir) {
    if (!node_fs_1.default.existsSync(dir)) {
        node_fs_1.default.mkdirSync(dir, { recursive: true });
        return;
    }
    const stats = node_fs_1.default.statSync(dir);
    if (stats.isDirectory()) {
        node_fs_1.default.rmSync(dir, { recursive: true });
        node_fs_1.default.mkdirSync(dir, { recursive: true });
    }
    else {
        throw new Error(`Path "${dir}" already exists and is not a directory`);
    }
}
exports.ensureEmptyDir = ensureEmptyDir;
/**
 * Gets the data source provider from the given model.
 */
function getDataSourceProvider(model) {
    const dataSource = model.declarations.find(ast_1.isDataSource);
    if (!dataSource) {
        return undefined;
    }
    const provider = dataSource === null || dataSource === void 0 ? void 0 : dataSource.fields.find((f) => f.name === 'provider');
    if (!provider) {
        return undefined;
    }
    return getLiteral(provider.value);
}
exports.getDataSourceProvider = getDataSourceProvider;
//# sourceMappingURL=utils.js.map