"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RestApiHandler = void 0;
const runtime_1 = require("@zenstackhq/runtime");
const change_case_1 = require("change-case");
const lower_case_first_1 = require("lower-case-first");
const superjson_1 = __importDefault(require("superjson"));
const ts_japi_1 = require("ts-japi");
const upper_case_first_1 = require("upper-case-first");
const url_pattern_1 = __importDefault(require("url-pattern"));
const zod_1 = __importDefault(require("zod"));
const zod_validation_error_1 = require("zod-validation-error");
const base_1 = require("../base");
const utils_1 = require("../utils");
const urlPatterns = {
    // collection operations
    collection: new url_pattern_1.default('/:type'),
    // single resource operations
    single: new url_pattern_1.default('/:type/:id'),
    // related entity fetching
    fetchRelationship: new url_pattern_1.default('/:type/:id/:relationship'),
    // relationship operations
    relationship: new url_pattern_1.default('/:type/:id/relationships/:relationship'),
};
class InvalidValueError extends Error {
    constructor(message) {
        super(message);
        this.message = message;
    }
}
const DEFAULT_PAGE_SIZE = 100;
const FilterOperations = [
    'lt',
    'lte',
    'gt',
    'gte',
    'contains',
    'icontains',
    'search',
    'startsWith',
    'endsWith',
    'has',
    'hasEvery',
    'hasSome',
    'isEmpty',
];
(0, utils_1.registerCustomSerializers)();
/**
 * RESTful-style API request handler (compliant with JSON:API)
 */
class RequestHandler extends base_1.APIHandlerBase {
    constructor(options) {
        super();
        this.options = options;
        // error responses
        this.errors = {
            unsupportedModel: {
                status: 404,
                title: 'Unsupported model type',
                detail: 'The model type is not supported',
            },
            unsupportedRelationship: {
                status: 400,
                title: 'Unsupported relationship',
                detail: 'The relationship is not supported',
            },
            invalidPath: {
                status: 400,
                title: 'The request path is invalid',
            },
            invalidVerb: {
                status: 400,
                title: 'The HTTP verb is not supported',
            },
            notFound: {
                status: 404,
                title: 'Resource not found',
            },
            noId: {
                status: 400,
                title: 'Model without an ID field is not supported',
            },
            multiId: {
                status: 400,
                title: 'Model with multiple ID fields is not supported',
            },
            invalidId: {
                status: 400,
                title: 'Resource ID is invalid',
            },
            invalidPayload: {
                status: 400,
                title: 'Invalid payload',
            },
            invalidRelationData: {
                status: 400,
                title: 'Invalid payload',
                detail: 'Invalid relationship data',
            },
            invalidRelation: {
                status: 400,
                title: 'Invalid payload',
                detail: 'Invalid relationship',
            },
            invalidFilter: {
                status: 400,
                title: 'Invalid filter',
            },
            invalidSort: {
                status: 400,
                title: 'Invalid sort',
            },
            invalidValue: {
                status: 400,
                title: 'Invalid value for type',
            },
            forbidden: {
                status: 403,
                title: 'Operation is forbidden',
            },
            validationError: {
                status: 422,
                title: 'Operation is unprocessable due to validation errors',
            },
            unknownError: {
                status: 400,
                title: 'Unknown error',
            },
        };
        this.filterParamPattern = new RegExp(/^filter(?<match>(\[[^[\]]+\])+)$/);
        // zod schema for payload of creating and updating a resource
        this.createUpdatePayloadSchema = zod_1.default
            .object({
            data: zod_1.default.object({
                type: zod_1.default.string(),
                attributes: zod_1.default.object({}).passthrough().optional(),
                relationships: zod_1.default
                    .record(zod_1.default.object({
                    data: zod_1.default.union([
                        zod_1.default.object({ type: zod_1.default.string(), id: zod_1.default.union([zod_1.default.string(), zod_1.default.number()]) }),
                        zod_1.default.array(zod_1.default.object({ type: zod_1.default.string(), id: zod_1.default.union([zod_1.default.string(), zod_1.default.number()]) })),
                    ]),
                }))
                    .optional(),
            }),
            meta: zod_1.default.object({}).passthrough().optional(),
        })
            .strict();
        // zod schema for updating a single relationship
        this.updateSingleRelationSchema = zod_1.default.object({
            data: zod_1.default.object({ type: zod_1.default.string(), id: zod_1.default.union([zod_1.default.string(), zod_1.default.number()]) }).nullable(),
        });
        // zod schema for updating collection relationship
        this.updateCollectionRelationSchema = zod_1.default.object({
            data: zod_1.default.array(zod_1.default.object({ type: zod_1.default.string(), id: zod_1.default.union([zod_1.default.string(), zod_1.default.number()]) })),
        });
    }
    handleRequest(_a) {
        return __awaiter(this, arguments, void 0, function* ({ prisma, method, path, query, requestBody, logger, modelMeta, zodSchemas, }) {
            modelMeta = modelMeta !== null && modelMeta !== void 0 ? modelMeta : this.defaultModelMeta;
            if (!modelMeta) {
                throw new Error('Model metadata is not provided or loaded from default location');
            }
            if (!this.serializers) {
                this.buildSerializers(modelMeta);
            }
            if (!this.typeMap) {
                this.buildTypeMap(logger, modelMeta);
            }
            method = method.toUpperCase();
            if (!path.startsWith('/')) {
                path = '/' + path;
            }
            try {
                switch (method) {
                    case 'GET': {
                        let match = urlPatterns.single.match(path);
                        if (match) {
                            // single resource read
                            return yield this.processSingleRead(prisma, match.type, match.id, query);
                        }
                        match = urlPatterns.fetchRelationship.match(path);
                        if (match) {
                            // fetch related resource(s)
                            return yield this.processFetchRelated(prisma, match.type, match.id, match.relationship, query);
                        }
                        match = urlPatterns.relationship.match(path);
                        if (match) {
                            // read relationship
                            return yield this.processReadRelationship(prisma, match.type, match.id, match.relationship, query, modelMeta);
                        }
                        match = urlPatterns.collection.match(path);
                        if (match) {
                            // collection read
                            return yield this.processCollectionRead(prisma, match.type, query);
                        }
                        return this.makeError('invalidPath');
                    }
                    case 'POST': {
                        if (!requestBody) {
                            return this.makeError('invalidPayload');
                        }
                        let match = urlPatterns.collection.match(path);
                        if (match) {
                            // resource creation
                            return yield this.processCreate(prisma, match.type, query, requestBody, zodSchemas);
                        }
                        match = urlPatterns.relationship.match(path);
                        if (match) {
                            // relationship creation (collection relationship only)
                            return yield this.processRelationshipCRUD(prisma, 'create', match.type, match.id, match.relationship, query, requestBody);
                        }
                        return this.makeError('invalidPath');
                    }
                    // TODO: PUT for full update
                    case 'PUT':
                    case 'PATCH': {
                        if (!requestBody) {
                            return this.makeError('invalidPayload');
                        }
                        let match = urlPatterns.single.match(path);
                        if (match) {
                            // resource update
                            return yield this.processUpdate(prisma, match.type, match.id, query, requestBody, zodSchemas);
                        }
                        match = urlPatterns.relationship.match(path);
                        if (match) {
                            // relationship update
                            return yield this.processRelationshipCRUD(prisma, 'update', match.type, match.id, match.relationship, query, requestBody);
                        }
                        return this.makeError('invalidPath');
                    }
                    case 'DELETE': {
                        let match = urlPatterns.single.match(path);
                        if (match) {
                            // resource deletion
                            return yield this.processDelete(prisma, match.type, match.id);
                        }
                        match = urlPatterns.relationship.match(path);
                        if (match) {
                            // relationship deletion (collection relationship only)
                            return yield this.processRelationshipCRUD(prisma, 'delete', match.type, match.id, match.relationship, query, requestBody);
                        }
                        return this.makeError('invalidPath');
                    }
                    default:
                        return this.makeError('invalidPath');
                }
            }
            catch (err) {
                if (err instanceof InvalidValueError) {
                    return this.makeError('invalidValue', err.message);
                }
                else {
                    return this.handlePrismaError(err);
                }
            }
        });
    }
    processSingleRead(prisma, type, resourceId, query) {
        return __awaiter(this, void 0, void 0, function* () {
            const typeInfo = this.typeMap[type];
            if (!typeInfo) {
                return this.makeUnsupportedModelError(type);
            }
            const args = { where: this.makeIdFilter(typeInfo.idField, typeInfo.idFieldType, resourceId) };
            // include IDs of relation fields so that they can be serialized
            this.includeRelationshipIds(type, args, 'include');
            // handle "include" query parameter
            let include;
            if (query === null || query === void 0 ? void 0 : query.include) {
                const { select, error, allIncludes } = this.buildRelationSelect(type, query.include);
                if (error) {
                    return error;
                }
                if (select) {
                    args.include = Object.assign(Object.assign({}, args.include), select);
                }
                include = allIncludes;
            }
            const entity = yield prisma[type].findUnique(args);
            if (entity) {
                return {
                    status: 200,
                    body: yield this.serializeItems(type, entity, { include }),
                };
            }
            else {
                return this.makeError('notFound');
            }
        });
    }
    processFetchRelated(prisma, type, resourceId, relationship, query) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const typeInfo = this.typeMap[type];
            if (!typeInfo) {
                return this.makeUnsupportedModelError(type);
            }
            const relationInfo = typeInfo.relationships[relationship];
            if (!relationInfo) {
                return this.makeUnsupportedRelationshipError(type, relationship, 404);
            }
            let select;
            // handle "include" query parameter
            let include;
            if (query === null || query === void 0 ? void 0 : query.include) {
                const { select: relationSelect, error, allIncludes } = this.buildRelationSelect(type, query.include);
                if (error) {
                    return error;
                }
                // trim the leading `$relationship.` from the include paths
                include = allIncludes
                    .filter((i) => i.startsWith(`${relationship}.`))
                    .map((i) => i.substring(`${relationship}.`.length));
                select = relationSelect;
            }
            select = select !== null && select !== void 0 ? select : { [relationship]: true };
            const args = {
                where: this.makeIdFilter(typeInfo.idField, typeInfo.idFieldType, resourceId),
                select,
            };
            if (relationInfo.isCollection) {
                // if related data is a collection, it can be filtered, sorted, and paginated
                const error = this.injectRelationQuery(relationInfo.type, select, relationship, query);
                if (error) {
                    return error;
                }
            }
            const entity = yield prisma[type].findUnique(args);
            let paginator;
            if (((_a = entity === null || entity === void 0 ? void 0 : entity._count) === null || _a === void 0 ? void 0 : _a[relationship]) !== undefined) {
                // build up paginator
                const total = (_b = entity === null || entity === void 0 ? void 0 : entity._count) === null || _b === void 0 ? void 0 : _b[relationship];
                const url = this.makeNormalizedUrl(`/${type}/${resourceId}/${relationship}`, query);
                const { offset, limit } = this.getPagination(query);
                paginator = this.makePaginator(url, offset, limit, total);
            }
            if (entity === null || entity === void 0 ? void 0 : entity[relationship]) {
                return {
                    status: 200,
                    body: yield this.serializeItems(relationInfo.type, entity[relationship], {
                        linkers: {
                            document: new ts_japi_1.Linker(() => this.makeLinkUrl(`/${type}/${resourceId}/${relationship}`)),
                            paginator,
                        },
                        include,
                    }),
                };
            }
            else {
                return this.makeError('notFound');
            }
        });
    }
    processReadRelationship(prisma, type, resourceId, relationship, query, modelMeta) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const typeInfo = this.typeMap[type];
            if (!typeInfo) {
                return this.makeUnsupportedModelError(type);
            }
            const relationInfo = typeInfo.relationships[relationship];
            if (!relationInfo) {
                return this.makeUnsupportedRelationshipError(type, relationship, 404);
            }
            const args = {
                where: this.makeIdFilter(typeInfo.idField, typeInfo.idFieldType, resourceId),
                select: this.makeIdSelect(type, modelMeta),
            };
            // include IDs of relation fields so that they can be serialized
            // this.includeRelationshipIds(type, args, 'select');
            args.select = Object.assign(Object.assign({}, args.select), { [relationship]: { select: this.makeIdSelect(relationInfo.type, modelMeta) } });
            let paginator;
            if (relationInfo.isCollection) {
                // if related data is a collection, it can be filtered, sorted, and paginated
                const error = this.injectRelationQuery(relationInfo.type, args.select, relationship, query);
                if (error) {
                    return error;
                }
            }
            const entity = yield prisma[type].findUnique(args);
            if (((_a = entity === null || entity === void 0 ? void 0 : entity._count) === null || _a === void 0 ? void 0 : _a[relationship]) !== undefined) {
                // build up paginator
                const total = (_b = entity === null || entity === void 0 ? void 0 : entity._count) === null || _b === void 0 ? void 0 : _b[relationship];
                const url = this.makeNormalizedUrl(`/${type}/${resourceId}/relationships/${relationship}`, query);
                const { offset, limit } = this.getPagination(query);
                paginator = this.makePaginator(url, offset, limit, total);
            }
            if (entity === null || entity === void 0 ? void 0 : entity[relationship]) {
                const serialized = yield this.serializeItems(relationInfo.type, entity[relationship], {
                    linkers: {
                        document: new ts_japi_1.Linker(() => this.makeLinkUrl(`/${type}/${resourceId}/relationships/${relationship}`)),
                        paginator,
                    },
                    onlyIdentifier: true,
                });
                return {
                    status: 200,
                    body: serialized,
                };
            }
            else {
                return this.makeError('notFound');
            }
        });
    }
    processCollectionRead(prisma, type, query) {
        return __awaiter(this, void 0, void 0, function* () {
            const typeInfo = this.typeMap[type];
            if (!typeInfo) {
                return this.makeUnsupportedModelError(type);
            }
            const args = {};
            // add filter
            const { filter, error: filterError } = this.buildFilter(type, query);
            if (filterError) {
                return filterError;
            }
            if (filter) {
                args.where = filter;
            }
            const { sort, error: sortError } = this.buildSort(type, query);
            if (sortError) {
                return sortError;
            }
            if (sort) {
                args.orderBy = sort;
            }
            // include IDs of relation fields so that they can be serialized
            this.includeRelationshipIds(type, args, 'include');
            // handle "include" query parameter
            let include;
            if (query === null || query === void 0 ? void 0 : query.include) {
                const { select, error, allIncludes } = this.buildRelationSelect(type, query.include);
                if (error) {
                    return error;
                }
                if (select) {
                    args.include = Object.assign(Object.assign({}, args.include), select);
                }
                include = allIncludes;
            }
            const { offset, limit } = this.getPagination(query);
            if (offset > 0) {
                args.skip = offset;
            }
            if (limit === Infinity) {
                const entities = yield prisma[type].findMany(args);
                const body = yield this.serializeItems(type, entities, { include });
                const total = entities.length;
                body.meta = this.addTotalCountToMeta(body.meta, total);
                return {
                    status: 200,
                    body: body,
                };
            }
            else {
                args.take = limit;
                const [entities, count] = yield Promise.all([
                    prisma[type].findMany(args),
                    prisma[type].count({ where: args.where }),
                ]);
                const total = count;
                const url = this.makeNormalizedUrl(`/${type}`, query);
                const options = {
                    include,
                    linkers: {
                        paginator: this.makePaginator(url, offset, limit, total),
                    },
                };
                const body = yield this.serializeItems(type, entities, options);
                body.meta = this.addTotalCountToMeta(body.meta, total);
                return {
                    status: 200,
                    body: body,
                };
            }
        });
    }
    addTotalCountToMeta(meta, total) {
        return meta ? Object.assign(meta, { total }) : Object.assign({}, { total });
    }
    makePaginator(baseUrl, offset, limit, total) {
        if (limit === Infinity) {
            return undefined;
        }
        const totalPages = Math.ceil(total / limit);
        return new ts_japi_1.Paginator(() => ({
            first: this.replaceURLSearchParams(baseUrl, { 'page[limit]': limit }),
            last: this.replaceURLSearchParams(baseUrl, {
                'page[offset]': (totalPages - 1) * limit,
            }),
            prev: offset - limit >= 0 && offset - limit <= total - 1
                ? this.replaceURLSearchParams(baseUrl, {
                    'page[offset]': offset - limit,
                    'page[limit]': limit,
                })
                : null,
            next: offset + limit <= total - 1
                ? this.replaceURLSearchParams(baseUrl, {
                    'page[offset]': offset + limit,
                    'page[limit]': limit,
                })
                : null,
        }));
    }
    processRequestBody(type, requestBody, zodSchemas, mode) {
        var _a, _b;
        let body = requestBody;
        if ((_a = body.meta) === null || _a === void 0 ? void 0 : _a.serialization) {
            // superjson deserialize body if a serialization meta is provided
            body = superjson_1.default.deserialize({ json: body, meta: body.meta.serialization });
        }
        const parsed = this.createUpdatePayloadSchema.parse(body);
        const attributes = parsed.data.attributes;
        if (attributes) {
            const schemaName = `${(0, upper_case_first_1.upperCaseFirst)(type)}${(0, upper_case_first_1.upperCaseFirst)(mode)}Schema`;
            // zod-parse attributes if a schema is provided
            const payloadSchema = (_b = zodSchemas === null || zodSchemas === void 0 ? void 0 : zodSchemas.models) === null || _b === void 0 ? void 0 : _b[schemaName];
            if (payloadSchema) {
                const parsed = payloadSchema.safeParse(attributes);
                if (!parsed.success) {
                    return {
                        error: this.makeError('invalidPayload', (0, zod_validation_error_1.fromZodError)(parsed.error).message, 422, runtime_1.CrudFailureReason.DATA_VALIDATION_VIOLATION, parsed.error),
                    };
                }
            }
        }
        return { attributes, relationships: parsed.data.relationships };
    }
    processCreate(prisma, type, _query, requestBody, zodSchemas) {
        return __awaiter(this, void 0, void 0, function* () {
            const typeInfo = this.typeMap[type];
            if (!typeInfo) {
                return this.makeUnsupportedModelError(type);
            }
            const { error, attributes, relationships } = this.processRequestBody(type, requestBody, zodSchemas, 'create');
            if (error) {
                return error;
            }
            const createPayload = { data: Object.assign({}, attributes) };
            // turn relationship payload into Prisma connect objects
            if (relationships) {
                for (const [key, data] of Object.entries(relationships)) {
                    if (!(data === null || data === void 0 ? void 0 : data.data)) {
                        return this.makeError('invalidRelationData');
                    }
                    const relationInfo = typeInfo.relationships[key];
                    if (!relationInfo) {
                        return this.makeUnsupportedRelationshipError(type, key, 400);
                    }
                    if (relationInfo.isCollection) {
                        createPayload.data[key] = {
                            connect: (0, runtime_1.enumerate)(data.data).map((item) => ({
                                [relationInfo.idField]: this.coerce(relationInfo.idFieldType, item.id),
                            })),
                        };
                    }
                    else {
                        if (typeof data.data !== 'object') {
                            return this.makeError('invalidRelationData');
                        }
                        createPayload.data[key] = {
                            connect: { [relationInfo.idField]: this.coerce(relationInfo.idFieldType, data.data.id) },
                        };
                    }
                    // make sure ID fields are included for result serialization
                    createPayload.include = Object.assign(Object.assign({}, createPayload.include), { [key]: { select: { [relationInfo.idField]: true } } });
                }
            }
            const entity = yield prisma[type].create(createPayload);
            return {
                status: 201,
                body: yield this.serializeItems(type, entity),
            };
        });
    }
    processRelationshipCRUD(prisma, mode, type, resourceId, relationship, query, requestBody) {
        return __awaiter(this, void 0, void 0, function* () {
            const typeInfo = this.typeMap[type];
            if (!typeInfo) {
                return this.makeUnsupportedModelError(type);
            }
            const relationInfo = typeInfo.relationships[relationship];
            if (!relationInfo) {
                return this.makeUnsupportedRelationshipError(type, relationship, 404);
            }
            if (!relationInfo.isCollection && mode !== 'update') {
                // to-one relation can only be updated
                return this.makeError('invalidVerb');
            }
            const updateArgs = {
                where: this.makeIdFilter(typeInfo.idField, typeInfo.idFieldType, resourceId),
                select: { [typeInfo.idField]: true, [relationship]: { select: { [relationInfo.idField]: true } } },
            };
            if (!relationInfo.isCollection) {
                // zod-parse payload
                const parsed = this.updateSingleRelationSchema.safeParse(requestBody);
                if (!parsed.success) {
                    return this.makeError('invalidPayload', (0, zod_validation_error_1.fromZodError)(parsed.error).message, undefined, runtime_1.CrudFailureReason.DATA_VALIDATION_VIOLATION, parsed.error);
                }
                if (parsed.data.data === null) {
                    if (!relationInfo.isOptional) {
                        // cannot disconnect a required relation
                        return this.makeError('invalidPayload');
                    }
                    // set null -> disconnect
                    updateArgs.data = {
                        [relationship]: {
                            disconnect: true,
                        },
                    };
                }
                else {
                    updateArgs.data = {
                        [relationship]: {
                            connect: {
                                [relationInfo.idField]: this.coerce(relationInfo.idFieldType, parsed.data.data.id),
                            },
                        },
                    };
                }
            }
            else {
                // zod-parse payload
                const parsed = this.updateCollectionRelationSchema.safeParse(requestBody);
                if (!parsed.success) {
                    return this.makeError('invalidPayload', (0, zod_validation_error_1.fromZodError)(parsed.error).message, undefined, runtime_1.CrudFailureReason.DATA_VALIDATION_VIOLATION, parsed.error);
                }
                // create -> connect, delete -> disconnect, update -> set
                const relationVerb = mode === 'create' ? 'connect' : mode === 'delete' ? 'disconnect' : 'set';
                updateArgs.data = {
                    [relationship]: {
                        [relationVerb]: (0, runtime_1.enumerate)(parsed.data.data).map((item) => ({
                            [relationInfo.idField]: this.coerce(relationInfo.idFieldType, item.id),
                        })),
                    },
                };
            }
            const entity = yield prisma[type].update(updateArgs);
            const serialized = yield this.serializeItems(relationInfo.type, entity[relationship], {
                linkers: {
                    document: new ts_japi_1.Linker(() => this.makeLinkUrl(`/${type}/${resourceId}/relationships/${relationship}`)),
                },
                onlyIdentifier: true,
            });
            return {
                status: 200,
                body: serialized,
            };
        });
    }
    processUpdate(prisma, type, resourceId, _query, requestBody, zodSchemas) {
        return __awaiter(this, void 0, void 0, function* () {
            const typeInfo = this.typeMap[type];
            if (!typeInfo) {
                return this.makeUnsupportedModelError(type);
            }
            const { error, attributes, relationships } = this.processRequestBody(type, requestBody, zodSchemas, 'update');
            if (error) {
                return error;
            }
            const updatePayload = {
                where: this.makeIdFilter(typeInfo.idField, typeInfo.idFieldType, resourceId),
                data: Object.assign({}, attributes),
            };
            // turn relationships into prisma payload
            if (relationships) {
                for (const [key, data] of Object.entries(relationships)) {
                    if (!(data === null || data === void 0 ? void 0 : data.data)) {
                        return this.makeError('invalidRelationData');
                    }
                    const relationInfo = typeInfo.relationships[key];
                    if (!relationInfo) {
                        return this.makeUnsupportedRelationshipError(type, key, 400);
                    }
                    if (relationInfo.isCollection) {
                        updatePayload.data[key] = {
                            set: (0, runtime_1.enumerate)(data.data).map((item) => ({
                                [relationInfo.idField]: this.coerce(relationInfo.idFieldType, item.id),
                            })),
                        };
                    }
                    else {
                        if (typeof data.data !== 'object') {
                            return this.makeError('invalidRelationData');
                        }
                        updatePayload.data[key] = {
                            set: { [relationInfo.idField]: this.coerce(relationInfo.idFieldType, data.data.id) },
                        };
                    }
                    updatePayload.include = Object.assign(Object.assign({}, updatePayload.include), { [key]: { select: { [relationInfo.idField]: true } } });
                }
            }
            const entity = yield prisma[type].update(updatePayload);
            return {
                status: 200,
                body: yield this.serializeItems(type, entity),
            };
        });
    }
    processDelete(prisma, type, resourceId) {
        return __awaiter(this, void 0, void 0, function* () {
            const typeInfo = this.typeMap[type];
            if (!typeInfo) {
                return this.makeUnsupportedModelError(type);
            }
            yield prisma[type].delete({
                where: this.makeIdFilter(typeInfo.idField, typeInfo.idFieldType, resourceId),
            });
            return {
                status: 204,
                body: undefined,
            };
        });
    }
    //#region utilities
    buildTypeMap(logger, modelMeta) {
        this.typeMap = {};
        for (const [model, { fields }] of Object.entries(modelMeta.models)) {
            const idFields = (0, runtime_1.getIdFields)(modelMeta, model);
            if (idFields.length === 0) {
                (0, utils_1.logWarning)(logger, `Not including model ${model} in the API because it has no ID field`);
                continue;
            }
            if (idFields.length > 1) {
                (0, utils_1.logWarning)(logger, `Not including model ${model} in the API because it has multiple ID fields`);
                continue;
            }
            this.typeMap[model] = {
                idField: idFields[0].name,
                idFieldType: idFields[0].type,
                relationships: {},
                fields,
            };
            for (const [field, fieldInfo] of Object.entries(fields)) {
                if (!fieldInfo.isDataModel) {
                    continue;
                }
                const fieldTypeIdFields = (0, runtime_1.getIdFields)(modelMeta, fieldInfo.type);
                if (fieldTypeIdFields.length === 0) {
                    (0, utils_1.logWarning)(logger, `Not including relation ${model}.${field} in the API because it has no ID field`);
                    continue;
                }
                if (fieldTypeIdFields.length > 1) {
                    (0, utils_1.logWarning)(logger, `Not including relation ${model}.${field} in the API because it has multiple ID fields`);
                    continue;
                }
                this.typeMap[model].relationships[field] = {
                    type: fieldInfo.type,
                    idField: fieldTypeIdFields[0].name,
                    idFieldType: fieldTypeIdFields[0].type,
                    isCollection: !!fieldInfo.isArray,
                    isOptional: !!fieldInfo.isOptional,
                };
            }
        }
    }
    makeLinkUrl(path) {
        return `${this.options.endpoint}${path}`;
    }
    buildSerializers(modelMeta) {
        this.serializers = new Map();
        const linkers = {};
        for (const model of Object.keys(modelMeta.models)) {
            const ids = (0, runtime_1.getIdFields)(modelMeta, model);
            if (ids.length !== 1) {
                continue;
            }
            const linker = new ts_japi_1.Linker((items) => Array.isArray(items)
                ? this.makeLinkUrl(`/${model}`)
                : this.makeLinkUrl(`/${model}/${this.getId(model, items, modelMeta)}`));
            linkers[model] = linker;
            let projection = {};
            for (const [field, fieldMeta] of Object.entries(modelMeta.models[model].fields)) {
                if (fieldMeta.isDataModel) {
                    projection[field] = 0;
                }
            }
            if (Object.keys(projection).length === 0) {
                projection = null;
            }
            const serializer = new ts_japi_1.Serializer(model, {
                version: '1.1',
                idKey: ids[0].name,
                linkers: {
                    resource: linker,
                    document: linker,
                },
                projection,
            });
            this.serializers.set(model, serializer);
        }
        // set relators
        for (const model of Object.keys(modelMeta.models)) {
            const serializer = this.serializers.get(model);
            if (!serializer) {
                continue;
            }
            const relators = {};
            for (const [field, fieldMeta] of Object.entries(modelMeta.models[model].fields)) {
                if (!fieldMeta.isDataModel) {
                    continue;
                }
                const fieldSerializer = this.serializers.get((0, lower_case_first_1.lowerCaseFirst)(fieldMeta.type));
                if (!fieldSerializer) {
                    continue;
                }
                const fieldIds = (0, runtime_1.getIdFields)(modelMeta, fieldMeta.type);
                if (fieldIds.length === 1) {
                    const relator = new ts_japi_1.Relator((data) => __awaiter(this, void 0, void 0, function* () {
                        return data[field];
                    }), fieldSerializer, {
                        relatedName: field,
                        linkers: {
                            related: new ts_japi_1.Linker((primary) => this.makeLinkUrl(`/${(0, lower_case_first_1.lowerCaseFirst)(model)}/${this.getId(model, primary, modelMeta)}/${field}`)),
                            relationship: new ts_japi_1.Linker((primary) => this.makeLinkUrl(`/${(0, lower_case_first_1.lowerCaseFirst)(model)}/${this.getId(model, primary, modelMeta)}/relationships/${field}`)),
                        },
                    });
                    relators[field] = relator;
                }
            }
            serializer.setRelators(relators);
        }
    }
    getId(model, data, modelMeta) {
        if (!data) {
            return undefined;
        }
        const ids = (0, runtime_1.getIdFields)(modelMeta, model);
        if (ids.length === 1) {
            return data[ids[0].name];
        }
        else {
            return undefined;
        }
    }
    serializeItems(model, items, options) {
        return __awaiter(this, void 0, void 0, function* () {
            model = (0, lower_case_first_1.lowerCaseFirst)(model);
            const serializer = this.serializers.get(model);
            if (!serializer) {
                throw new Error(`serializer not found for model ${model}`);
            }
            // serialize to JSON:API structure
            const serialized = yield serializer.serialize(items, options);
            // convert the serialization result to plain object otherwise SuperJSON won't work
            const plainResult = this.toPlainObject(serialized);
            // superjson serialize the result
            const { json, meta } = superjson_1.default.serialize(plainResult);
            const result = json;
            if (meta) {
                result.meta = Object.assign(Object.assign({}, result.meta), { serialization: meta });
            }
            return result;
        });
    }
    toPlainObject(data) {
        if (data === undefined || data === null) {
            return data;
        }
        if (Array.isArray(data)) {
            return data.map((item) => this.toPlainObject(item));
        }
        if (typeof data === 'object') {
            if (typeof data.toJSON === 'function') {
                // custom toJSON function
                return data.toJSON();
            }
            const result = {};
            for (const [field, value] of Object.entries(data)) {
                if (value === undefined || typeof value === 'function') {
                    // trim undefined and functions
                    continue;
                }
                else if (field === 'attributes') {
                    // don't visit into entity data
                    result[field] = value;
                }
                else {
                    result[field] = this.toPlainObject(value);
                }
            }
            return result;
        }
        return data;
    }
    replaceURLSearchParams(url, params) {
        const r = new URL(url);
        for (const [key, value] of Object.entries(params)) {
            r.searchParams.set(key, value.toString());
        }
        return r.toString();
    }
    makeIdFilter(idField, idFieldType, resourceId) {
        return { [idField]: this.coerce(idFieldType, resourceId) };
    }
    makeIdSelect(model, modelMeta) {
        const idFields = (0, runtime_1.getIdFields)(modelMeta, model);
        if (idFields.length === 0) {
            throw this.errors.noId;
        }
        else if (idFields.length > 1) {
            throw this.errors.multiId;
        }
        return { [idFields[0].name]: true };
    }
    includeRelationshipIds(model, args, mode) {
        const typeInfo = this.typeMap[model];
        if (!typeInfo) {
            return;
        }
        for (const [relation, relationInfo] of Object.entries(typeInfo.relationships)) {
            args[mode] = Object.assign(Object.assign({}, args[mode]), { [relation]: { select: { [relationInfo.idField]: true } } });
        }
    }
    coerce(type, value) {
        if (typeof value === 'string') {
            if (type === 'Int' || type === 'BigInt') {
                const parsed = parseInt(value);
                if (isNaN(parsed)) {
                    throw new InvalidValueError(`invalid ${type} value: ${value}`);
                }
                return parsed;
            }
            else if (type === 'Float' || type === 'Decimal') {
                const parsed = parseFloat(value);
                if (isNaN(parsed)) {
                    throw new InvalidValueError(`invalid ${type} value: ${value}`);
                }
                return parsed;
            }
            else if (type === 'Boolean') {
                if (value === 'true') {
                    return true;
                }
                else if (value === 'false') {
                    return false;
                }
                else {
                    throw new InvalidValueError(`invalid ${type} value: ${value}`);
                }
            }
        }
        return value;
    }
    makeNormalizedUrl(path, query) {
        const url = new URL(this.makeLinkUrl(path));
        for (const [key, value] of Object.entries(query !== null && query !== void 0 ? query : {})) {
            if (key.startsWith('filter[') ||
                key.startsWith('sort[') ||
                key.startsWith('include[') ||
                key.startsWith('fields[')) {
                for (const v of (0, runtime_1.enumerate)(value)) {
                    url.searchParams.append(key, v);
                }
            }
        }
        return url.toString();
    }
    getPagination(query) {
        var _a, _b;
        if (!query) {
            return { offset: 0, limit: (_a = this.options.pageSize) !== null && _a !== void 0 ? _a : DEFAULT_PAGE_SIZE };
        }
        let offset = 0;
        if (query['page[offset]']) {
            const value = query['page[offset]'];
            const offsetText = Array.isArray(value) ? value[value.length - 1] : value;
            offset = parseInt(offsetText);
            if (isNaN(offset) || offset < 0) {
                offset = 0;
            }
        }
        let pageSizeOption = (_b = this.options.pageSize) !== null && _b !== void 0 ? _b : DEFAULT_PAGE_SIZE;
        if (pageSizeOption <= 0) {
            pageSizeOption = DEFAULT_PAGE_SIZE;
        }
        let limit = pageSizeOption;
        if (query['page[limit]']) {
            const value = query['page[limit]'];
            const limitText = Array.isArray(value) ? value[value.length - 1] : value;
            limit = parseInt(limitText);
            if (isNaN(limit) || limit <= 0) {
                limit = pageSizeOption;
            }
            limit = Math.min(pageSizeOption, limit);
        }
        return { offset, limit };
    }
    buildFilter(type, query) {
        if (!query) {
            return { filter: undefined, error: undefined };
        }
        const typeInfo = this.typeMap[(0, lower_case_first_1.lowerCaseFirst)(type)];
        if (!typeInfo) {
            return { filter: undefined, error: this.makeUnsupportedModelError(type) };
        }
        const items = [];
        let currType = typeInfo;
        for (const [key, value] of Object.entries(query)) {
            if (!value) {
                continue;
            }
            // try matching query parameter key as "filter[x][y]..."
            const match = key.match(this.filterParamPattern);
            if (!match || !match.groups) {
                continue;
            }
            const filterKeys = match.groups.match
                .replaceAll(/[[\]]/g, ' ')
                .split(' ')
                .filter((i) => i);
            if (!filterKeys.length) {
                continue;
            }
            // turn filter into a nested Prisma query object
            const item = {};
            let curr = item;
            for (const filterValue of (0, runtime_1.enumerate)(value)) {
                for (let i = 0; i < filterKeys.length; i++) {
                    // extract filter operation from (optional) trailing $op
                    let filterKey = filterKeys[i];
                    let filterOp;
                    const pos = filterKey.indexOf('$');
                    if (pos > 0) {
                        filterOp = filterKey.substring(pos + 1);
                        filterKey = filterKey.substring(0, pos);
                    }
                    if (!!filterOp && !FilterOperations.includes(filterOp)) {
                        return {
                            filter: undefined,
                            error: this.makeError('invalidFilter', `invalid filter operation: ${filterOp}`),
                        };
                    }
                    const fieldInfo = filterKey === 'id'
                        ? Object.values(currType.fields).find((f) => f.isId)
                        : currType.fields[filterKey];
                    if (!fieldInfo) {
                        return { filter: undefined, error: this.makeError('invalidFilter') };
                    }
                    if (!fieldInfo.isDataModel) {
                        // regular field
                        if (i !== filterKeys.length - 1) {
                            // must be the last segment of a filter
                            return { filter: undefined, error: this.makeError('invalidFilter') };
                        }
                        curr[fieldInfo.name] = this.makeFilterValue(fieldInfo, filterValue, filterOp);
                    }
                    else {
                        // relation field
                        if (i === filterKeys.length - 1) {
                            curr[fieldInfo.name] = this.makeFilterValue(fieldInfo, filterValue, filterOp);
                        }
                        else {
                            // keep going
                            if (fieldInfo.isArray) {
                                // collection filtering implies "some" operation
                                curr[fieldInfo.name] = { some: {} };
                                curr = curr[fieldInfo.name].some;
                            }
                            else {
                                curr = curr[fieldInfo.name] = {};
                            }
                            currType = this.typeMap[(0, lower_case_first_1.lowerCaseFirst)(fieldInfo.type)];
                        }
                    }
                }
                items.push(item);
            }
        }
        if (items.length === 0) {
            return { filter: undefined, error: undefined };
        }
        else {
            // combine filters with AND
            return { filter: items.length === 1 ? items[0] : { AND: items }, error: undefined };
        }
    }
    buildSort(type, query) {
        if (!(query === null || query === void 0 ? void 0 : query['sort'])) {
            return { sort: undefined, error: undefined };
        }
        const typeInfo = this.typeMap[(0, lower_case_first_1.lowerCaseFirst)(type)];
        if (!typeInfo) {
            return { sort: undefined, error: this.makeUnsupportedModelError(type) };
        }
        const result = [];
        for (const sortSpec of (0, runtime_1.enumerate)(query['sort'])) {
            const sortFields = sortSpec.split(',').filter((i) => i);
            for (const sortField of sortFields) {
                const dir = sortField.startsWith('-') ? 'desc' : 'asc';
                const cleanedSortField = sortField.startsWith('-') ? sortField.substring(1) : sortField;
                const parts = cleanedSortField.split('.').filter((i) => i);
                const sortItem = {};
                let curr = sortItem;
                let currType = typeInfo;
                for (let i = 0; i < parts.length; i++) {
                    const part = parts[i];
                    const fieldInfo = currType.fields[part];
                    if (!fieldInfo || fieldInfo.isArray) {
                        return {
                            sort: undefined,
                            error: this.makeError('invalidSort', 'sorting by array field is not supported'),
                        };
                    }
                    if (i === parts.length - 1) {
                        if (fieldInfo.isDataModel) {
                            // relation field: sort by id
                            const relationType = this.typeMap[(0, lower_case_first_1.lowerCaseFirst)(fieldInfo.type)];
                            if (!relationType) {
                                return { sort: undefined, error: this.makeUnsupportedModelError(fieldInfo.type) };
                            }
                            curr[fieldInfo.name] = { [relationType.idField]: dir };
                        }
                        else {
                            // regular field
                            curr[fieldInfo.name] = dir;
                        }
                    }
                    else {
                        if (!fieldInfo.isDataModel) {
                            // must be a relation field
                            return {
                                sort: undefined,
                                error: this.makeError('invalidSort', 'intermediate sort segments must be relationships'),
                            };
                        }
                        // keep going
                        curr = curr[fieldInfo.name] = {};
                        currType = this.typeMap[(0, lower_case_first_1.lowerCaseFirst)(fieldInfo.type)];
                        if (!currType) {
                            return { sort: undefined, error: this.makeUnsupportedModelError(fieldInfo.type) };
                        }
                    }
                    result.push(sortItem);
                }
            }
        }
        return { sort: result, error: undefined };
    }
    buildRelationSelect(type, include) {
        var _a;
        const typeInfo = this.typeMap[(0, lower_case_first_1.lowerCaseFirst)(type)];
        if (!typeInfo) {
            return { select: undefined, error: this.makeUnsupportedModelError(type) };
        }
        const result = {};
        const allIncludes = [];
        for (const includeItem of (0, runtime_1.enumerate)(include)) {
            const inclusions = includeItem.split(',').filter((i) => i);
            for (const inclusion of inclusions) {
                allIncludes.push(inclusion);
                const parts = inclusion.split('.');
                let currPayload = result;
                let currType = typeInfo;
                for (let i = 0; i < parts.length; i++) {
                    const relation = parts[i];
                    const relationInfo = currType.relationships[relation];
                    if (!relationInfo) {
                        return { select: undefined, error: this.makeUnsupportedRelationshipError(type, relation, 400) };
                    }
                    currType = this.typeMap[(0, lower_case_first_1.lowerCaseFirst)(relationInfo.type)];
                    if (!currType) {
                        return { select: undefined, error: this.makeUnsupportedModelError(relationInfo.type) };
                    }
                    if (i !== parts.length - 1) {
                        currPayload[relation] = { include: Object.assign({}, (_a = currPayload[relation]) === null || _a === void 0 ? void 0 : _a.include) };
                        currPayload = currPayload[relation].include;
                    }
                    else {
                        currPayload[relation] = true;
                    }
                }
            }
        }
        return { select: result, error: undefined, allIncludes };
    }
    makeFilterValue(fieldInfo, value, op) {
        if (fieldInfo.isDataModel) {
            // relation filter is converted to an ID filter
            const info = this.typeMap[(0, lower_case_first_1.lowerCaseFirst)(fieldInfo.type)];
            if (fieldInfo.isArray) {
                // filtering a to-many relation, imply 'some' operator
                const values = value.split(',').filter((i) => i);
                const filterValue = values.length > 1
                    ? { OR: values.map((v) => this.makeIdFilter(info.idField, info.idFieldType, v)) }
                    : this.makeIdFilter(info.idField, info.idFieldType, value);
                return { some: filterValue };
            }
            else {
                return { is: this.makeIdFilter(info.idField, info.idFieldType, value) };
            }
        }
        else {
            const coerced = this.coerce(fieldInfo.type, value);
            switch (op) {
                case 'icontains':
                    return { contains: coerced, mode: 'insensitive' };
                case 'hasSome':
                case 'hasEvery': {
                    const values = value
                        .split(',')
                        .filter((i) => i)
                        .map((v) => this.coerce(fieldInfo.type, v));
                    return { [op]: values };
                }
                case 'isEmpty':
                    if (value !== 'true' && value !== 'false') {
                        throw new InvalidValueError(`Not a boolean: ${value}`);
                    }
                    return { isEmpty: value === 'true' ? true : false };
                default:
                    return op ? { [op]: coerced } : { equals: coerced };
            }
        }
    }
    injectRelationQuery(type, injectTarget, injectKey, query) {
        const { filter, error: filterError } = this.buildFilter(type, query);
        if (filterError) {
            return filterError;
        }
        if (filter) {
            injectTarget[injectKey] = Object.assign(Object.assign({}, injectTarget[injectKey]), { where: filter });
        }
        const { sort, error: sortError } = this.buildSort(type, query);
        if (sortError) {
            return sortError;
        }
        if (sort) {
            injectTarget[injectKey] = Object.assign(Object.assign({}, injectTarget[injectKey]), { orderBy: sort });
        }
        const pagination = this.getPagination(query);
        const offset = pagination.offset;
        if (offset > 0) {
            // inject skip
            injectTarget[injectKey] = Object.assign(Object.assign({}, injectTarget[injectKey]), { skip: offset });
        }
        const limit = pagination.limit;
        if (limit !== Infinity) {
            // inject take
            injectTarget[injectKey] = Object.assign(Object.assign({}, injectTarget[injectKey]), { take: limit });
            // include a count query  for the relationship
            injectTarget._count = { select: { [injectKey]: true } };
        }
    }
    handlePrismaError(err) {
        var _a, _b, _c, _d;
        if ((0, runtime_1.isPrismaClientKnownRequestError)(err)) {
            if (err.code === runtime_1.PrismaErrorCode.CONSTRAINED_FAILED) {
                if (((_a = err.meta) === null || _a === void 0 ? void 0 : _a.reason) === runtime_1.CrudFailureReason.DATA_VALIDATION_VIOLATION) {
                    return this.makeError('validationError', undefined, 422, (_b = err.meta) === null || _b === void 0 ? void 0 : _b.reason, (_c = err.meta) === null || _c === void 0 ? void 0 : _c.zodErrors);
                }
                else {
                    return this.makeError('forbidden', undefined, 403, (_d = err.meta) === null || _d === void 0 ? void 0 : _d.reason);
                }
            }
            else if (err.code === 'P2025' || err.code === 'P2018') {
                return this.makeError('notFound');
            }
            else {
                return {
                    status: 400,
                    body: {
                        errors: [
                            {
                                status: 400,
                                code: 'prisma-error',
                                prismaCode: err.code,
                                title: 'Prisma error',
                                detail: err.message,
                            },
                        ],
                    },
                };
            }
        }
        else {
            const _err = err;
            return this.makeError('unknownError', `${_err.message}\n${_err.stack}`);
        }
    }
    makeError(code, detail, status, reason, zodErrors) {
        const error = {
            status: status !== null && status !== void 0 ? status : this.errors[code].status,
            code: (0, change_case_1.paramCase)(code),
            title: this.errors[code].title,
        };
        if (detail) {
            error.detail = detail;
        }
        if (reason) {
            error.reason = reason;
        }
        if (zodErrors) {
            error.zodErrors = zodErrors;
        }
        return {
            status: status !== null && status !== void 0 ? status : this.errors[code].status,
            body: {
                errors: [error],
            },
        };
    }
    makeUnsupportedModelError(model) {
        return this.makeError('unsupportedModel', `Model ${model} doesn't exist`);
    }
    makeUnsupportedRelationshipError(model, relationship, status) {
        return this.makeError('unsupportedRelationship', `Relationship ${model}.${relationship} doesn't exist`, status);
    }
}
function makeHandler(options) {
    const handler = new RequestHandler(options);
    return handler.handleRequest.bind(handler);
}
exports.default = makeHandler;
exports.RestApiHandler = makeHandler;
//# sourceMappingURL=index.js.map