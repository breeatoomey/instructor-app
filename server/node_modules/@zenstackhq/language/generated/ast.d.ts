/******************************************************************************
 * This file was generated by langium-cli 1.3.1.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/
import type { AstNode, Reference, ReferenceInfo, TypeMetaData } from 'langium';
import { AbstractAstReflection } from 'langium';
export declare const ZModelTerminals: {
    WS: RegExp;
    INTERNAL_ATTRIBUTE_NAME: RegExp;
    MODEL_ATTRIBUTE_NAME: RegExp;
    FIELD_ATTRIBUTE_NAME: RegExp;
    ID: RegExp;
    STRING: RegExp;
    NUMBER: RegExp;
    TRIPLE_SLASH_COMMENT: RegExp;
    ML_COMMENT: RegExp;
    SL_COMMENT: RegExp;
};
export type AbstractDeclaration = Attribute | DataModel | DataSource | Enum | FunctionDecl | GeneratorDecl | Plugin;
export declare const AbstractDeclaration = "AbstractDeclaration";
export declare function isAbstractDeclaration(item: unknown): item is AbstractDeclaration;
export type Boolean = boolean;
export declare function isBoolean(item: unknown): item is Boolean;
export type BuiltinType = 'BigInt' | 'Boolean' | 'Bytes' | 'DateTime' | 'Decimal' | 'Float' | 'Int' | 'Json' | 'String';
export declare function isBuiltinType(item: unknown): item is BuiltinType;
export type ConfigExpr = ConfigArrayExpr | InvocationExpr | LiteralExpr;
export declare const ConfigExpr = "ConfigExpr";
export declare function isConfigExpr(item: unknown): item is ConfigExpr;
export type Expression = ArrayExpr | BinaryExpr | InvocationExpr | LiteralExpr | MemberAccessExpr | NullExpr | ObjectExpr | ReferenceExpr | ThisExpr | UnaryExpr;
export declare const Expression = "Expression";
export declare function isExpression(item: unknown): item is Expression;
export type ExpressionType = 'Any' | 'Boolean' | 'DateTime' | 'Float' | 'Int' | 'Null' | 'Object' | 'String' | 'Unsupported';
export declare function isExpressionType(item: unknown): item is ExpressionType;
export type LiteralExpr = BooleanLiteral | NumberLiteral | StringLiteral;
export declare const LiteralExpr = "LiteralExpr";
export declare function isLiteralExpr(item: unknown): item is LiteralExpr;
export type ReferenceTarget = DataModelField | EnumField | FunctionParam;
export declare const ReferenceTarget = "ReferenceTarget";
export declare function isReferenceTarget(item: unknown): item is ReferenceTarget;
export type RegularID = 'abstract' | 'attribute' | 'datasource' | 'enum' | 'import' | 'in' | 'model' | 'plugin' | 'view' | string;
export declare function isRegularID(item: unknown): item is RegularID;
export type RegularIDWithTypeNames = 'Any' | 'BigInt' | 'Boolean' | 'Bytes' | 'DateTime' | 'Decimal' | 'Float' | 'Int' | 'Json' | 'Null' | 'Object' | 'String' | 'Unsupported' | RegularID;
export declare function isRegularIDWithTypeNames(item: unknown): item is RegularIDWithTypeNames;
export type TypeDeclaration = DataModel | Enum;
export declare const TypeDeclaration = "TypeDeclaration";
export declare function isTypeDeclaration(item: unknown): item is TypeDeclaration;
export interface Argument extends AstNode {
    readonly $container: InvocationExpr;
    readonly $type: 'Argument';
    value: Expression;
}
export declare const Argument = "Argument";
export declare function isArgument(item: unknown): item is Argument;
export interface ArrayExpr extends AstNode {
    readonly $container: Argument | ArrayExpr | AttributeArg | BinaryExpr | ConfigArrayExpr | ConfigField | ConfigInvocationArg | FieldInitializer | FunctionDecl | MemberAccessExpr | PluginField | ReferenceArg | UnaryExpr | UnsupportedFieldType;
    readonly $type: 'ArrayExpr';
    items: Array<Expression>;
}
export declare const ArrayExpr = "ArrayExpr";
export declare function isArrayExpr(item: unknown): item is ArrayExpr;
export interface Attribute extends AstNode {
    readonly $container: Model;
    readonly $type: 'Attribute';
    attributes: Array<InternalAttribute>;
    comments: Array<string>;
    name: string;
    params: Array<AttributeParam>;
}
export declare const Attribute = "Attribute";
export declare function isAttribute(item: unknown): item is Attribute;
export interface AttributeArg extends AstNode {
    readonly $container: DataModelAttribute | DataModelFieldAttribute | InternalAttribute;
    readonly $type: 'AttributeArg';
    name?: RegularID;
    value: Expression;
}
export declare const AttributeArg = "AttributeArg";
export declare function isAttributeArg(item: unknown): item is AttributeArg;
export interface AttributeParam extends AstNode {
    readonly $container: Attribute;
    readonly $type: 'AttributeParam';
    attributes: Array<InternalAttribute>;
    comments: Array<string>;
    default: boolean;
    name: RegularID;
    type: AttributeParamType;
}
export declare const AttributeParam = "AttributeParam";
export declare function isAttributeParam(item: unknown): item is AttributeParam;
export interface AttributeParamType extends AstNode {
    readonly $container: AttributeParam;
    readonly $type: 'AttributeParamType';
    array: boolean;
    optional: boolean;
    reference?: Reference<TypeDeclaration>;
    type?: 'ContextType' | 'FieldReference' | 'TransitiveFieldReference' | ExpressionType;
}
export declare const AttributeParamType = "AttributeParamType";
export declare function isAttributeParamType(item: unknown): item is AttributeParamType;
export interface BinaryExpr extends AstNode {
    readonly $container: Argument | ArrayExpr | AttributeArg | BinaryExpr | ConfigArrayExpr | ConfigField | ConfigInvocationArg | FieldInitializer | FunctionDecl | MemberAccessExpr | PluginField | ReferenceArg | UnaryExpr | UnsupportedFieldType;
    readonly $type: 'BinaryExpr';
    left: Expression;
    operator: '!' | '!=' | '&&' | '<' | '<=' | '==' | '>' | '>=' | '?' | '^' | 'in' | '||';
    right: Expression;
}
export declare const BinaryExpr = "BinaryExpr";
export declare function isBinaryExpr(item: unknown): item is BinaryExpr;
export interface BooleanLiteral extends AstNode {
    readonly $container: Argument | ArrayExpr | AttributeArg | BinaryExpr | ConfigArrayExpr | ConfigField | ConfigInvocationArg | FieldInitializer | FunctionDecl | MemberAccessExpr | PluginField | ReferenceArg | UnaryExpr | UnsupportedFieldType;
    readonly $type: 'BooleanLiteral';
    value: Boolean;
}
export declare const BooleanLiteral = "BooleanLiteral";
export declare function isBooleanLiteral(item: unknown): item is BooleanLiteral;
export interface ConfigArrayExpr extends AstNode {
    readonly $container: Argument | ArrayExpr | AttributeArg | BinaryExpr | ConfigArrayExpr | ConfigField | ConfigInvocationArg | FieldInitializer | FunctionDecl | MemberAccessExpr | PluginField | ReferenceArg | UnaryExpr | UnsupportedFieldType;
    readonly $type: 'ConfigArrayExpr';
    items: Array<ConfigInvocationExpr | LiteralExpr>;
}
export declare const ConfigArrayExpr = "ConfigArrayExpr";
export declare function isConfigArrayExpr(item: unknown): item is ConfigArrayExpr;
export interface ConfigField extends AstNode {
    readonly $container: DataSource | GeneratorDecl;
    readonly $type: 'ConfigField';
    name: RegularID;
    value: ConfigExpr;
}
export declare const ConfigField = "ConfigField";
export declare function isConfigField(item: unknown): item is ConfigField;
export interface ConfigInvocationArg extends AstNode {
    readonly $container: ConfigInvocationExpr;
    readonly $type: 'ConfigInvocationArg';
    name: string;
    value: LiteralExpr;
}
export declare const ConfigInvocationArg = "ConfigInvocationArg";
export declare function isConfigInvocationArg(item: unknown): item is ConfigInvocationArg;
export interface ConfigInvocationExpr extends AstNode {
    readonly $container: ConfigArrayExpr;
    readonly $type: 'ConfigInvocationExpr';
    args: Array<ConfigInvocationArg>;
    name: string;
}
export declare const ConfigInvocationExpr = "ConfigInvocationExpr";
export declare function isConfigInvocationExpr(item: unknown): item is ConfigInvocationExpr;
export interface DataModel extends AstNode {
    readonly $container: Model;
    readonly $type: 'DataModel';
    attributes: Array<DataModelAttribute>;
    comments: Array<string>;
    fields: Array<DataModelField>;
    isAbstract: boolean;
    isView: boolean;
    name: RegularID;
    superTypes: Array<Reference<DataModel>>;
}
export declare const DataModel = "DataModel";
export declare function isDataModel(item: unknown): item is DataModel;
export interface DataModelAttribute extends AstNode {
    readonly $container: DataModel | Enum;
    readonly $type: 'DataModelAttribute';
    args: Array<AttributeArg>;
    decl: Reference<Attribute>;
}
export declare const DataModelAttribute = "DataModelAttribute";
export declare function isDataModelAttribute(item: unknown): item is DataModelAttribute;
export interface DataModelField extends AstNode {
    readonly $container: DataModel | Enum | FunctionDecl;
    readonly $type: 'DataModelField';
    attributes: Array<DataModelFieldAttribute>;
    comments: Array<string>;
    name: RegularIDWithTypeNames;
    type: DataModelFieldType;
}
export declare const DataModelField = "DataModelField";
export declare function isDataModelField(item: unknown): item is DataModelField;
export interface DataModelFieldAttribute extends AstNode {
    readonly $container: DataModelField | EnumField;
    readonly $type: 'DataModelFieldAttribute';
    args: Array<AttributeArg>;
    decl: Reference<Attribute>;
}
export declare const DataModelFieldAttribute = "DataModelFieldAttribute";
export declare function isDataModelFieldAttribute(item: unknown): item is DataModelFieldAttribute;
export interface DataModelFieldType extends AstNode {
    readonly $container: DataModelField;
    readonly $type: 'DataModelFieldType';
    array: boolean;
    optional: boolean;
    reference?: Reference<TypeDeclaration>;
    type?: BuiltinType;
    unsupported?: UnsupportedFieldType;
}
export declare const DataModelFieldType = "DataModelFieldType";
export declare function isDataModelFieldType(item: unknown): item is DataModelFieldType;
export interface DataSource extends AstNode {
    readonly $container: Model;
    readonly $type: 'DataSource';
    fields: Array<ConfigField>;
    name: RegularID;
}
export declare const DataSource = "DataSource";
export declare function isDataSource(item: unknown): item is DataSource;
export interface Enum extends AstNode {
    readonly $container: Model;
    readonly $type: 'Enum';
    attributes: Array<DataModelAttribute>;
    comments: Array<string>;
    fields: Array<EnumField>;
    name: RegularID;
}
export declare const Enum = "Enum";
export declare function isEnum(item: unknown): item is Enum;
export interface EnumField extends AstNode {
    readonly $container: DataModel | Enum | FunctionDecl;
    readonly $type: 'EnumField';
    attributes: Array<DataModelFieldAttribute>;
    comments: Array<string>;
    name: RegularIDWithTypeNames;
}
export declare const EnumField = "EnumField";
export declare function isEnumField(item: unknown): item is EnumField;
export interface FieldInitializer extends AstNode {
    readonly $container: ObjectExpr;
    readonly $type: 'FieldInitializer';
    name: RegularID | string;
    value: Expression;
}
export declare const FieldInitializer = "FieldInitializer";
export declare function isFieldInitializer(item: unknown): item is FieldInitializer;
export interface FunctionDecl extends AstNode {
    readonly $container: Model;
    readonly $type: 'FunctionDecl';
    attributes: Array<InternalAttribute>;
    expression?: Expression;
    name: RegularID;
    params: Array<FunctionParam>;
    returnType: FunctionParamType;
}
export declare const FunctionDecl = "FunctionDecl";
export declare function isFunctionDecl(item: unknown): item is FunctionDecl;
export interface FunctionParam extends AstNode {
    readonly $container: DataModel | Enum | FunctionDecl;
    readonly $type: 'FunctionParam';
    name: RegularID;
    optional: boolean;
    type: FunctionParamType;
}
export declare const FunctionParam = "FunctionParam";
export declare function isFunctionParam(item: unknown): item is FunctionParam;
export interface FunctionParamType extends AstNode {
    readonly $container: FunctionDecl | FunctionParam;
    readonly $type: 'FunctionParamType';
    array: boolean;
    reference?: Reference<TypeDeclaration>;
    type?: ExpressionType;
}
export declare const FunctionParamType = "FunctionParamType";
export declare function isFunctionParamType(item: unknown): item is FunctionParamType;
export interface GeneratorDecl extends AstNode {
    readonly $container: Model;
    readonly $type: 'GeneratorDecl';
    fields: Array<ConfigField>;
    name: RegularID;
}
export declare const GeneratorDecl = "GeneratorDecl";
export declare function isGeneratorDecl(item: unknown): item is GeneratorDecl;
export interface InternalAttribute extends AstNode {
    readonly $container: Attribute | AttributeParam | FunctionDecl;
    readonly $type: 'InternalAttribute';
    args: Array<AttributeArg>;
    decl: Reference<Attribute>;
}
export declare const InternalAttribute = "InternalAttribute";
export declare function isInternalAttribute(item: unknown): item is InternalAttribute;
export interface InvocationExpr extends AstNode {
    readonly $container: Argument | ArrayExpr | AttributeArg | BinaryExpr | ConfigArrayExpr | ConfigField | ConfigInvocationArg | FieldInitializer | FunctionDecl | MemberAccessExpr | PluginField | ReferenceArg | UnaryExpr | UnsupportedFieldType;
    readonly $type: 'InvocationExpr';
    args: Array<Argument>;
    function: Reference<FunctionDecl>;
}
export declare const InvocationExpr = "InvocationExpr";
export declare function isInvocationExpr(item: unknown): item is InvocationExpr;
export interface MemberAccessExpr extends AstNode {
    readonly $container: Argument | ArrayExpr | AttributeArg | BinaryExpr | ConfigArrayExpr | ConfigField | ConfigInvocationArg | FieldInitializer | FunctionDecl | MemberAccessExpr | PluginField | ReferenceArg | UnaryExpr | UnsupportedFieldType;
    readonly $type: 'MemberAccessExpr';
    member: Reference<DataModelField>;
    operand: Expression;
}
export declare const MemberAccessExpr = "MemberAccessExpr";
export declare function isMemberAccessExpr(item: unknown): item is MemberAccessExpr;
export interface Model extends AstNode {
    readonly $type: 'Model';
    declarations: Array<AbstractDeclaration>;
    imports: Array<ModelImport>;
}
export declare const Model = "Model";
export declare function isModel(item: unknown): item is Model;
export interface ModelImport extends AstNode {
    readonly $container: Model;
    readonly $type: 'ModelImport';
    path: string;
}
export declare const ModelImport = "ModelImport";
export declare function isModelImport(item: unknown): item is ModelImport;
export interface NullExpr extends AstNode {
    readonly $container: Argument | ArrayExpr | AttributeArg | BinaryExpr | ConfigArrayExpr | ConfigField | ConfigInvocationArg | FieldInitializer | FunctionDecl | MemberAccessExpr | PluginField | ReferenceArg | UnaryExpr | UnsupportedFieldType;
    readonly $type: 'NullExpr';
    value: 'null';
}
export declare const NullExpr = "NullExpr";
export declare function isNullExpr(item: unknown): item is NullExpr;
export interface NumberLiteral extends AstNode {
    readonly $container: Argument | ArrayExpr | AttributeArg | BinaryExpr | ConfigArrayExpr | ConfigField | ConfigInvocationArg | FieldInitializer | FunctionDecl | MemberAccessExpr | PluginField | ReferenceArg | UnaryExpr | UnsupportedFieldType;
    readonly $type: 'NumberLiteral';
    value: string;
}
export declare const NumberLiteral = "NumberLiteral";
export declare function isNumberLiteral(item: unknown): item is NumberLiteral;
export interface ObjectExpr extends AstNode {
    readonly $container: Argument | ArrayExpr | AttributeArg | BinaryExpr | ConfigArrayExpr | ConfigField | ConfigInvocationArg | FieldInitializer | FunctionDecl | MemberAccessExpr | PluginField | ReferenceArg | UnaryExpr | UnsupportedFieldType;
    readonly $type: 'ObjectExpr';
    fields: Array<FieldInitializer>;
}
export declare const ObjectExpr = "ObjectExpr";
export declare function isObjectExpr(item: unknown): item is ObjectExpr;
export interface Plugin extends AstNode {
    readonly $container: Model;
    readonly $type: 'Plugin';
    fields: Array<PluginField>;
    name: RegularID;
}
export declare const Plugin = "Plugin";
export declare function isPlugin(item: unknown): item is Plugin;
export interface PluginField extends AstNode {
    readonly $container: Plugin;
    readonly $type: 'PluginField';
    name: RegularID;
    value: ArrayExpr | LiteralExpr | ObjectExpr;
}
export declare const PluginField = "PluginField";
export declare function isPluginField(item: unknown): item is PluginField;
export interface ReferenceArg extends AstNode {
    readonly $container: ReferenceExpr;
    readonly $type: 'ReferenceArg';
    name: string;
    value: Expression;
}
export declare const ReferenceArg = "ReferenceArg";
export declare function isReferenceArg(item: unknown): item is ReferenceArg;
export interface ReferenceExpr extends AstNode {
    readonly $container: Argument | ArrayExpr | AttributeArg | BinaryExpr | ConfigArrayExpr | ConfigField | ConfigInvocationArg | FieldInitializer | FunctionDecl | MemberAccessExpr | PluginField | ReferenceArg | UnaryExpr | UnsupportedFieldType;
    readonly $type: 'ReferenceExpr';
    args: Array<ReferenceArg>;
    target: Reference<ReferenceTarget>;
}
export declare const ReferenceExpr = "ReferenceExpr";
export declare function isReferenceExpr(item: unknown): item is ReferenceExpr;
export interface StringLiteral extends AstNode {
    readonly $container: Argument | ArrayExpr | AttributeArg | BinaryExpr | ConfigArrayExpr | ConfigField | ConfigInvocationArg | FieldInitializer | FunctionDecl | MemberAccessExpr | PluginField | ReferenceArg | UnaryExpr | UnsupportedFieldType;
    readonly $type: 'StringLiteral';
    value: string;
}
export declare const StringLiteral = "StringLiteral";
export declare function isStringLiteral(item: unknown): item is StringLiteral;
export interface ThisExpr extends AstNode {
    readonly $container: Argument | ArrayExpr | AttributeArg | BinaryExpr | ConfigArrayExpr | ConfigField | ConfigInvocationArg | FieldInitializer | FunctionDecl | MemberAccessExpr | PluginField | ReferenceArg | UnaryExpr | UnsupportedFieldType;
    readonly $type: 'ThisExpr';
    value: 'this';
}
export declare const ThisExpr = "ThisExpr";
export declare function isThisExpr(item: unknown): item is ThisExpr;
export interface UnaryExpr extends AstNode {
    readonly $container: Argument | ArrayExpr | AttributeArg | BinaryExpr | ConfigArrayExpr | ConfigField | ConfigInvocationArg | FieldInitializer | FunctionDecl | MemberAccessExpr | PluginField | ReferenceArg | UnaryExpr | UnsupportedFieldType;
    readonly $type: 'UnaryExpr';
    operand: Expression;
    operator: '!';
}
export declare const UnaryExpr = "UnaryExpr";
export declare function isUnaryExpr(item: unknown): item is UnaryExpr;
export interface UnsupportedFieldType extends AstNode {
    readonly $container: DataModelFieldType;
    readonly $type: 'UnsupportedFieldType';
    value: LiteralExpr;
}
export declare const UnsupportedFieldType = "UnsupportedFieldType";
export declare function isUnsupportedFieldType(item: unknown): item is UnsupportedFieldType;
export type ZModelAstType = {
    AbstractDeclaration: AbstractDeclaration;
    Argument: Argument;
    ArrayExpr: ArrayExpr;
    Attribute: Attribute;
    AttributeArg: AttributeArg;
    AttributeParam: AttributeParam;
    AttributeParamType: AttributeParamType;
    BinaryExpr: BinaryExpr;
    BooleanLiteral: BooleanLiteral;
    ConfigArrayExpr: ConfigArrayExpr;
    ConfigExpr: ConfigExpr;
    ConfigField: ConfigField;
    ConfigInvocationArg: ConfigInvocationArg;
    ConfigInvocationExpr: ConfigInvocationExpr;
    DataModel: DataModel;
    DataModelAttribute: DataModelAttribute;
    DataModelField: DataModelField;
    DataModelFieldAttribute: DataModelFieldAttribute;
    DataModelFieldType: DataModelFieldType;
    DataSource: DataSource;
    Enum: Enum;
    EnumField: EnumField;
    Expression: Expression;
    FieldInitializer: FieldInitializer;
    FunctionDecl: FunctionDecl;
    FunctionParam: FunctionParam;
    FunctionParamType: FunctionParamType;
    GeneratorDecl: GeneratorDecl;
    InternalAttribute: InternalAttribute;
    InvocationExpr: InvocationExpr;
    LiteralExpr: LiteralExpr;
    MemberAccessExpr: MemberAccessExpr;
    Model: Model;
    ModelImport: ModelImport;
    NullExpr: NullExpr;
    NumberLiteral: NumberLiteral;
    ObjectExpr: ObjectExpr;
    Plugin: Plugin;
    PluginField: PluginField;
    ReferenceArg: ReferenceArg;
    ReferenceExpr: ReferenceExpr;
    ReferenceTarget: ReferenceTarget;
    StringLiteral: StringLiteral;
    ThisExpr: ThisExpr;
    TypeDeclaration: TypeDeclaration;
    UnaryExpr: UnaryExpr;
    UnsupportedFieldType: UnsupportedFieldType;
};
export declare class ZModelAstReflection extends AbstractAstReflection {
    getAllTypes(): string[];
    protected computeIsSubtype(subtype: string, supertype: string): boolean;
    getReferenceType(refInfo: ReferenceInfo): string;
    getTypeMetaData(type: string): TypeMetaData;
}
export declare const reflection: ZModelAstReflection;
