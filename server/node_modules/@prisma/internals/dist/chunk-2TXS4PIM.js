"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var chunk_2TXS4PIM_exports = {};
__export(chunk_2TXS4PIM_exports, {
  checkTypeScriptVersion: () => checkTypeScriptVersion,
  checkUnsupportedDataProxy: () => checkUnsupportedDataProxy,
  checkYarnVersion: () => checkYarnVersion,
  debug: () => debug4,
  forbiddenCmdWithDataProxyFlagMessage: () => forbiddenCmdWithDataProxyFlagMessage,
  formatSchema: () => formatSchema,
  generatorResolvers: () => generatorResolvers,
  getBinaryTargetForCurrentPlatform: () => import_get_platform2.getBinaryTargetForCurrentPlatform,
  getCLIPathHash: () => getCLIPathHash,
  getEnvPaths: () => getEnvPaths,
  getGenerator: () => getGenerator,
  getGenerators: () => getGenerators,
  getNodeAPIName: () => import_get_platform2.getNodeAPIName,
  getPrismaConfigFromPackageJson: () => getPrismaConfigFromPackageJson,
  getProjectHash: () => getProjectHash,
  getRelativeSchemaPath: () => getRelativeSchemaPath,
  getSchema: () => getSchema,
  getSchemaDir: () => getSchemaDir,
  getSchemaPath: () => getSchemaPath,
  getSchemaPathFromPackageJsonSync: () => getSchemaPathFromPackageJsonSync,
  getSchemaPathInternal: () => getSchemaPathInternal,
  getSchemaPathSync: () => getSchemaPathSync,
  getSchemaPathSyncInternal: () => getSchemaPathSyncInternal,
  knownBinaryTargets: () => knownBinaryTargets,
  loadEnvFile: () => loadEnvFile,
  prismaClientResolver: () => prismaClientResolver,
  readSchemaFromSingleFile: () => readSchemaFromSingleFile,
  skipIndex: () => skipIndex
});
module.exports = __toCommonJS(chunk_2TXS4PIM_exports);
var import_chunk_NTUFHXJS = require("./chunk-NTUFHXJS.js");
var import_chunk_EUTJYQDW = require("./chunk-EUTJYQDW.js");
var import_chunk_IPKE37QC = require("./chunk-IPKE37QC.js");
var import_chunk_4BFTRXOK = require("./chunk-4BFTRXOK.js");
var import_chunk_QPJNGMJF = require("./chunk-QPJNGMJF.js");
var import_chunk_A46NX7MG = require("./chunk-A46NX7MG.js");
var import_chunk_X77CS5RK = require("./chunk-X77CS5RK.js");
var import_chunk_6AHD2V6O = require("./chunk-6AHD2V6O.js");
var import_chunk_RS2R7COT = require("./chunk-RS2R7COT.js");
var import_chunk_X3P4J7WW = require("./chunk-X3P4J7WW.js");
var import_chunk_TCKF2JY6 = require("./chunk-TCKF2JY6.js");
var import_chunk_3N2PUJQZ = require("./chunk-3N2PUJQZ.js");
var import_chunk_5V36RLCO = require("./chunk-5V36RLCO.js");
var import_chunk_5FJ3MENK = require("./chunk-5FJ3MENK.js");
var import_chunk_36RDCUXI = require("./chunk-36RDCUXI.js");
var import_chunk_MUGH66MS = require("./chunk-MUGH66MS.js");
var import_chunk_J77ZIDXB = require("./chunk-J77ZIDXB.js");
var import_chunk_LNSJVWED = require("./chunk-LNSJVWED.js");
var import_chunk_TSJICM5S = require("./chunk-TSJICM5S.js");
var import_chunk_ZKZBTR2H = require("./chunk-ZKZBTR2H.js");
var import_chunk_NKTOLEDC = require("./chunk-NKTOLEDC.js");
var import_chunk_S3K6KTRH = require("./chunk-S3K6KTRH.js");
var import_chunk_45G7GPQ2 = require("./chunk-45G7GPQ2.js");
var import_chunk_URGOXRQA = require("./chunk-URGOXRQA.js");
var import_chunk_7SZOUC3T = require("./chunk-7SZOUC3T.js");
var import_chunk_6JCLYLDY = require("./chunk-6JCLYLDY.js");
var import_chunk_2B26F5N3 = require("./chunk-2B26F5N3.js");
var import_chunk_YFBJNO6Q = require("./chunk-YFBJNO6Q.js");
var import_chunk_M3GBKLGE = require("./chunk-M3GBKLGE.js");
var import_chunk_A4QWQE3W = require("./chunk-A4QWQE3W.js");
var import_chunk_635TMBAP = require("./chunk-635TMBAP.js");
var import_chunk_IOIAK7V7 = require("./chunk-IOIAK7V7.js");
var import_chunk_JYTJ6Y5B = require("./chunk-JYTJ6Y5B.js");
var import_chunk_H2HHKMCC = require("./chunk-H2HHKMCC.js");
var import_chunk_TOTPZIKH = require("./chunk-TOTPZIKH.js");
var import_chunk_PG5FDKSF = require("./chunk-PG5FDKSF.js");
var import_chunk_CTBG5EFY = require("./chunk-CTBG5EFY.js");
var import_debug = __toESM2(require("@prisma/debug"));
var import_fs = __toESM2(require("fs"));
var import_debug2 = __toESM2(require("@prisma/debug"));
var import_fs2 = __toESM2(require("fs"));
var import_path = __toESM2(require("path"));
var import_debug3 = require("@prisma/debug");
var import_schema_files_loader = require("@prisma/schema-files-loader");
var import_fs3 = __toESM2(require("fs"));
var import_path2 = __toESM2(require("path"));
var import_util = require("util");
var import_crypto = __toESM2(require("crypto"));
var import_debug4 = __toESM2(require("@prisma/debug"));
var import_engines = require("@prisma/engines");
var import_fetch_engine = require("@prisma/fetch-engine");
var import_get_platform = require("@prisma/get-platform");
var import_path3 = __toESM2(require("path"));
var import_debug5 = __toESM2(require("@prisma/debug"));
var import_fs4 = __toESM2(require("fs"));
var import_path4 = __toESM2(require("path"));
var import_debug6 = __toESM2(require("@prisma/debug"));
var import_fs5 = __toESM2(require("fs"));
var import_path5 = __toESM2(require("path"));
var import_get_platform2 = require("@prisma/get-platform");
var require_yocto_queue = (0, import_chunk_CTBG5EFY.__commonJS)({
  "../../node_modules/.pnpm/yocto-queue@0.1.0/node_modules/yocto-queue/index.js"(exports, module2) {
    "use strict";
    var Node = class {
      /// value;
      /// next;
      constructor(value) {
        this.value = value;
        this.next = void 0;
      }
    };
    var Queue = class {
      // TODO: Use private class fields when targeting Node.js 12.
      // #_head;
      // #_tail;
      // #_size;
      constructor() {
        this.clear();
      }
      enqueue(value) {
        const node = new Node(value);
        if (this._head) {
          this._tail.next = node;
          this._tail = node;
        } else {
          this._head = node;
          this._tail = node;
        }
        this._size++;
      }
      dequeue() {
        const current = this._head;
        if (!current) {
          return;
        }
        this._head = this._head.next;
        this._size--;
        return current.value;
      }
      clear() {
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
      }
      get size() {
        return this._size;
      }
      *[Symbol.iterator]() {
        let current = this._head;
        while (current) {
          yield current.value;
          current = current.next;
        }
      }
    };
    module2.exports = Queue;
  }
});
var require_p_limit = (0, import_chunk_CTBG5EFY.__commonJS)({
  "../../node_modules/.pnpm/p-limit@3.1.0/node_modules/p-limit/index.js"(exports, module2) {
    "use strict";
    var Queue = require_yocto_queue();
    var pLimit = (concurrency) => {
      if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
        throw new TypeError("Expected `concurrency` to be a number from 1 and up");
      }
      const queue = new Queue();
      let activeCount = 0;
      const next = () => {
        activeCount--;
        if (queue.size > 0) {
          queue.dequeue()();
        }
      };
      const run = async (fn, resolve, ...args) => {
        activeCount++;
        const result = (async () => fn(...args))();
        resolve(result);
        try {
          await result;
        } catch {
        }
        next();
      };
      const enqueue = (fn, resolve, ...args) => {
        queue.enqueue(run.bind(null, fn, resolve, ...args));
        (async () => {
          await Promise.resolve();
          if (activeCount < concurrency && queue.size > 0) {
            queue.dequeue()();
          }
        })();
      };
      const generator = (fn, ...args) => new Promise((resolve) => {
        enqueue(fn, resolve, ...args);
      });
      Object.defineProperties(generator, {
        activeCount: {
          get: () => activeCount
        },
        pendingCount: {
          get: () => queue.size
        },
        clearQueue: {
          value: () => {
            queue.clear();
          }
        }
      });
      return generator;
    };
    module2.exports = pLimit;
  }
});
var require_p_locate = (0, import_chunk_CTBG5EFY.__commonJS)({
  "../../node_modules/.pnpm/p-locate@5.0.0/node_modules/p-locate/index.js"(exports, module2) {
    "use strict";
    var pLimit = require_p_limit();
    var EndError = class extends Error {
      constructor(value) {
        super();
        this.value = value;
      }
    };
    var testElement = async (element, tester) => tester(await element);
    var finder = async (element) => {
      const values = await Promise.all(element);
      if (values[1] === true) {
        throw new EndError(values[0]);
      }
      return false;
    };
    var pLocate = async (iterable, tester, options2) => {
      options2 = {
        concurrency: Infinity,
        preserveOrder: true,
        ...options2
      };
      const limit = pLimit(options2.concurrency);
      const items = [...iterable].map((element) => [element, limit(testElement, element, tester)]);
      const checkLimit = pLimit(options2.preserveOrder ? 1 : Infinity);
      try {
        await Promise.all(items.map((element) => checkLimit(finder, element)));
      } catch (error) {
        if (error instanceof EndError) {
          return error.value;
        }
        throw error;
      }
    };
    module2.exports = pLocate;
  }
});
var require_locate_path = (0, import_chunk_CTBG5EFY.__commonJS)({
  "../../node_modules/.pnpm/locate-path@6.0.0/node_modules/locate-path/index.js"(exports, module2) {
    "use strict";
    var path6 = (0, import_chunk_CTBG5EFY.__require)("path");
    var fs6 = (0, import_chunk_CTBG5EFY.__require)("fs");
    var { promisify: promisify2 } = (0, import_chunk_CTBG5EFY.__require)("util");
    var pLocate = require_p_locate();
    var fsStat = promisify2(fs6.stat);
    var fsLStat = promisify2(fs6.lstat);
    var typeMappings = {
      directory: "isDirectory",
      file: "isFile"
    };
    function checkType({ type }) {
      if (type in typeMappings) {
        return;
      }
      throw new Error(`Invalid type specified: ${type}`);
    }
    var matchType = (type, stat) => type === void 0 || stat[typeMappings[type]]();
    module2.exports = async (paths, options2) => {
      options2 = {
        cwd: process.cwd(),
        type: "file",
        allowSymlinks: true,
        ...options2
      };
      checkType(options2);
      const statFn = options2.allowSymlinks ? fsStat : fsLStat;
      return pLocate(paths, async (path_) => {
        try {
          const stat = await statFn(path6.resolve(options2.cwd, path_));
          return matchType(options2.type, stat);
        } catch {
          return false;
        }
      }, options2);
    };
    module2.exports.sync = (paths, options2) => {
      options2 = {
        cwd: process.cwd(),
        allowSymlinks: true,
        type: "file",
        ...options2
      };
      checkType(options2);
      const statFn = options2.allowSymlinks ? fs6.statSync : fs6.lstatSync;
      for (const path_ of paths) {
        try {
          const stat = statFn(path6.resolve(options2.cwd, path_));
          if (matchType(options2.type, stat)) {
            return path_;
          }
        } catch {
        }
      }
    };
  }
});
var require_path_exists = (0, import_chunk_CTBG5EFY.__commonJS)({
  "../../node_modules/.pnpm/path-exists@4.0.0/node_modules/path-exists/index.js"(exports, module2) {
    "use strict";
    var fs6 = (0, import_chunk_CTBG5EFY.__require)("fs");
    var { promisify: promisify2 } = (0, import_chunk_CTBG5EFY.__require)("util");
    var pAccess = promisify2(fs6.access);
    module2.exports = async (path6) => {
      try {
        await pAccess(path6);
        return true;
      } catch (_) {
        return false;
      }
    };
    module2.exports.sync = (path6) => {
      try {
        fs6.accessSync(path6);
        return true;
      } catch (_) {
        return false;
      }
    };
  }
});
var require_find_up = (0, import_chunk_CTBG5EFY.__commonJS)({
  "../../node_modules/.pnpm/find-up@5.0.0/node_modules/find-up/index.js"(exports, module2) {
    "use strict";
    var path6 = (0, import_chunk_CTBG5EFY.__require)("path");
    var locatePath = require_locate_path();
    var pathExists = require_path_exists();
    var stop = Symbol("findUp.stop");
    module2.exports = async (name, options2 = {}) => {
      let directory = path6.resolve(options2.cwd || "");
      const { root } = path6.parse(directory);
      const paths = [].concat(name);
      const runMatcher = async (locateOptions) => {
        if (typeof name !== "function") {
          return locatePath(paths, locateOptions);
        }
        const foundPath = await name(locateOptions.cwd);
        if (typeof foundPath === "string") {
          return locatePath([foundPath], locateOptions);
        }
        return foundPath;
      };
      while (true) {
        const foundPath = await runMatcher({ ...options2, cwd: directory });
        if (foundPath === stop) {
          return;
        }
        if (foundPath) {
          return path6.resolve(directory, foundPath);
        }
        if (directory === root) {
          return;
        }
        directory = path6.dirname(directory);
      }
    };
    module2.exports.sync = (name, options2 = {}) => {
      let directory = path6.resolve(options2.cwd || "");
      const { root } = path6.parse(directory);
      const paths = [].concat(name);
      const runMatcher = (locateOptions) => {
        if (typeof name !== "function") {
          return locatePath.sync(paths, locateOptions);
        }
        const foundPath = name(locateOptions.cwd);
        if (typeof foundPath === "string") {
          return locatePath.sync([foundPath], locateOptions);
        }
        return foundPath;
      };
      while (true) {
        const foundPath = runMatcher({ ...options2, cwd: directory });
        if (foundPath === stop) {
          return;
        }
        if (foundPath) {
          return path6.resolve(directory, foundPath);
        }
        if (directory === root) {
          return;
        }
        directory = path6.dirname(directory);
      }
    };
    module2.exports.exists = pathExists;
    module2.exports.sync.exists = pathExists.sync;
    module2.exports.stop = stop;
  }
});
var import_find_up = (0, import_chunk_CTBG5EFY.__toESM)(require_find_up());
var import_execa = (0, import_chunk_CTBG5EFY.__toESM)((0, import_chunk_YFBJNO6Q.require_execa)());
var exists2 = (0, import_util.promisify)(import_fs3.default.exists);
var readFile = (0, import_util.promisify)(import_fs3.default.readFile);
var debug = (0, import_debug3.Debug)("prisma:getSchema");
async function getSchemaPath(schemaPathFromArgs, opts = {
  cwd: process.cwd()
}) {
  return getSchemaPathInternal(schemaPathFromArgs, {
    cwd: opts.cwd
  });
}
async function readSchemaFromSingleFile(schemaPath2) {
  debug("Reading schema from single file", schemaPath2);
  const file = await readFile(schemaPath2, { encoding: "utf-8" });
  const schemaTuple = [schemaPath2, file];
  return { schemaPath: schemaPath2, schemas: [schemaTuple] };
}
async function readSchemaFromMultiFiles(schemaPath2) {
  debug("Reading schema from multiple files", schemaPath2);
  const files = await (0, import_schema_files_loader.loadSchemaFiles)(schemaPath2);
  debug("Loading config");
  const config2 = await (0, import_chunk_S3K6KTRH.getConfig)({
    datamodel: files,
    ignoreEnvVarErrors: true
  });
  debug("Ok");
  if ((0, import_schema_files_loader.usesPrismaSchemaFolder)(config2)) {
    return { schemaPath: schemaPath2, schemas: files };
  }
  return null;
}
async function getSchemaPathInternal(schemaPathFromArgs, opts = {
  cwd: process.cwd()
}) {
  async function getSchemaResult(schemaPath2) {
    return readSchemaFromSingleFile(schemaPath2).catch(() => readSchemaFromMultiFiles(schemaPath2)).catch(() => null);
  }
  if (schemaPathFromArgs) {
    const customSchemaPath = await getAbsoluteSchemaPath(import_path2.default.resolve(schemaPathFromArgs));
    const onError = () => {
      throw new Error(`Provided --schema at ${schemaPathFromArgs} doesn't exist.`);
    };
    if (!customSchemaPath) {
      return onError();
    }
    const customSchemaResult = await getSchemaResult(import_path2.default.resolve(opts.cwd ?? process.cwd(), customSchemaPath));
    if (!customSchemaResult) {
      return onError();
    }
    return customSchemaResult;
  }
  const trials = [
    // 2. Try the package.json `prisma.schema` custom path.
    { strategy: "package.json", fn: getSchemaPathFromPackageJson, sourcePath: opts.cwd },
    // 3. Try the conventional ./schema.prisma or ./prisma/schema.prisma paths.
    { strategy: "relative", fn: getRelativeSchemaPath, sourcePath: opts.cwd },
    // 4. Try resolving yarn workspaces and looking for a schema.prisma file there.
    { strategy: "yarn", fn: resolveYarnSchema, sourcePath: opts.cwd }
  ];
  for (const { strategy, sourcePath, fn } of trials) {
    debug(`Trying ${strategy}...`);
    const schemaPath2 = await fn(sourcePath);
    debug(`${strategy} resolved to ${schemaPath2}`);
    if (!schemaPath2) {
      continue;
    }
    const schemaPathResult = await getSchemaResult(import_path2.default.resolve(sourcePath, schemaPath2));
    if (schemaPathResult) {
      return schemaPathResult;
    }
  }
  return null;
}
async function getPrismaConfigFromPackageJson(cwd) {
  const pkgJson = await (0, import_chunk_JYTJ6Y5B.readPackageUp)({ cwd, normalize: false });
  const prismaPropertyFromPkgJson = pkgJson?.packageJson?.prisma;
  if (!pkgJson) {
    return null;
  }
  return {
    data: prismaPropertyFromPkgJson,
    packagePath: pkgJson.path
  };
}
async function getSchemaPathFromPackageJson(cwd) {
  const prismaConfig = await getPrismaConfigFromPackageJson(cwd);
  debug("prismaConfig", prismaConfig);
  if (!prismaConfig || !prismaConfig.data?.schema) {
    return null;
  }
  const schemaPathFromPkgJson = prismaConfig.data.schema;
  if (typeof schemaPathFromPkgJson !== "string") {
    throw new Error(
      `Provided schema path \`${schemaPathFromPkgJson}\` from \`${import_path2.default.relative(
        cwd,
        prismaConfig.packagePath
      )}\` must be of type string`
    );
  }
  const absoluteSchemaPath = import_path2.default.isAbsolute(schemaPathFromPkgJson) ? schemaPathFromPkgJson : import_path2.default.resolve(import_path2.default.dirname(prismaConfig.packagePath), schemaPathFromPkgJson);
  if (await exists2(absoluteSchemaPath) === false) {
    throw new Error(
      `Provided schema path \`${import_path2.default.relative(cwd, absoluteSchemaPath)}\` from \`${import_path2.default.relative(
        cwd,
        prismaConfig.packagePath
      )}\` doesn't exist.`
    );
  }
  return absoluteSchemaPath;
}
async function resolveYarnSchema(cwd) {
  if (process.env.npm_config_user_agent?.includes("yarn")) {
    try {
      const { stdout: version3 } = await import_execa.default.command("yarn --version", {
        cwd
      });
      if (version3.startsWith("2")) {
        return null;
      }
      const { stdout } = await import_execa.default.command("yarn workspaces info --json", {
        cwd
      });
      const json = getJson(stdout);
      const workspaces = Object.values(json);
      const workspaceRootDir = await findWorkspaceRoot(cwd);
      if (!workspaceRootDir) {
        return null;
      }
      for (const workspace of workspaces) {
        const workspacePath = import_path2.default.join(workspaceRootDir, workspace.location);
        const workspaceSchemaPath = getSchemaPathFromPackageJsonSync(workspacePath) ?? getRelativeSchemaPathSync(workspacePath);
        if (workspaceSchemaPath) {
          return workspaceSchemaPath;
        }
      }
      const workspaceSchemaPathFromRoot = getSchemaPathFromPackageJsonSync(workspaceRootDir) ?? getRelativeSchemaPathSync(workspaceRootDir);
      if (workspaceSchemaPathFromRoot) {
        return workspaceSchemaPathFromRoot;
      }
    } catch (e) {
      return null;
    }
  }
  return null;
}
function resolveYarnSchemaSync(cwd) {
  if (process.env.npm_config_user_agent?.includes("yarn")) {
    try {
      const { stdout: version3 } = import_execa.default.commandSync("yarn --version", {
        cwd
      });
      if (version3.startsWith("2")) {
        return null;
      }
      const { stdout } = import_execa.default.commandSync("yarn workspaces info --json", {
        cwd
      });
      const json = getJson(stdout);
      const workspaces = Object.values(json);
      const workspaceRootDir = findWorkspaceRootSync(cwd);
      if (!workspaceRootDir) {
        return null;
      }
      for (const workspace of workspaces) {
        const workspacePath = import_path2.default.join(workspaceRootDir, workspace.location);
        const workspaceSchemaPath = getSchemaPathFromPackageJsonSync(workspacePath) ?? getRelativeSchemaPathSync(workspacePath);
        if (workspaceSchemaPath) {
          return workspaceSchemaPath;
        }
      }
      const workspaceSchemaPathFromRoot = getSchemaPathFromPackageJsonSync(workspaceRootDir) ?? getRelativeSchemaPathSync(workspaceRootDir);
      if (workspaceSchemaPathFromRoot) {
        return workspaceSchemaPathFromRoot;
      }
    } catch (e) {
      return null;
    }
  }
  return null;
}
async function getAbsoluteSchemaPath(schemaPath2) {
  if (await exists2(schemaPath2)) {
    return schemaPath2;
  }
  return null;
}
async function getRelativeSchemaPath(cwd) {
  const relativeSchemaPaths = [
    "schema.prisma",
    import_path2.default.join("prisma", "schema.prisma"),
    import_path2.default.join("prisma", "schema")
  ];
  for (const relativeSchemaPath of relativeSchemaPaths) {
    const relativePath = import_path2.default.join(cwd, relativeSchemaPath);
    debug(`Checking existence of ${relativePath}`);
    if (await exists2(relativePath)) {
      debug("Found schema at", relativeSchemaPath);
      return relativeSchemaPath;
    }
  }
  return null;
}
async function getSchemaDir(schemaPathFromArgs) {
  if (schemaPathFromArgs) {
    return import_path2.default.resolve(import_path2.default.dirname(schemaPathFromArgs));
  }
  const schemaPathResult = await getSchemaPath();
  if (!schemaPathResult) {
    return null;
  }
  return import_path2.default.dirname(schemaPathResult.schemaPath);
}
async function getSchema(schemaPathFromArgs) {
  const schemaPathResult = await getSchemaPath(schemaPathFromArgs);
  if (!schemaPathResult) {
    throw new Error(
      `Could not find a ${(0, import_chunk_PG5FDKSF.bold)(
        "schema.prisma"
      )} file that is required for this command.
You can either provide it with ${(0, import_chunk_PG5FDKSF.green)(
        "--schema"
      )}, set it as \`prisma.schema\` in your package.json or put it into the default location ${(0, import_chunk_PG5FDKSF.green)(
        "./prisma/schema.prisma"
      )} https://pris.ly/d/prisma-schema-location`
    );
  }
  return schemaPathResult.schemas;
}
function getSchemaPathSync(schemaPathFromArgs) {
  return getSchemaPathSyncInternal(schemaPathFromArgs, {
    cwd: process.cwd()
  });
}
function getSchemaPathSyncInternal(schemaPathFromArgs, opts = {
  cwd: process.cwd()
}) {
  if (schemaPathFromArgs) {
    const customSchemaPath = getAbsoluteSchemaPathSync(import_path2.default.resolve(schemaPathFromArgs));
    if (!customSchemaPath) {
      throw new Error(`Provided --schema at ${schemaPathFromArgs} doesn't exist.`);
    }
    return customSchemaPath;
  }
  const schemaPath2 = getSchemaPathFromPackageJsonSync(opts.cwd) ?? getRelativeSchemaPathSync(opts.cwd) ?? resolveYarnSchemaSync(opts.cwd);
  if (schemaPath2) {
    return schemaPath2;
  }
  return null;
}
function getSchemaPathFromPackageJsonSync(cwd) {
  const pkgJson = (0, import_chunk_JYTJ6Y5B.readPackageUpSync)({ cwd, normalize: false });
  const schemaPathFromPkgJson = pkgJson?.packageJson?.prisma?.["schema"];
  if (!schemaPathFromPkgJson || !pkgJson) {
    return null;
  }
  if (typeof schemaPathFromPkgJson !== "string") {
    throw new Error(
      `Provided schema path \`${schemaPathFromPkgJson}\` from \`${import_path2.default.relative(
        cwd,
        pkgJson.path
      )}\` must be of type string`
    );
  }
  const absoluteSchemaPath = import_path2.default.isAbsolute(schemaPathFromPkgJson) ? schemaPathFromPkgJson : import_path2.default.resolve(import_path2.default.dirname(pkgJson.path), schemaPathFromPkgJson);
  if (import_fs3.default.existsSync(absoluteSchemaPath) === false) {
    throw new Error(
      `Provided schema path \`${import_path2.default.relative(cwd, absoluteSchemaPath)}\` from \`${import_path2.default.relative(
        cwd,
        pkgJson.path
      )}\` doesn't exist.`
    );
  }
  return absoluteSchemaPath;
}
function getAbsoluteSchemaPathSync(schemaPath2) {
  if (import_fs3.default.existsSync(schemaPath2)) {
    return schemaPath2;
  }
  return null;
}
function getRelativeSchemaPathSync(cwd) {
  let schemaPath2 = import_path2.default.join(cwd, "schema.prisma");
  if (import_fs3.default.existsSync(schemaPath2)) {
    return schemaPath2;
  }
  schemaPath2 = import_path2.default.join(cwd, `prisma/schema.prisma`);
  if (import_fs3.default.existsSync(schemaPath2)) {
    return schemaPath2;
  }
  return null;
}
function getJson(stdout) {
  const firstCurly = stdout.indexOf("{");
  const lastCurly = stdout.lastIndexOf("}");
  const sliced = stdout.slice(firstCurly, lastCurly + 1);
  return JSON.parse(sliced);
}
function isPkgJsonWorkspaceRoot(pkgJson) {
  const workspaces = pkgJson.workspaces;
  if (!workspaces) {
    return false;
  }
  return Array.isArray(workspaces) || workspaces.packages !== void 0;
}
async function isNearestPkgJsonWorkspaceRoot(cwd) {
  const pkgJson = await (0, import_chunk_JYTJ6Y5B.readPackageUp)({ cwd, normalize: false });
  if (!pkgJson) {
    return null;
  }
  return {
    isRoot: isPkgJsonWorkspaceRoot(pkgJson.packageJson),
    path: pkgJson.path
  };
}
function isNearestPkgJsonWorkspaceRootSync(cwd) {
  const pkgJson = (0, import_chunk_JYTJ6Y5B.readPackageUpSync)({ cwd, normalize: false });
  if (!pkgJson) {
    return null;
  }
  return {
    isRoot: isPkgJsonWorkspaceRoot(pkgJson.packageJson),
    path: pkgJson.path
  };
}
async function findWorkspaceRoot(cwd) {
  let pkgJson = await isNearestPkgJsonWorkspaceRoot(cwd);
  if (!pkgJson) {
    return null;
  }
  if (pkgJson.isRoot === true) {
    return import_path2.default.dirname(pkgJson.path);
  }
  const pkgJsonParentDir = import_path2.default.dirname(import_path2.default.dirname(pkgJson.path));
  pkgJson = await isNearestPkgJsonWorkspaceRoot(pkgJsonParentDir);
  if (!pkgJson || pkgJson.isRoot === false) {
    return null;
  }
  return import_path2.default.dirname(pkgJson.path);
}
function findWorkspaceRootSync(cwd) {
  let pkgJson = isNearestPkgJsonWorkspaceRootSync(cwd);
  if (!pkgJson) {
    return null;
  }
  if (pkgJson.isRoot === true) {
    return import_path2.default.dirname(pkgJson.path);
  }
  const pkgJsonParentDir = import_path2.default.dirname(import_path2.default.dirname(pkgJson.path));
  pkgJson = isNearestPkgJsonWorkspaceRootSync(pkgJsonParentDir);
  if (!pkgJson || pkgJson.isRoot === false) {
    return null;
  }
  return import_path2.default.dirname(pkgJson.path);
}
var debug2 = (0, import_debug2.default)("prisma:loadEnv");
function getEnvPaths(schemaPath2, opts = { cwd: process.cwd() }) {
  const rootEnvPath = getProjectRootEnvPath({ cwd: opts.cwd }) ?? null;
  const schemaEnvPathFromArgs = schemaPathToEnvPath(schemaPath2);
  const schemaEnvPathFromPkgJson = schemaPathToEnvPath(readSchemaPathFromPkgJson());
  const schemaEnvPaths = [
    schemaEnvPathFromArgs,
    // 1 - Check --schema directory for .env
    schemaEnvPathFromPkgJson,
    // 2 - Check package.json schema directory for .env
    "./prisma/.env",
    // 3 - Check ./prisma directory for .env
    "./.env"
    // 4 - Check cwd for .env
  ];
  const schemaEnvPath = schemaEnvPaths.find(import_chunk_3N2PUJQZ.exists);
  return { rootEnvPath, schemaEnvPath };
}
function readSchemaPathFromPkgJson() {
  try {
    return getSchemaPathFromPackageJsonSync(process.cwd());
  } catch {
    return null;
  }
}
function getProjectRootEnvPath(opts) {
  const pkgJsonPath = import_find_up.default.sync((dir) => {
    const pkgPath = import_path.default.join(dir, "package.json");
    if (import_find_up.default.sync.exists(pkgPath)) {
      try {
        const pkg = JSON.parse(import_fs2.default.readFileSync(pkgPath, "utf8"));
        if (pkg["name"] !== ".prisma/client") {
          debug2(`project root found at ${pkgPath}`);
          return pkgPath;
        }
      } catch (e) {
        debug2(`skipping package.json at ${pkgPath}`);
      }
    }
    return void 0;
  }, opts);
  if (!pkgJsonPath) {
    return null;
  }
  const candidate = import_path.default.join(import_path.default.dirname(pkgJsonPath), ".env");
  if (!import_fs2.default.existsSync(candidate)) {
    return null;
  }
  return candidate;
}
function schemaPathToEnvPath(schemaPath2) {
  if (!schemaPath2) return null;
  return import_path.default.join(import_path.default.dirname(schemaPath2), ".env");
}
function loadEnvFile({
  schemaPath: schemaPath2,
  printMessage = false
} = {}) {
  const envPaths = getEnvPaths(schemaPath2);
  const envData = (0, import_chunk_3N2PUJQZ.tryLoadEnvs)(envPaths, { conflictCheck: "error" });
  if (printMessage && envData && envData.message) {
    process.stdout.write(envData.message + "\n");
  }
}
var forbiddenCmdWithDataProxyFlagMessage = (command) => `
Using an Accelerate URL is not supported for this CLI command ${(0, import_chunk_PG5FDKSF.green)(`prisma ${command}`)} yet.
Please use a direct connection to your database via the datasource \`directUrl\` setting.

More information about this limitation: ${(0, import_chunk_LNSJVWED.link)("https://pris.ly/d/accelerate-limitations")}
`;
async function checkUnsupportedDataProxyMessage(command, args, implicitSchema) {
  if (implicitSchema === true) {
    args["--schema"] = (await getSchemaPath(args["--schema"]))?.schemaPath ?? void 0;
  }
  const argList = Object.entries(args);
  for (const [argName, argValue] of argList) {
    if (argName.includes("url") && argValue.includes("prisma://")) {
      return forbiddenCmdWithDataProxyFlagMessage(command);
    }
    if (argName.includes("schema")) {
      loadEnvFile({ schemaPath: argValue, printMessage: false });
      const datamodel = await import_fs.default.promises.readFile(argValue, "utf-8");
      const config2 = await (0, import_chunk_S3K6KTRH.getConfig)({ datamodel, ignoreEnvVarErrors: true });
      const url = (0, import_chunk_S3K6KTRH.resolveUrl)((0, import_chunk_S3K6KTRH.getEffectiveUrl)(config2.datasources[0]));
      if (url?.startsWith("prisma://")) {
        return forbiddenCmdWithDataProxyFlagMessage(command);
      }
    }
  }
  return void 0;
}
async function checkUnsupportedDataProxy(command, args, implicitSchema) {
  const message = await checkUnsupportedDataProxyMessage(command, args, implicitSchema).catch(() => void 0);
  if (message) throw new Error(message);
}
async function getProjectHash() {
  const args = (0, import_chunk_6JCLYLDY.arg)(process.argv.slice(3), { "--schema": String });
  const projectPath = (await getSchemaPath(args["--schema"]))?.schemaPath ?? process.cwd();
  return import_crypto.default.createHash("sha256").update(projectPath).digest("hex").substring(0, 8);
}
function getCLIPathHash() {
  const cliPath = process.argv[1];
  return import_crypto.default.createHash("sha256").update(cliPath).digest("hex").substring(0, 8);
}
var import_p_map = (0, import_chunk_CTBG5EFY.__toESM)((0, import_chunk_JYTJ6Y5B.require_p_map)());
var debug3 = (0, import_debug6.default)("prisma:generator");
async function checkTypeScriptVersion() {
  const minVersion = "4.1.0";
  try {
    const typescriptPath = await (0, import_chunk_H2HHKMCC.resolvePkg)("typescript", {
      basedir: process.cwd()
    });
    debug3("typescriptPath", typescriptPath);
    const typescriptPkg = typescriptPath && import_path5.default.join(typescriptPath, "package.json");
    if (typescriptPkg && import_fs5.default.existsSync(typescriptPkg)) {
      const pjson = (0, import_chunk_CTBG5EFY.__require)(typescriptPkg);
      const currentVersion = pjson.version;
      if ((0, import_chunk_EUTJYQDW.semverLt)(currentVersion, minVersion)) {
        import_chunk_TOTPZIKH.logger_exports.warn(
          `Prisma detected that your ${(0, import_chunk_PG5FDKSF.bold)(
            "TypeScript"
          )} version ${currentVersion} is outdated. If you want to use Prisma Client with TypeScript please update it to version ${(0, import_chunk_PG5FDKSF.bold)(
            minVersion
          )} or ${(0, import_chunk_PG5FDKSF.bold)("newer")}. ${(0, import_chunk_PG5FDKSF.dim)(`TypeScript found in: ${(0, import_chunk_PG5FDKSF.bold)(typescriptPath)}`)}`
        );
      }
    }
  } catch (e) {
  }
}
function checkYarnVersion() {
  if (process.env.npm_config_user_agent) {
    const match = parseUserAgentString(process.env.npm_config_user_agent);
    if (match) {
      const { agent, major, minor, patch } = match;
      if (agent === "yarn" && major === 1) {
        const currentYarnVersion = `${major}.${minor}.${patch}`;
        const minYarnVersion = "1.19.2";
        if ((0, import_chunk_EUTJYQDW.semverLt)(currentYarnVersion, minYarnVersion)) {
          import_chunk_TOTPZIKH.logger_exports.warn(
            `Your ${(0, import_chunk_PG5FDKSF.bold)("yarn")} has version ${currentYarnVersion}, which is outdated. Please update it to ${(0, import_chunk_PG5FDKSF.bold)(
              minYarnVersion
            )} or ${(0, import_chunk_PG5FDKSF.bold)("newer")} in order to use Prisma.`
          );
        }
      }
    }
  }
}
function parseUserAgentString(str) {
  const userAgentRegex = /(\w+)\/(\d+)\.(\d+)\.(\d+)/;
  const match = userAgentRegex.exec(str);
  if (match) {
    const agent = match[1];
    const major = parseInt(match[2]);
    const minor = parseInt(match[3]);
    const patch = parseInt(match[4]);
    return { agent, major, minor, patch };
  }
  return null;
}
var debug4 = (0, import_debug5.default)("prisma:generator");
async function prismaClientResolver(baseDir2, version3) {
  let prismaClientDir = await (0, import_chunk_4BFTRXOK.findPrismaClientDir)(baseDir2);
  debug4("baseDir", baseDir2);
  checkYarnVersion();
  await checkTypeScriptVersion();
  if (!prismaClientDir && !process.env.PRISMA_GENERATE_SKIP_AUTOINSTALL) {
    let projectRoot = (0, import_chunk_J77ZIDXB.longestCommonPathPrefix)(baseDir2, process.cwd());
    debug4("projectRoot", projectRoot);
    const warningTag = `${(0, import_chunk_PG5FDKSF.bold)("Warning:")} ${(0, import_chunk_PG5FDKSF.dim)("[Prisma auto-install on generate]")}`;
    if (projectRoot === void 0) {
      console.warn(
        (0, import_chunk_PG5FDKSF.yellow)(
          `${warningTag} The Prisma schema directory ${(0, import_chunk_PG5FDKSF.bold)(baseDir2)} and the current working directory ${(0, import_chunk_PG5FDKSF.bold)(
            process.cwd()
          )} have no common ancestor. The Prisma schema directory will be used as the project root.`
        )
      );
      projectRoot = baseDir2;
    }
    if (!import_fs4.default.existsSync(import_path4.default.join(projectRoot, "package.json"))) {
      console.warn(
        (0, import_chunk_PG5FDKSF.yellow)(
          `${warningTag} Prisma could not find a ${(0, import_chunk_PG5FDKSF.bold)("package.json")} file in the inferred project root ${(0, import_chunk_PG5FDKSF.bold)(
            projectRoot
          )}. During the next step, when an auto-install of Prisma package(s) will be attempted, it will then be created by your package manager on the appropriate level if necessary.`
        )
      );
    }
    const prismaCliDir = await (0, import_chunk_H2HHKMCC.resolvePkg)("prisma", { basedir: baseDir2 });
    if (process.platform === "win32" && await (0, import_chunk_NTUFHXJS.isYarnUsed)(baseDir2)) {
      const hasCli = (s) => prismaCliDir !== void 0 ? s : "";
      const missingCli = (s) => prismaCliDir === void 0 ? s : "";
      throw new Error(
        `Could not resolve ${missingCli(`${(0, import_chunk_PG5FDKSF.bold)("prisma")} and `)}${(0, import_chunk_PG5FDKSF.bold)(
          "@prisma/client"
        )} in the current project. Please install ${hasCli("it")}${missingCli("them")} with ${missingCli(
          `${(0, import_chunk_PG5FDKSF.bold)((0, import_chunk_PG5FDKSF.green)(`${await (0, import_chunk_A46NX7MG.getPackageCmd)(baseDir2, "add", "prisma", "-D")}`))} and `
        )}${(0, import_chunk_PG5FDKSF.bold)((0, import_chunk_PG5FDKSF.green)(`${await (0, import_chunk_A46NX7MG.getPackageCmd)(baseDir2, "add", "@prisma/client")}`))}, and rerun ${(0, import_chunk_PG5FDKSF.bold)(
          await (0, import_chunk_A46NX7MG.getPackageCmd)(baseDir2, "execute", "prisma generate")
        )} \u{1F64F}.`
      );
    }
    if (!prismaCliDir) {
      await (0, import_chunk_QPJNGMJF.runPackageCmd)(projectRoot, "add", `prisma@${version3 ?? "latest"}`, "-D");
    }
    await (0, import_chunk_QPJNGMJF.runPackageCmd)(projectRoot, "add", `@prisma/client@${version3 ?? "latest"}`);
    prismaClientDir = await (0, import_chunk_4BFTRXOK.findPrismaClientDir)(import_path4.default.join(".", baseDir2));
    if (!prismaClientDir) {
      throw new Error(
        `Could not resolve @prisma/client despite the installation that we just tried.
Please try to install it by hand with ${(0, import_chunk_PG5FDKSF.bold)(
          (0, import_chunk_PG5FDKSF.green)(`${await (0, import_chunk_A46NX7MG.getPackageCmd)(baseDir2, "add", "@prisma/client")}`)
        )} and rerun ${(0, import_chunk_PG5FDKSF.bold)(await (0, import_chunk_A46NX7MG.getPackageCmd)(baseDir2, "execute", "prisma generate"))} \u{1F64F}.`
      );
    }
    console.info(
      `
\u2714 Installed the ${(0, import_chunk_PG5FDKSF.bold)((0, import_chunk_PG5FDKSF.green)("@prisma/client"))} and ${(0, import_chunk_PG5FDKSF.bold)((0, import_chunk_PG5FDKSF.green)("prisma"))} packages in your project`
    );
  }
  if (!prismaClientDir) {
    throw new Error(
      `Could not resolve @prisma/client.
Please try to install it with ${(0, import_chunk_PG5FDKSF.bold)((0, import_chunk_PG5FDKSF.green)("npm install @prisma/client"))} and rerun ${(0, import_chunk_PG5FDKSF.bold)(
        await (0, import_chunk_A46NX7MG.getPackageCmd)(baseDir2, "execute", "prisma generate")
      )} \u{1F64F}.`
    );
  }
  return {
    outputPath: prismaClientDir,
    generatorPath: import_path4.default.resolve(prismaClientDir, "generator-build/index.js"),
    isNode: true
  };
}
var generatorResolvers = {
  "prisma-client-js": prismaClientResolver
};
var debug5 = (0, import_debug4.default)("prisma:getGenerators");
async function getGenerators(options) {
  const {
    schemaPath,
    providerAliases: aliases,
    // do you get the pun?
    version,
    cliVersion,
    printDownloadProgress,
    baseDir = import_path3.default.dirname(schemaPath),
    overrideGenerators,
    skipDownload,
    binaryPathsOverride,
    generatorNames = [],
    postinstall,
    noEngine,
    allowNoModels
  } = options;
  if (!schemaPath) {
    throw new Error(`schemaPath for getGenerators got invalid value ${schemaPath}`);
  }
  let schemaResult = null;
  try {
    schemaResult = await getSchemaPath(schemaPath);
  } catch (_) {
    throw new Error(`${schemaPath} does not exist`);
  }
  const { schemas } = schemaResult;
  const binaryTarget = await (0, import_get_platform.getBinaryTargetForCurrentPlatform)();
  const queryEngineBinaryType = (0, import_engines.getCliQueryEngineBinaryType)();
  const queryEngineType = (0, import_chunk_RS2R7COT.binaryTypeToEngineType)(queryEngineBinaryType);
  let prismaPath = binaryPathsOverride?.[queryEngineType];
  if (version && !prismaPath) {
    const potentialPath = eval(`require('path').join(__dirname, '..')`);
    if (!potentialPath.match(import_chunk_M3GBKLGE.vercelPkgPathRegex)) {
      const downloadParams = {
        binaries: {
          [queryEngineBinaryType]: potentialPath
        },
        binaryTargets: [binaryTarget],
        showProgress: false,
        version,
        skipDownload
      };
      const binaryPathsWithEngineType = await (0, import_fetch_engine.download)(downloadParams);
      prismaPath = binaryPathsWithEngineType[queryEngineBinaryType][binaryTarget];
    }
  }
  const config = await (0, import_chunk_S3K6KTRH.getConfig)({
    datamodel: schemas,
    datamodelPath: schemaPath,
    prismaPath,
    ignoreEnvVarErrors: true
  });
  if (config.datasources.length === 0) {
    throw new Error(import_chunk_36RDCUXI.missingDatasource);
  }
  (0, import_chunk_5FJ3MENK.printConfigWarnings)(config.warnings);
  const previewFeatures = (0, import_chunk_TSJICM5S.extractPreviewFeatures)(config);
  const dmmf = await (0, import_chunk_45G7GPQ2.getDMMF)({
    datamodel: schemas,
    datamodelPath: schemaPath,
    prismaPath,
    previewFeatures
  });
  if (dmmf.datamodel.models.length === 0 && !allowNoModels) {
    if (config.datasources.some((d) => d.provider === "mongodb")) {
      throw new Error(import_chunk_MUGH66MS.missingModelMessageMongoDB);
    }
    throw new Error(import_chunk_MUGH66MS.missingModelMessage);
  }
  (0, import_chunk_IPKE37QC.checkFeatureFlags)(config, options);
  const generatorConfigs = filterGenerators(overrideGenerators || config.generators, generatorNames);
  await validateGenerators(generatorConfigs);
  const runningGenerators = [];
  try {
    const generators = await (0, import_p_map.default)(
      generatorConfigs,
      async (generator, index) => {
        let generatorPath = (0, import_chunk_IOIAK7V7.parseEnvValue)(generator.provider);
        let paths;
        const providerValue = (0, import_chunk_IOIAK7V7.parseEnvValue)(generator.provider);
        if (aliases && aliases[providerValue]) {
          generatorPath = aliases[providerValue].generatorPath;
          paths = aliases[providerValue];
        } else if (generatorResolvers[providerValue]) {
          paths = await generatorResolvers[providerValue](baseDir, cliVersion);
          generatorPath = paths.generatorPath;
        }
        const generatorInstance = new import_chunk_635TMBAP.Generator(generatorPath, generator, paths?.isNode);
        await generatorInstance.init();
        if (generator.output) {
          generator.output = {
            value: import_path3.default.resolve(baseDir, (0, import_chunk_IOIAK7V7.parseEnvValue)(generator.output)),
            fromEnvVar: null
          };
          generator.isCustomOutput = true;
        } else if (paths) {
          generator.output = {
            value: paths.outputPath,
            fromEnvVar: null
          };
        } else {
          if (!generatorInstance.manifest || !generatorInstance.manifest.defaultOutput) {
            throw new Error(
              `Can't resolve output dir for generator ${(0, import_chunk_PG5FDKSF.bold)(generator.name)} with provider ${(0, import_chunk_PG5FDKSF.bold)(
                generator.provider.value
              )}.
The generator needs to either define the \`defaultOutput\` path in the manifest or you need to define \`output\` in the datamodel.prisma file.`
            );
          }
          generator.output = {
            value: await (0, import_chunk_2B26F5N3.resolveOutput)({
              defaultOutput: generatorInstance.manifest.defaultOutput,
              baseDir
            }),
            fromEnvVar: "null"
          };
        }
        const datamodel = (0, import_chunk_NKTOLEDC.mergeSchemas)({ schemas });
        const options2 = {
          datamodel,
          datasources: config.datasources,
          generator,
          dmmf,
          otherGenerators: skipIndex(generatorConfigs, index),
          schemaPath,
          version: version || import_engines.enginesVersion,
          // this version makes no sense anymore and should be ignored
          postinstall,
          noEngine,
          allowNoModels
        };
        generatorInstance.setOptions(options2);
        runningGenerators.push(generatorInstance);
        return generatorInstance;
      },
      {
        stopOnError: false
        // needed so we can first make sure all generators are created properly, then cleaned up properly
      }
    );
    const generatorProviders = generatorConfigs.map((g) => (0, import_chunk_IOIAK7V7.parseEnvValue)(g.provider));
    for (const g of generators) {
      if (g.manifest && g.manifest.requiresGenerators && g.manifest.requiresGenerators.length > 0) {
        for (const neededGenerator of g.manifest.requiresGenerators) {
          if (!generatorProviders.includes(neededGenerator)) {
            throw new Error(
              `Generator "${g.manifest.prettyName}" requires generator "${neededGenerator}", but it is missing in your schema.prisma.
Please add it to your schema.prisma:

generator gen {
  provider = "${neededGenerator}"
}
`
            );
          }
        }
      }
    }
    const neededVersions = /* @__PURE__ */ Object.create(null);
    for (const g of generators) {
      if (g.manifest && g.manifest.requiresEngines && Array.isArray(g.manifest.requiresEngines) && g.manifest.requiresEngines.length > 0) {
        const neededVersion = (0, import_chunk_X3P4J7WW.getEngineVersionForGenerator)(g.manifest, version);
        if (!neededVersions[neededVersion]) {
          neededVersions[neededVersion] = { engines: [], binaryTargets: [] };
        }
        for (const engine of g.manifest.requiresEngines) {
          if (!neededVersions[neededVersion].engines.includes(engine)) {
            neededVersions[neededVersion].engines.push(engine);
          }
        }
        const generatorBinaryTargets = g.options?.generator?.binaryTargets;
        if (generatorBinaryTargets && generatorBinaryTargets.length > 0) {
          for (const binaryTarget2 of generatorBinaryTargets) {
            if (!neededVersions[neededVersion].binaryTargets.find((object) => object.value === binaryTarget2.value)) {
              neededVersions[neededVersion].binaryTargets.push(binaryTarget2);
            }
          }
        }
      }
    }
    debug5("neededVersions", JSON.stringify(neededVersions, null, 2));
    const binaryPathsByVersion = await (0, import_chunk_6AHD2V6O.getBinaryPathsByVersion)({
      neededVersions,
      binaryTarget,
      version,
      printDownloadProgress,
      skipDownload,
      binaryPathsOverride
    });
    for (const generator of generators) {
      if (generator.manifest && generator.manifest.requiresEngines) {
        const engineVersion = (0, import_chunk_X3P4J7WW.getEngineVersionForGenerator)(generator.manifest, version);
        const binaryPaths = binaryPathsByVersion[engineVersion];
        const generatorBinaryPaths = (0, import_chunk_5V36RLCO.pick)(binaryPaths, generator.manifest.requiresEngines);
        debug5({ generatorBinaryPaths });
        generator.setBinaryPaths(generatorBinaryPaths);
        if (engineVersion !== version && generator.options && generator.manifest.requiresEngines.includes(queryEngineType) && generatorBinaryPaths[queryEngineType] && generatorBinaryPaths[queryEngineType]?.[binaryTarget]) {
          const customDmmf = await (0, import_chunk_45G7GPQ2.getDMMF)({
            datamodel: schemas,
            datamodelPath: schemaPath,
            prismaPath: generatorBinaryPaths[queryEngineType]?.[binaryTarget],
            previewFeatures
          });
          const options2 = { ...generator.options, dmmf: customDmmf };
          debug5("generator.manifest.prettyName", generator.manifest.prettyName);
          debug5("options", options2);
          debug5("options.generator.binaryTargets", options2.generator.binaryTargets);
          generator.setOptions(options2);
        }
      }
    }
    return generators;
  } catch (e) {
    runningGenerators.forEach((g) => g.stop());
    throw e;
  }
}
async function getGenerator(options2) {
  const generators = await getGenerators(options2);
  return generators[0];
}
function skipIndex(arr, index) {
  return [...arr.slice(0, index), ...arr.slice(index + 1)];
}
var knownBinaryTargets = [...import_get_platform.binaryTargets, "native"];
var oldToNewBinaryTargetsMapping = {
  "linux-glibc-libssl1.0.1": "debian-openssl-1.0.x",
  "linux-glibc-libssl1.0.2": "debian-openssl-1.0.x",
  "linux-glibc-libssl1.1.0": "debian-openssl1.1.x"
};
async function validateGenerators(generators) {
  const binaryTarget2 = await (0, import_get_platform.getBinaryTargetForCurrentPlatform)();
  for (const generator of generators) {
    if (generator.config.platforms) {
      throw new Error(
        `The \`platforms\` field on the generator definition is deprecated. Please rename it to \`binaryTargets\`.`
      );
    }
    if (generator.config.pinnedBinaryTargets) {
      throw new Error(
        `The \`pinnedBinaryTargets\` field on the generator definition is deprecated.
Please use the PRISMA_QUERY_ENGINE_BINARY env var instead to pin the binary target.`
      );
    }
    if (generator.binaryTargets) {
      const binaryTargets2 = generator.binaryTargets && generator.binaryTargets.length > 0 ? generator.binaryTargets : [{ fromEnvVar: null, value: "native" }];
      const resolvedBinaryTargets = binaryTargets2.flatMap((object) => (0, import_chunk_IOIAK7V7.parseBinaryTargetsEnvValue)(object)).map((p) => p === "native" ? binaryTarget2 : p);
      for (const resolvedBinaryTarget of resolvedBinaryTargets) {
        if (oldToNewBinaryTargetsMapping[resolvedBinaryTarget]) {
          throw new Error(
            `Binary target ${(0, import_chunk_PG5FDKSF.red)((0, import_chunk_PG5FDKSF.bold)(resolvedBinaryTarget))} is deprecated. Please use ${(0, import_chunk_PG5FDKSF.green)(
              (0, import_chunk_PG5FDKSF.bold)(oldToNewBinaryTargetsMapping[resolvedBinaryTarget])
            )} instead.`
          );
        }
        if (!knownBinaryTargets.includes(resolvedBinaryTarget)) {
          throw new Error(
            `Unknown binary target ${(0, import_chunk_PG5FDKSF.red)(resolvedBinaryTarget)} in generator ${(0, import_chunk_PG5FDKSF.bold)(generator.name)}.
Possible binaryTargets: ${(0, import_chunk_PG5FDKSF.green)(knownBinaryTargets.join(", "))}`
          );
        }
      }
      if (!resolvedBinaryTargets.includes(binaryTarget2)) {
        const originalBinaryTargetsConfig = (0, import_chunk_TCKF2JY6.getOriginalBinaryTargetsValue)(generator.binaryTargets);
        console.log(`${(0, import_chunk_PG5FDKSF.yellow)("Warning:")} Your current platform \`${(0, import_chunk_PG5FDKSF.bold)(
          binaryTarget2
        )}\` is not included in your generator's \`binaryTargets\` configuration ${JSON.stringify(
          originalBinaryTargetsConfig
        )}.
To fix it, use this generator config in your ${(0, import_chunk_PG5FDKSF.bold)("schema.prisma")}:
${(0, import_chunk_PG5FDKSF.green)(
          (0, import_chunk_TCKF2JY6.printGeneratorConfig)({
            ...generator,
            binaryTargets: (0, import_chunk_X77CS5RK.fixBinaryTargets)(generator.binaryTargets, binaryTarget2)
          })
        )}
${(0, import_chunk_PG5FDKSF.gray)(
          `Note, that by providing \`native\`, Prisma Client automatically resolves \`${binaryTarget2}\`.
Read more about deploying Prisma Client: ${(0, import_chunk_PG5FDKSF.underline)(
            "https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-schema/generators"
          )}`
        )}
`);
      }
    }
  }
}
function filterGenerators(generators, generatorNames2) {
  if (generatorNames2.length < 1) {
    return generators;
  }
  const filtered = generators.filter((generator) => generatorNames2.includes(generator.name));
  if (filtered.length !== generatorNames2.length) {
    const missings = generatorNames2.filter((name) => filtered.find((generator) => generator.name === name) == null);
    const isSingular = missings.length <= 1;
    throw new Error(
      `The ${isSingular ? "generator" : "generators"} ${(0, import_chunk_PG5FDKSF.bold)(missings.join(", "))} specified via ${(0, import_chunk_PG5FDKSF.bold)(
        "--generator"
      )} ${isSingular ? "does" : "do"} not exist in your Prisma schema`
    );
  }
  return filtered;
}
var debug6 = (0, import_debug.default)("prisma:format");
async function formatSchema({ schemas: schemas2 }, inputFormattingOptions) {
  if (process.env.FORCE_PANIC_PRISMA_SCHEMA) {
    handleFormatPanic(
      () => {
        import_chunk_7SZOUC3T.prismaSchemaWasm.debug_panic();
      },
      { schemas: schemas2 }
    );
  }
  const defaultFormattingOptions = {
    tabSize: 2,
    insertSpaces: true
  };
  const documentFormattingParams = {
    textDocument: { uri: "file:/dev/null" },
    options: {
      ...defaultFormattingOptions,
      ...inputFormattingOptions
    }
  };
  const { formattedMultipleSchemas, lintDiagnostics } = handleFormatPanic(
    () => {
      const formattedMultipleSchemasRaw = formatWasm(JSON.stringify(schemas2), documentFormattingParams);
      const formattedMultipleSchemas2 = JSON.parse(formattedMultipleSchemasRaw);
      const lintDiagnostics2 = (0, import_chunk_ZKZBTR2H.lintSchema)({ schemas: formattedMultipleSchemas2 });
      return { formattedMultipleSchemas: formattedMultipleSchemas2, lintDiagnostics: lintDiagnostics2 };
    },
    { schemas: schemas2 }
  );
  const lintWarnings = (0, import_chunk_ZKZBTR2H.getLintWarningsAsText)(lintDiagnostics);
  if (lintWarnings && import_chunk_TOTPZIKH.logger_exports.should.warn()) {
    console.warn(lintWarnings);
  }
  return Promise.resolve(formattedMultipleSchemas);
}
function handleFormatPanic(tryCb, { schemas: schemas2 }) {
  try {
    return tryCb();
  } catch (e) {
    const { message, stack } = (0, import_chunk_A4QWQE3W.getWasmError)(e);
    debug6(`Error formatting schema: ${message}`);
    debug6(stack);
    const panic = new import_chunk_A4QWQE3W.RustPanic(
      /* message */
      message,
      /* rustStack */
      stack,
      /* request */
      "@prisma/prisma-schema-wasm format",
      "FMT_CLI",
      /* schemaPath */
      (0, import_chunk_URGOXRQA.debugMultipleSchemaPaths)(schemas2),
      /* schema */
      (0, import_chunk_URGOXRQA.debugMultipleSchemas)(schemas2)
    );
    throw panic;
  }
}
function formatWasm(schema, documentFormattingParams) {
  const formattedSchema = import_chunk_7SZOUC3T.prismaSchemaWasm.format(schema, JSON.stringify(documentFormattingParams));
  return formattedSchema;
}
